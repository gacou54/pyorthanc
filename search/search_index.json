{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyOrthanc","text":"<p>PyOrthanc is a Python client for the Orthanc REST API. It provides:</p> <ul> <li>Complete wrapping of the Orthanc REST API methods</li> <li>High-level utilities for common DICOM operations</li> <li>Asynchronous client support</li> <li>Helper functions for working with DICOM data</li> <li>Integration with the Orthanc Python plugin</li> </ul>"},{"location":"#why-pyorthanc","title":"Why PyOrthanc?","text":"<p>PyOrthanc makes it easy to work with DICOM medical images stored on Orthanc servers using Python - instead  of dealing with the DICOM protocol directly or creating complex code to interact with Orthanc's REST API.</p> <p>Researchers and clinicians can make simple Python script to access and manage their medical imaging data. </p> <p>Advanced users can use PyOrthanc to make Orthanc query a hospital PACS (Picture Archiving and Communication System). This allows to find and retrieve images produced in the clinic for research or quality control purposes.  Additionally, since PyOrthanc simplifies Orthanc's anonymization operations,  an entire medical image management workflow can be implemented in Python.</p>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code>pip install pyorthanc        # Basic installation\npip install pyorthanc[all]   # Install all optional dependencies (progr)\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from pyorthanc import Orthanc, upload\n\n# Connect to Orthanc server\nclient = Orthanc('http://localhost:8042')\n# Or with authentication:\nclient = Orthanc('http://localhost:8042', username='orthanc', password='orthanc')\n\n# Basic operations\npatient_ids = client.get_patients()\nstudies = client.get_studies() \n\n# Upload DICOM files\nupload(client, 'image.dcm')  # From a file\nupload(client, 'dicom_files.zip')  # From a zip\nupload(client, 'path/to/directory')  # Upload all dicom files in a directory\nupload(client, 'path/to/directory', recursive=True)  # Upload all dicom files in a directory recursively\n# Check if dicom is in Orthanc before upload\nupload(client, 'path/to/directory', recursive=True, check_before_upload=True)\n</code></pre>"},{"location":"#working-with-dicom-modalities","title":"Working with DICOM Modalities","text":"<pre><code>from pyorthanc import Modality\n\n# Create modality connection\nmodality = Modality(client, 'REMOTE_PACS')\n\n# Test connection with C-ECHO\nif modality.echo():\n    print(\"Successfully connected to PACS\")\n\n# Query studies with C-FIND\nresponse = modality.find({\n    'Level': 'Study',\n    'Query': {\n        'PatientID': '12345*',\n        'StudyDate': '20230101-20231231'\n    }\n})\n\n# Matches (i.e. answers in Orthanc nomenclature) can be reviewed before retrieving results\nresponse['answers']\n\n# Retrieve results with C-MOVE to a target AET\nmodality.move(response['ID'], {'TargetAet': 'ORTHANC'})\n</code></pre>"},{"location":"#finding-and-processing-dicom-data","title":"Finding and Processing DICOM Data","text":"<pre><code>from pyorthanc import find_patients\n\n# Search for patients\npatients = find_patients(\n    client,\n    query={'PatientName': '*Gabriel'},\n    labels=['research']  # It is also possible to filter by labels\n)\n\n# Process patient data\nfor patient in patients:\n    print(f\"Patient: {patient.name} (ID: {patient.patient_id})\")\n    print(f\"Birth Date: {patient.birth_date}\")\n    print(f\"Labels: {patient.labels}\")\n\n    # Access studies\n    for study in patient.studies:\n        print(f\"\\nStudy Date: {study.date}\")\n        print(f\"Description: {study.description}\")\n\n        # Access series\n        for series in study.series:\n            print(f\"\\nModality: {series.modality}\")\n            print(f\"Series Description: {series.description}\")\n\n            # Access individual DICOM instances\n            for instance in series.instances:\n                # Convert to pydicom dataset\n                ds = instance.get_pydicom()\n                # Process DICOM data...\n</code></pre>"},{"location":"#using-pyorthanc-within-orthanc","title":"Using pyorthanc within Orthanc","text":"<p>Use the <code>orthanc_sdk</code> module when using Orthanc's Python plugin. <code>orthanc_sdk</code> acts as the same as <code>orthanc</code>, but it provides type hints and autocompletion.  For example:</p> <pre><code>import json\nfrom pyorthanc import orthanc_sdk, get_internal_client, find_series\n\n# Register a new REST endpoint\ndef handle_api(output: orthanc_sdk.RestOutput, uri: str, **request):\n    \"\"\"Handle REST API request\"\"\"\n    if request['method'] == 'GET':\n        output.AnswerBuffer('Hello from plugin!', 'text/plain')\n    else:\n        output.SendMethodNotAllowed('GET')\n\northanc_sdk.RegisterRestCallback('/hello-world', handle_api)\n\n# Handle incoming DICOM\ndef on_store(dicom: orthanc_sdk.DicomInstance, instance_id: str):\n    \"\"\"Process stored DICOM instances\"\"\"\n    print(f'Received instance {instance_id}')\n    print(f'Size: {dicom.GetInstanceSize()} bytes')\n    print(f'Transfer Syntax: {dicom.GetInstanceTransferSyntaxUid()}')\n\northanc_sdk.RegisterOnStoredInstanceCallback(on_store)\n\n# Use the `pyorthanc.Orthanc()` inside Orthanc\ndef get_modalities_in_orthanc(output: orthanc_sdk.RestOutput, *_, **__):\n    client = get_internal_client()  # This returns a `pyorthanc.Orthanc`\n\n    # Don't use in a very large collection \n    series = find_series(client)\n    modalities_in_orthanc = set([s.modality for s in series])\n\n    output.AnswerBuffer(\n        json.dumps({'modalities': list(modalities_in_orthanc)}),\n        'application/json'\n    )\n\northanc_sdk.RegisterRestCallback('/get-modalities-in-orthanc', get_modalities_in_orthanc) \n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Typical example can be found in these notebooks. -  This notebook shows    how a user can query image data from an Orthanc server -  This notebook shows    how a user can query and pull data from other modality (such as a CT scan or a PACS) connected to an Orthanc Server.</p>"},{"location":"#cheat-sheet","title":"Cheat sheet","text":""},{"location":"#first-steps","title":"First steps","text":""},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>Import pyorthanc library</li> <li>Connect to Orthanc</li> <li>Upload DICOM files to Orthanc:</li> <li>Getting list of connected remote modalities:</li> <li>Find and download patients according to criteria:</li> <li>Query (C-Find) and Retrieve (C-Move) from remote modality:</li> </ul>"},{"location":"#examples_1","title":"Examples","text":"<ul> <li>Query and access data in an Orthanc Sever</li> <li>Interact with a connected modality</li> <li>Transfer data from a PACS to an Orthanc server</li> </ul>"},{"location":"#community-guidelines","title":"Community guidelines","text":"<ul> <li>Report an issue</li> <li>Support</li> <li>Contribute</li> </ul>"},{"location":"#releases","title":"Releases","text":""},{"location":"#contacts","title":"Contacts","text":"<ul> <li>Maintainers Team</li> <li>Useful links</li> </ul>"},{"location":"#citation","title":"Citation","text":""},{"location":"cheat_sheet/","title":"Cheat sheet","text":"<p>Orthanc has a very useful cheat sheet for finding functionalities and REST API routes.  This page contains the mappings between REST API paths and methods in the <code>pyorthanc.Orthanc</code> class.</p> <p>Note that <code>pyorthanc.Orthanc</code> is the low level client with which users can interact with Orthanc. Higher level functionalities such as Patient, Study, Series,  Instance, find_patients/studies/series/instances, or Modality might be more convenient to use.</p> Path GET POST DELETE PUT Summary <code>/changes</code> here - here - List changes <code>/exports</code> here - here - List exports <code>/instances</code> here here - - List the available instances <code>/instances/{id}</code> here - here - Get information about some instance <code>/instances/{id}/anonymize</code> - here - - Anonymize instance <code>/instances/{id}/attachments</code> here - - - List attachments <code>/instances/{id}/attachments/{name}</code> here - here here List operations on attachments <code>/instances/{id}/attachments/{name}/compress</code> - here - - Compress attachment <code>/instances/{id}/attachments/{name}/compressed-data</code> here - - - Get attachment <code>/instances/{id}/attachments/{name}/compressed-md5</code> here - - - Get MD5 of attachment on disk <code>/instances/{id}/attachments/{name}/compressed-size</code> here - - - Get size of attachment on disk <code>/instances/{id}/attachments/{name}/data</code> here - - - Get attachment <code>/instances/{id}/attachments/{name}/info</code> here - - - Get info about the attachment <code>/instances/{id}/attachments/{name}/is-compressed</code> here - - - Is attachment compressed? <code>/instances/{id}/attachments/{name}/md5</code> here - - - Get MD5 of attachment <code>/instances/{id}/attachments/{name}/size</code> here - - - Get size of attachment <code>/instances/{id}/attachments/{name}/uncompress</code> - here - - Uncompress attachment <code>/instances/{id}/attachments/{name}/verify-md5</code> - here - - Verify attachment <code>/instances/{id}/content/{path}</code> here - - - Get raw tag <code>/instances/{id}/export</code> - here - - Write DICOM onto filesystem <code>/instances/{id}/file</code> here - - - Download DICOM <code>/instances/{id}/frames</code> here - - - List available frames <code>/instances/{id}/frames/{frame}</code> here - - - List operations <code>/instances/{id}/frames/{frame}/image-int16</code> here - - - Decode a frame <code>/instances/{id}/frames/{frame}/image-uint16</code> here - - - Decode a frame <code>/instances/{id}/frames/{frame}/image-uint8</code> here - - - Decode a frame <code>/instances/{id}/frames/{frame}/matlab</code> here - - - Decode frame for Matlab <code>/instances/{id}/frames/{frame}/numpy</code> here - - - Decode frame for numpy <code>/instances/{id}/frames/{frame}/preview</code> here - - - Decode a frame <code>/instances/{id}/frames/{frame}/raw</code> here - - - Access raw frame <code>/instances/{id}/frames/{frame}/raw.gz</code> here - - - Access raw frame <code>/instances/{id}/frames/{frame}/rendered</code> here - - - Render a frame <code>/instances/{id}/header</code> here - - - Get DICOM meta-header <code>/instances/{id}/image-int16</code> here - - - Decode an image <code>/instances/{id}/image-uint16</code> here - - - Decode an image <code>/instances/{id}/image-uint8</code> here - - - Decode an image <code>/instances/{id}/labels</code> here - - - List labels <code>/instances/{id}/labels/{label}</code> here - here here Test label <code>/instances/{id}/matlab</code> here - - - Decode frame for Matlab <code>/instances/{id}/metadata</code> here - - - List metadata <code>/instances/{id}/metadata/{name}</code> here - here here Get metadata <code>/instances/{id}/modify</code> - here - - Modify instance <code>/instances/{id}/module</code> here - - - Get instance module <code>/instances/{id}/numpy</code> here - - - Decode instance for numpy <code>/instances/{id}/patient</code> here - - - Get parent patient <code>/instances/{id}/pdf</code> here - - - Get embedded PDF <code>/instances/{id}/preview</code> here - - - Decode an image <code>/instances/{id}/reconstruct</code> - here - - Reconstruct tags &amp; optionally files of instance <code>/instances/{id}/rendered</code> here - - - Render an image <code>/instances/{id}/series</code> here - - - Get parent series <code>/instances/{id}/simplified-tags</code> here - - - Get human-readable tags <code>/instances/{id}/statistics</code> here - - - Get instance statistics <code>/instances/{id}/study</code> here - - - Get parent study <code>/instances/{id}/tags</code> here - - - Get DICOM tags <code>/jobs</code> here - - - List jobs <code>/jobs/{id}</code> here - here - Get job <code>/jobs/{id}/cancel</code> - here - - Cancel job <code>/jobs/{id}/pause</code> - here - - Pause job <code>/jobs/{id}/resubmit</code> - here - - Resubmit job <code>/jobs/{id}/resume</code> - here - - Resume job <code>/jobs/{id}/{key}</code> here - here - Get job output <code>/modalities</code> here - - - List DICOM modalities <code>/modalities/{id}</code> here - here here List operations on modality <code>/modalities/{id}/configuration</code> here - - - Get modality configuration <code>/modalities/{id}/echo</code> - here - - Trigger C-ECHO SCU <code>/modalities/{id}/find</code> - here - - Hierarchical C-FIND SCU <code>/modalities/{id}/find-instance</code> - here - - C-FIND SCU for instances <code>/modalities/{id}/find-patient</code> - here - - C-FIND SCU for patients <code>/modalities/{id}/find-series</code> - here - - C-FIND SCU for series <code>/modalities/{id}/find-study</code> - here - - C-FIND SCU for studies <code>/modalities/{id}/find-worklist</code> - here - - C-FIND SCU for worklist <code>/modalities/{id}/move</code> - here - - Trigger C-MOVE SCU <code>/modalities/{id}/query</code> - here - - Trigger C-FIND SCU <code>/modalities/{id}/storage-commitment</code> - here - - Trigger storage commitment request <code>/modalities/{id}/store</code> - here - - Trigger C-STORE SCU <code>/modalities/{id}/store-straight</code> - here - - Straight C-STORE SCU <code>/patients</code> here - - - List the available patients <code>/patients/{id}</code> here - here - Get information about some patient <code>/patients/{id}/anonymize</code> - here - - Anonymize patient <code>/patients/{id}/archive</code> here here - - Create ZIP archive <code>/patients/{id}/attachments</code> here - - - List attachments <code>/patients/{id}/attachments/{name}</code> here - here here List operations on attachments <code>/patients/{id}/attachments/{name}/compress</code> - here - - Compress attachment <code>/patients/{id}/attachments/{name}/compressed-data</code> here - - - Get attachment <code>/patients/{id}/attachments/{name}/compressed-md5</code> here - - - Get MD5 of attachment on disk <code>/patients/{id}/attachments/{name}/compressed-size</code> here - - - Get size of attachment on disk <code>/patients/{id}/attachments/{name}/data</code> here - - - Get attachment <code>/patients/{id}/attachments/{name}/info</code> here - - - Get info about the attachment <code>/patients/{id}/attachments/{name}/is-compressed</code> here - - - Is attachment compressed? <code>/patients/{id}/attachments/{name}/md5</code> here - - - Get MD5 of attachment <code>/patients/{id}/attachments/{name}/size</code> here - - - Get size of attachment <code>/patients/{id}/attachments/{name}/uncompress</code> - here - - Uncompress attachment <code>/patients/{id}/attachments/{name}/verify-md5</code> - here - - Verify attachment <code>/patients/{id}/instances</code> here - - - Get child instances <code>/patients/{id}/instances-tags</code> here - - - Get tags of instances <code>/patients/{id}/labels</code> here - - - List labels <code>/patients/{id}/labels/{label}</code> here - here here Test label <code>/patients/{id}/media</code> here here - - Create DICOMDIR media <code>/patients/{id}/metadata</code> here - - - List metadata <code>/patients/{id}/metadata/{name}</code> here - here here Get metadata <code>/patients/{id}/modify</code> - here - - Modify patient <code>/patients/{id}/module</code> here - - - Get patient module <code>/patients/{id}/protected</code> here - - here Is the patient protected against recycling? <code>/patients/{id}/reconstruct</code> - here - - Reconstruct tags &amp; optionally files of patient <code>/patients/{id}/series</code> here - - - Get child series <code>/patients/{id}/shared-tags</code> here - - - Get shared tags <code>/patients/{id}/statistics</code> here - - - Get patient statistics <code>/patients/{id}/studies</code> here - - - Get child studies <code>/peers</code> here - - - List Orthanc peers <code>/peers/{id}</code> here - here here List operations on peer <code>/peers/{id}/configuration</code> here - - - Get peer configuration <code>/peers/{id}/store</code> - here - - Send to Orthanc peer <code>/peers/{id}/store-straight</code> - here - - Straight store to peer <code>/peers/{id}/system</code> here - - - Get peer system information <code>/plugins</code> here - - - List plugins <code>/plugins/explorer.js</code> here - - - JavaScript extensions to Orthanc Explorer <code>/plugins/{id}</code> here - - - Get plugin <code>/queries</code> here - - - List query/retrieve operations <code>/queries/{id}</code> here - here - List operations on a query <code>/queries/{id}/answers</code> here - - - List answers to a query <code>/queries/{id}/answers/{index}</code> here - - - List operations on an answer <code>/queries/{id}/answers/{index}/content</code> here - - - Get answer content <code>/queries/{id}/answers/{index}/retrieve</code> - here - - Retrieve answer <code>/queries/{id}/level</code> here - - - Get query level <code>/queries/{id}/modality</code> here - - - Get query modality <code>/queries/{id}/query</code> here - - - Get query arguments <code>/queries/{id}/retrieve</code> - here - - Retrieve all answers <code>/series</code> here - - - List the available series <code>/series/{id}</code> here - here - Get information about series <code>/series/{id}/anonymize</code> - here - - Anonymize series <code>/series/{id}/archive</code> here here - - Create ZIP archive <code>/series/{id}/attachments</code> here - - - List attachments <code>/series/{id}/attachments/{name}</code> here - here here List operations on attachments <code>/series/{id}/attachments/{name}/compress</code> - here - - Compress attachment <code>/series/{id}/attachments/{name}/compressed-data</code> here - - - Get attachment <code>/series/{id}/attachments/{name}/compressed-md5</code> here - - - Get MD5 of attachment on disk <code>/series/{id}/attachments/{name}/compressed-size</code> here - - - Get size of attachment on disk <code>/series/{id}/attachments/{name}/data</code> here - - - Get attachment <code>/series/{id}/attachments/{name}/info</code> here - - - Get info about attachment <code>/series/{id}/attachments/{name}/is-compressed</code> here - - - Is attachment compressed? <code>/series/{id}/attachments/{name}/md5</code> here - - - Get MD5 of attachment <code>/series/{id}/attachments/{name}/size</code> here - - - Get size of attachment <code>/series/{id}/attachments/{name}/uncompress</code> - here - - Uncompress attachment <code>/series/{id}/attachments/{name}/verify-md5</code> - here - - Verify attachment <code>/series/{id}/instances</code> here - - - Get child instances <code>/series/{id}/instances-tags</code> here - - - Get tags of instances <code>/series/{id}/labels</code> here - - - List labels <code>/series/{id}/labels/{label}</code> here - here here Test label <code>/series/{id}/media</code> here here - - Create DICOMDIR media <code>/series/{id}/metadata</code> here - - - List metadata <code>/series/{id}/metadata/{name}</code> here - here here Get metadata <code>/series/{id}/modify</code> - here - - Modify series <code>/series/{id}/module</code> here - - - Get series module <code>/series/{id}/ordered-sliced</code> here - - - Order slices <code>/series/{id}/patient</code> here - - - Get parent patient <code>/series/{id}/reconstruct</code> - here - - Reconstruct tags &amp; optionally files <code>/series/{id}/shared-tags</code> here - - - Get shared tags <code>/series/{id}/statistics</code> here - - - Get series statistics <code>/series/{id}/study</code> here - - - Get parent study <code>/statistics</code> here - - - Get database statistics <code>/studies</code> here - - - List available studies <code>/studies/{id}</code> here - here - Get information about study <code>/studies/{id}/anonymize</code> - here - - Anonymize study <code>/studies/{id}/archive</code> here here - - Create ZIP archive <code>/studies/{id}/attachments</code> here - - - List attachments <code>/studies/{id}/attachments/{name}</code> here - here here List operations on attachments <code>/studies/{id}/attachments/{name}/compress</code> - here - - Compress attachment <code>/studies/{id}/attachments/{name}/compressed-data</code> here - - - Get attachment <code>/studies/{id}/attachments/{name}/compressed-md5</code> here - - - Get MD5 of attachment on disk <code>/studies/{id}/attachments/{name}/compressed-size</code> here - - - Get size of attachment on disk <code>/studies/{id}/attachments/{name}/data</code> here - - - Get attachment <code>/studies/{id}/attachments/{name}/info</code> here - - - Get info about attachment <code>/studies/{id}/attachments/{name}/is-compressed</code> here - - - Is attachment compressed? <code>/studies/{id}/attachments/{name}/md5</code> here - - - Get MD5 of attachment <code>/studies/{id}/attachments/{name}/size</code> here - - - Get size of attachment <code>/studies/{id}/attachments/{name}/uncompress</code> - here - - Uncompress attachment <code>/studies/{id}/attachments/{name}/verify-md5</code> - here - - Verify attachment <code>/studies/{id}/instances</code> here - - - Get child instances <code>/studies/{id}/instances-tags</code> here - - - Get tags of instances <code>/studies/{id}/labels</code> here - - - List labels <code>/studies/{id}/labels/{label}</code> here - here here Test label <code>/studies/{id}/media</code> here here - - Create DICOMDIR media <code>/studies/{id}/metadata</code> here - - - List metadata <code>/studies/{id}/metadata/{name}</code> here - here here Get metadata <code>/studies/{id}/modify</code> - here - - Modify study <code>/studies/{id}/module</code> here - - - Get study module <code>/studies/{id}/module-patient</code> here - - - Get patient module <code>/studies/{id}/patient</code> here - - - Get parent patient <code>/studies/{id}/reconstruct</code> - here - - Reconstruct tags &amp; optionally files <code>/studies/{id}/series</code> here - - - Get child series <code>/studies/{id}/shared-tags</code> here - - - Get shared tags <code>/studies/{id}/statistics</code> here - - - Get study statistics <code>/system</code> here - - - Get system information <code>/tools/accepted-transfer-syntaxes</code> here - - here Get/set accepted transfer syntaxes <code>/tools/bulk-content</code> - here - - Bulk content modifications <code>/tools/bulk-delete</code> - here - - Bulk delete <code>/tools/bulk-modify</code> - here - - Bulk modifications <code>/tools/create-archive</code> - here - - Create ZIP archive <code>/tools/create-dicom</code> - here - - Create one DICOM instance <code>/tools/create-media</code> - here - - Create DICOMDIR media <code>/tools/default-encoding</code> here - - here Get/set default encoding <code>/tools/dicom-conformance</code> here - - - Get DICOM conformance statement <code>/tools/execute-script</code> - here - - Execute Lua script <code>/tools/find</code> - here - - Look for local resources <code>/tools/generate-uid</code> here - - - Generate DICOM UID <code>/tools/lookup</code> - here - - Look for DICOM identifiers <code>/tools/metrics</code> here - - - Get real-time metrics <code>/tools/metrics-prometheus</code> here - - - Get metrics for Prometheus <code>/tools/now</code> here - - - Get UTC time <code>/tools/reconstruct</code> - here - - Reconstruct database <code>/tools/reset</code> - here - - Reset Orthanc <code>/tools/shutdown</code> - here - - Shutdown Orthanc <code>/tools/unknown-sop-class-accepted</code> here - - here Get/set unknown SOP class acceptance"},{"location":"citation/","title":"Citation","text":"<p>If you use PyOrthanc in your research or publications, please cite our work.</p> <ul> <li>JOSS Paper: </li> <li>Zenodo DOI: </li> </ul>"},{"location":"contacts/","title":"Contacts","text":""},{"location":"contacts/#maintainers-team","title":"Maintainers Team","text":"<ul> <li>Developer: Gabriel Couture, Yannick Lemar\u00e9chal</li> </ul>"},{"location":"contacts/#useful-links","title":"Useful links","text":"<ul> <li>Orthanc</li> <li>PARADIM</li> </ul>"},{"location":"contributing/","title":"Contribute","text":""},{"location":"contributing/#report-an-issue","title":"Report an issue","text":"<p>You can open an issue here explaining your issue.</p>"},{"location":"contributing/#seeking-support","title":"Seeking support","text":"<p>You can open an issue here to ask a question.</p>"},{"location":"contributing/#contribute_1","title":"Contribute","text":"<p>You can contribute a fix or a new feature to this project with the following steps:</p> <ol> <li> <p>First, fork the project on GitHub</p> </li> <li> <p>Clone the project</p> </li> </ol> <pre><code>    git clone https://github.com/&lt;your-github-username&gt;/pyorthanc\n</code></pre> <ol> <li>Enter the project and create a poetry environment     (this project use the poetry for dependency management).</li> </ol> <pre><code>   cd pyorthanc\n</code></pre> <pre><code>   peotry install \n</code></pre> <ol> <li>Make a new git branch where you will apply the changes</li> </ol> <pre><code>    git checkout -b your-branch-name\n</code></pre> <ol> <li> <p>Once done, <code>git add</code>, <code>git commit</code> and <code>git push</code> the changes.</p> </li> <li> <p>Make a Pull Request from your branch to the pyorthanc repository.</p> </li> </ol>"},{"location":"releases/","title":"Releases","text":"<p>See https://github.com/gacou54/pyorthanc/releases</p>"},{"location":"api/async_client/","title":"Asynchronous Orthanc","text":""},{"location":"api/async_client/#pyorthanc.AsyncOrthanc","title":"<code>pyorthanc.AsyncOrthanc</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>Orthanc API</p> <p>version 1.12.6 This is the full documentation of the REST API of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A shorter cheat sheet is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is still available, but is not up-to-date anymore (source).</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>class AsyncOrthanc(httpx.AsyncClient):\n    \"\"\"Orthanc API\n\n    version 1.12.6\n    This is the full documentation of the [REST API](https://orthanc.uclouvain.be/book/users/rest.html) of Orthanc.&lt;p&gt;This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://orthanc.uclouvain.be/book/users/rest-cheatsheet.html) is part of the Orthanc Book.&lt;p&gt;An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).\n\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        return_raw_response: bool = False,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        url\n            server's URL\n        username\n            Orthanc's username\n        password\n            Orthanc's password\n        return_raw_response\n            All Orthanc's methods will return a raw httpx.Response rather than the serialized result\n        *args, **kwargs\n            Parameters passed to the httpx.Client (headers, timeout, etc.)\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.url = url\n        self.version = \"1.12.6\"\n        self.return_raw_response = return_raw_response\n\n        if username and password:\n            self.setup_credentials(username, password)\n\n    def setup_credentials(self, username: str, password: str) -&gt; None:\n        \"\"\"Set credentials needed for HTTP requests\"\"\"\n        self._auth = httpx.BasicAuth(username, password)\n\n    async def _get(\n        self,\n        route: str,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"GET request with specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        params\n            Parameters for the HTTP request.\n        headers\n            Headers for the HTTP request.\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP GET request or httpx.Response.\n        \"\"\"\n        response = await self.get(\n            url=route, params=params, headers=headers, cookies=cookies\n        )\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with content: {response.text}\"\n        )\n\n    async def _delete(\n        self,\n        route: str,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"DELETE to specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        params\n            Parameters for the HTTP request.\n        headers\n            Headers for the HTTP request.\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP DELETE request or httpx.Response.\n        \"\"\"\n        response = await self.delete(\n            route, params=params, headers=headers, cookies=cookies\n        )\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with content: {response.text}\"\n        )\n\n    async def _post(\n        self,\n        route: str,\n        content: Optional[RequestContent] = None,\n        data: Optional[RequestData] = None,\n        files: Optional[RequestFiles] = None,\n        json: Optional[Any] = None,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"POST to specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        content\n        data\n            Dictionary to send in the body of request.\n        files\n        json\n        params\n        headers\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP POST request or httpx.Response.\n        \"\"\"\n        response = await self.post(\n            route,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n        )\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with text: {response.text}\"\n        )\n\n    async def _put(\n        self,\n        route: str,\n        content: RequestContent = None,\n        data: RequestData = None,\n        files: Optional[RequestFiles] = None,\n        json: Optional[Any] = None,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"PUT to specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        content\n        data\n            Dictionary to send in the body of request.\n        files\n        json\n        params\n        headers\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP PUT request or httpx.Response.\n        \"\"\"\n        response = await self.put(\n            route,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n        )\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with text: {response.text}\"\n        )\n\n    async def delete_changes(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Clear changes\n\n        Clear the full history stored in the changes log\n        Tags: Tracking changes\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/changes\",\n        )\n\n    async def get_changes(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List changes\n\n        Whenever Orthanc receives a new DICOM instance, this event is recorded in the so-called _Changes Log_. This enables remote scripts to react to the arrival of new DICOM resources. A typical application is auto-routing, where an external script waits for a new DICOM instance to arrive into Orthanc, then forward this instance to another modality. Please note that, when resources are deleted, their corresponding change entries are also removed from the Changes Log, which helps ensuring that this log does not grow indefinitely.\n        Tags: Tracking changes\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"last\" (float): Request only the last change id (this argument must be used alone)\n                \"limit\" (float): Limit the number of results\n                \"since\" (float): Show only the resources since the provided index excluded\n                \"to\" (float): Show only the resources till the provided index included (only available if your DB backend supports ExtendedChanges)\n                \"type\" (str): Show only the changes of the provided type (only available if your DB backend supports ExtendedChanges).  Multiple values can be provided and must be separated by a ';'.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of changes\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/changes\",\n            params=params,\n        )\n\n    async def delete_exports(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Clear exports\n\n        Clear the full history stored in the exports log\n        Tags: Tracking changes\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/exports\",\n        )\n\n    async def get_exports(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List exports\n\n        For medical traceability, Orthanc can be configured to store a log of all the resources that have been exported to remote modalities. In auto-routing scenarios, it is important to prevent this log to grow indefinitely as incoming instances are routed. You can either disable this logging by setting the option `LogExportedResources` to `false` in the configuration file, or periodically clear this log by `DELETE`-ing this URI. This route might be removed in future versions of Orthanc.\n        Tags: Tracking changes\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"limit\" (float): Limit the number of results\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of exports\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/exports\",\n            params=params,\n        )\n\n    async def get_instances(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List the available instances\n\n        List the Orthanc identifiers of all the available DICOM instances\n        Tags: Instances\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported instances (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances\",\n            params=params,\n        )\n\n    async def post_instances(\n        self,\n        content: RequestContent = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Upload DICOM instances\n\n        Upload DICOM instances\n        Tags: Instances\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the uploaded instance, or list of information for each uploaded instance in the case of ZIP archive\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/instances\",\n            content=content,\n        )\n\n    async def delete_instances_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete some instance\n\n        Delete the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/instances/{id_}\",\n        )\n\n    async def get_instances_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get information about some instance\n\n        Get detailed information about the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM instance\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}\",\n            params=params,\n        )\n\n    async def post_instances_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Anonymize instance\n\n        Download an anonymized version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-a-single-instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        json\n            Dictionary with the following keys:\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The anonymized DICOM instance\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/instances/{id_}/anonymize\",\n            json=json,\n        )\n\n    async def get_instances_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List attachments\n\n        Get the list of attachments that are associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments\",\n            params=params,\n        )\n\n    async def delete_instances_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete attachment\n\n        Delete an attachment associated with the given DICOM instance. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given instance\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def put_instances_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set attachment\n\n        Attach a file to the given DICOM instance. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    async def post_instances_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compress\",\n        )\n\n    async def get_instances_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given instance. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given instance, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment on disk\n\n        Get the size of one attachment associated with the given instance, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment\n\n        Get the (binary) content of one attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get info about the attachment\n\n        Get all the information about the attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    async def get_instances_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment\n\n        Get the size of one attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    async def post_instances_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/uncompress\",\n        )\n\n    async def post_instances_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    async def get_instances_id_content_path(\n        self,\n        id_: str,\n        path: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get raw tag\n\n        Get the raw content of one DICOM tag in the hierarchy of DICOM dataset\n        Tags: Instances\n\n        Parameters\n        ----------\n        path\n            Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, `/0008-1140/1/0008-1150`\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The raw value of the tag of intereset (binary data, whose memory layout depends on the underlying transfer syntax), or JSON array containing the list of available tags if accessing a dataset\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/content/{path}\",\n        )\n\n    async def post_instances_id_export(\n        self,\n        id_: str,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Write DICOM onto filesystem\n\n        Write the DICOM file onto the filesystem where Orthanc is running.  This is insecure for Orthanc servers that are remotely accessible since one could overwrite any system file.  Since Orthanc 1.12.0, this route is disabled by default, but can be enabled using the `RestApiWriteToFileSystemEnabled` configuration option.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        data\n            Target path on the filesystem\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/instances/{id_}/export\",\n            data=data,\n        )\n\n    async def get_instances_id_file(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Download DICOM\n\n        Download one DICOM instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"transcode\" (str): If present, the DICOM file will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): This HTTP header can be set to retrieve the DICOM instance in DICOMweb format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The DICOM instance\n            The DICOM instance, in DICOMweb JSON format\n            The DICOM instance, in DICOMweb XML format\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/file\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_frames(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List available frames\n\n        List the frames that are available in the DICOM instance of interest\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of the indices of the available frames\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames\",\n        )\n\n    async def get_instances_id_frames_frame(\n        self,\n        frame: str,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations\n\n        List the available operations under URI `/instances/{id}/frames/{frame}/`\n        Tags: Other\n\n        Parameters\n        ----------\n        frame\n\n        id_\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}\",\n        )\n\n    async def get_instances_id_frames_frame_image_int16(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode a frame (int16)\n\n        Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/image-int16\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_frames_frame_image_uint16(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode a frame (uint16)\n\n        Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint16\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_frames_frame_image_uint8(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode a frame (uint8)\n\n        Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint8\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_frames_frame_matlab(\n        self,\n        frame: float,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode frame for Matlab\n\n        Decode one frame of interest from the given DICOM instance, and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Octave/Matlab matrix\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/matlab\",\n        )\n\n    async def get_instances_id_frames_frame_numpy(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode frame for numpy\n\n        Decode one frame of interest from the given DICOM instance, for use with numpy in Python. The numpy array has 3 dimensions: (height, width, color channel).\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM resource of interest\n        params\n            Dictionary of optional parameters:\n                \"compress\" (bool): Compress the file as `.npz`\n                \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/numpy\",\n            params=params,\n        )\n\n    async def get_instances_id_frames_frame_preview(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode a frame (preview)\n\n        Decode one frame of interest from the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/preview\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_frames_frame_raw(\n        self,\n        frame: float,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Access raw frame\n\n        Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The raw frame\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/raw\",\n        )\n\n    async def get_instances_id_frames_frame_raw_gz(\n        self,\n        frame: float,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Access raw frame (compressed)\n\n        Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. The image is compressed using gzip\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The raw frame, compressed using gzip\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/raw.gz\",\n        )\n\n    async def get_instances_id_frames_frame_rendered(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Render a frame\n\n        Render one frame of interest from the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"height\" (float): Height of the resized image\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n                \"smooth\" (bool): Whether to smooth image on resize\n                \"width\" (float): Width of the resized image\n                \"window-center\" (float): Windowing center\n                \"window-width\" (float): Windowing width\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/rendered\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_header(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get DICOM meta-header\n\n        Get the DICOM tags in the meta-header of the DICOM instance. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags and their associated value\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/header\",\n            params=params,\n        )\n\n    async def get_instances_id_image_int16(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode an image (int16)\n\n        Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/image-int16\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_image_uint16(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode an image (uint16)\n\n        Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/image-uint16\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_image_uint8(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode an image (uint8)\n\n        Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/image-uint8\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List labels\n\n        Get the labels that are associated with the given instance (new in Orthanc 1.12.0)\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/labels\",\n        )\n\n    async def delete_instances_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Remove label\n\n        Remove a label associated with a instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/instances/{id_}/labels/{label}\",\n        )\n\n    async def get_instances_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Test label\n\n        Test whether the instance is associated with the given label\n        Tags: Instances\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/labels/{label}\",\n        )\n\n    async def put_instances_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Add label\n\n        Associate a label with a instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/instances/{id_}/labels/{label}\",\n        )\n\n    async def get_instances_id_matlab(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode frame for Matlab\n\n        Decode the first frame of the given DICOM instance., and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Octave/Matlab matrix\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/matlab\",\n        )\n\n    async def get_instances_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List metadata\n\n        Get the list of metadata that are associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/metadata\",\n            params=params,\n        )\n\n    async def delete_instances_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete metadata\n\n        Delete some metadata associated with the given DICOM instance. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def get_instances_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get metadata\n\n        Get the value of a metadata that is associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def put_instances_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set metadata\n\n        Set the value of some metadata in the given DICOM instance. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    async def post_instances_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Modify instance\n\n        Download a modified version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-a-single-instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        json\n            Dictionary with the following keys:\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The modified DICOM instance\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/instances/{id_}/modify\",\n            json=json,\n        )\n\n    async def get_instances_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get instance module\n\n        Get the instance module of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM instance\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/module\",\n            params=params,\n        )\n\n    async def get_instances_id_numpy(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode instance for numpy\n\n        Decode the given DICOM instance, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM resource of interest\n        params\n            Dictionary of optional parameters:\n                \"compress\" (bool): Compress the file as `.npz`\n                \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/numpy\",\n            params=params,\n        )\n\n    async def get_instances_id_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get parent patient\n\n        Get detailed information about the parent patient of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM patient\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/patient\",\n            params=params,\n        )\n\n    async def get_instances_id_pdf(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get embedded PDF\n\n        Get the PDF file that is embedded in one DICOM instance. If the DICOM instance doesn't contain the `EncapsulatedDocument` tag or if the `MIMETypeOfEncapsulatedDocument` tag doesn't correspond to the PDF type, a `404` HTTP error is raised.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            PDF file\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/pdf\",\n        )\n\n    async def get_instances_id_preview(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode an image (preview)\n\n        Decode the first frame of the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/preview\",\n            params=params,\n            headers=headers,\n        )\n\n    async def post_instances_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Reconstruct tags &amp; optionally files of instance\n\n        Reconstruct the main DICOM tags in DB of the instance whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/instances/{id_}/reconstruct\",\n            json=json,\n        )\n\n    async def get_instances_id_rendered(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Render an image\n\n        Render the first frame of the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"height\" (float): Height of the resized image\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n                \"smooth\" (bool): Whether to smooth image on resize\n                \"width\" (float): Width of the resized image\n                \"window-center\" (float): Windowing center\n                \"window-width\" (float): Windowing width\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/rendered\",\n            params=params,\n            headers=headers,\n        )\n\n    async def get_instances_id_series(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get parent series\n\n        Get detailed information about the parent series of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM series\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/series\",\n            params=params,\n        )\n\n    async def get_instances_id_simplified_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get human-readable tags\n\n        Get the DICOM tags in human-readable format (same as the `/instances/{id}/tags?simplify` route)\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags and their associated value\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/simplified-tags\",\n            params=params,\n        )\n\n    async def get_instances_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get instance statistics\n\n        Get statistics about the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/statistics\",\n        )\n\n    async def get_instances_id_study(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get parent study\n\n        Get detailed information about the parent study of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM study\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/study\",\n            params=params,\n        )\n\n    async def get_instances_id_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get DICOM tags\n\n        Get the DICOM tags in the specified format. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n                \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags and their associated value\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/instances/{id_}/tags\",\n            params=params,\n        )\n\n    async def get_jobs(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List jobs\n\n        List all the available jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual jobs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the jobs identifiers, or detailed information about the reported jobs (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/jobs\",\n            params=params,\n        )\n\n    async def delete_jobs_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete a job from history\n\n        Delete the job from the jobs history.  Only a completed job can be deleted. If the job has not run or not completed yet, you must cancel it first. If the job has outputs, all outputs will be deleted as well.\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/jobs/{id_}\",\n        )\n\n    async def get_jobs_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get job\n\n        Retrieve detailed information about the job whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object detailing the job\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/jobs/{id_}\",\n        )\n\n    async def post_jobs_id_cancel(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Cancel job\n\n        Cancel the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/jobs/{id_}/cancel\",\n        )\n\n    async def post_jobs_id_pause(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Pause job\n\n        Pause the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/jobs/{id_}/pause\",\n        )\n\n    async def post_jobs_id_resubmit(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Resubmit job\n\n        Resubmit the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/jobs/{id_}/resubmit\",\n        )\n\n    async def post_jobs_id_resume(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Resume job\n\n        Resume the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/jobs/{id_}/resume\",\n        )\n\n    async def delete_jobs_id_key(\n        self,\n        id_: str,\n        key: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete a job output\n\n        Delete the output produced by a job. As of Orthanc 1.12.1, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n        Tags: Jobs\n\n        Parameters\n        ----------\n        key\n            Name of the output of interest\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/jobs/{id_}/{key}\",\n        )\n\n    async def get_jobs_id_key(\n        self,\n        id_: str,\n        key: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get job output\n\n        Retrieve some output produced by a job. As of Orthanc 1.8.2, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n        Tags: Jobs\n\n        Parameters\n        ----------\n        key\n            Name of the output of interest\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Content of the output of the job\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/jobs/{id_}/{key}\",\n        )\n\n    async def get_modalities(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List DICOM modalities\n\n        List all the DICOM modalities that are known to Orthanc. This corresponds either to the content of the `DicomModalities` configuration option, or to the information stored in the database if `DicomModalitiesInDatabase` is `true`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual DICOM modalities\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the identifiers of the modalities, or detailed information about the modalities (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/modalities\",\n            params=params,\n        )\n\n    async def delete_modalities_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete DICOM modality\n\n        Delete one DICOM modality. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the DICOM modality of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/modalities/{id_}\",\n        )\n\n    async def get_modalities_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on modality\n\n        List the operations that are available for a DICOM modality.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the DICOM modality of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/modalities/{id_}\",\n        )\n\n    async def put_modalities_id(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Update DICOM modality\n\n        Define a new DICOM modality, or update an existing one. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the new/updated DICOM modality\n        json\n            Dictionary with the following keys:\n              \"AET\": AET of the remote DICOM modality\n              \"AllowEcho\": Whether to accept C-ECHO SCU commands issued by the remote modality\n              \"AllowFind\": Whether to accept C-FIND SCU commands issued by the remote modality\n              \"AllowFindWorklist\": Whether to accept C-FIND SCU commands for worklists issued by the remote modality\n              \"AllowGet\": Whether to accept C-GET SCU commands issued by the remote modality\n              \"AllowMove\": Whether to accept C-MOVE SCU commands issued by the remote modality\n              \"AllowStorageCommitment\": Whether to accept storage commitment requests issued by the remote modality\n              \"AllowStore\": Whether to accept C-STORE SCU commands issued by the remote modality\n              \"AllowTranscoding\": Whether to allow transcoding for operations initiated by this modality. This option applies to Orthanc C-GET SCP and to Orthanc C-STORE SCU. It only has an effect if the global option `EnableTranscoding` is set to `true`.\n              \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n              \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n              \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n              \"Port\": TCP port of the remote DICOM modality\n              \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n              \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._put(\n            route=f\"{self.url}/modalities/{id_}\",\n            json=json,\n        )\n\n    async def get_modalities_id_configuration(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get modality configuration\n\n        Get detailed information about the configuration of some DICOM modality\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Configuration of the modality\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/modalities/{id_}/configuration\",\n        )\n\n    async def post_modalities_id_echo(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Trigger C-ECHO SCU\n\n        Trigger C-ECHO SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-echo\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n              \"Timeout\": Timeout for the C-ECHO command, in seconds\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/echo\",\n            json=json,\n        )\n\n    async def post_modalities_id_find(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Hierarchical C-FIND SCU\n\n        Trigger a sequence of C-FIND SCU commands against the DICOM modality whose identifier is provided in URL, in order to discover a hierarchy of matching patients/studies/series. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching patients, embedding the matching studies, then the matching series.\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/find\",\n            json=json,\n        )\n\n    async def post_modalities_id_find_instance(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) C-FIND SCU for instances\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find an instance. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching instances\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/find-instance\",\n            json=json,\n        )\n\n    async def post_modalities_id_find_patient(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) C-FIND SCU for patients\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a patient. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching patients\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/find-patient\",\n            json=json,\n        )\n\n    async def post_modalities_id_find_series(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) C-FIND SCU for series\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a series. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching series\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/find-series\",\n            json=json,\n        )\n\n    async def post_modalities_id_find_study(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) C-FIND SCU for studies\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a study. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching studies\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/find-study\",\n            json=json,\n        )\n\n    async def post_modalities_id_find_worklist(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) C-FIND SCU for worklist\n\n        Trigger C-FIND SCU command against the remote worklists of the DICOM modality whose identifier is provided in URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching worklists\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/find-worklist\",\n            json=json,\n        )\n\n    async def post_modalities_id_get(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Trigger C-GET SCU\n\n        Start a C-GET SCU command as a job, in order to retrieve DICOM resources from a remote DICOM modality whose identifier is provided in the URL:\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of queries identifying all the DICOM resources to be sent.  Usage of wildcards is prohibited and the query shall only contain DICOM ID tags.  Additionally, you may provide SOPClassesInStudy to limit the scope of the DICOM negotiation to certain SOPClassUID or to present uncommon SOPClassUID during the DICOM negotation.  By default, Orhanc will propose the most 120 common SOPClassUIDs.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Timeout\": Timeout for the C-GET command, in seconds\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/get\",\n            json=json,\n        )\n\n    async def post_modalities_id_move(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Trigger C-MOVE SCU\n\n        Start a C-MOVE SCU command as a job, in order to drive the execution of a sequence of C-STORE commands by some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-move\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of queries identifying all the DICOM resources to be sent\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"TargetAet\": Target AET that will be used by the remote DICOM modality as a target for its C-STORE SCU commands, defaults to `DicomAet` configuration option in order to do a simple query/retrieve\n              \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/move\",\n            json=json,\n        )\n\n    async def post_modalities_id_query(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Trigger C-FIND SCU\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"Normalize\": Whether to normalize the query, i.e. whether to wipe out from the query, the DICOM tags that are not applicable for the query-retrieve level of interest\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command and subsequent C-MOVE retrievals, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/query\",\n            json=json,\n        )\n\n    async def post_modalities_id_storage_commitment(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Trigger storage commitment request\n\n        Trigger a storage commitment request to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"DicomInstances\": List of DICOM resources that are not necessarily stored within Orthanc, but that must be checked by storage commitment. This is a list of JSON objects that must contain the `SOPClassUID` and `SOPInstanceUID` fields.\n              \"Resources\": List of the Orthanc identifiers of the DICOM resources to be checked by storage commitment\n              \"Timeout\": Timeout for the storage commitment command (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/storage-commitment\",\n            json=json,\n        )\n\n    async def post_modalities_id_store(\n        self,\n        id_: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Trigger C-STORE SCU\n\n        Start a C-STORE SCU command as a job, in order to send DICOM resources stored locally to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#rest-store-scu\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"CalledAet\": Called AET that is used for this commands, defaults to `AET` configuration option. Allows you to overwrite the destination AET for a specific operation.\n              \"Host\": Host that is used for this commands, defaults to `Host` configuration option. Allows you to overwrite the destination host for a specific operation.\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"MoveOriginatorAet\": Move originator AET that is used for this commands, in order to fake a C-MOVE SCU\n              \"MoveOriginatorID\": Move originator ID that is used for this commands, in order to fake a C-MOVE SCU\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Port\": Port that is used for this command, defaults to `Port` configuration option. Allows you to overwrite the destination port for a specific operation.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n              \"StorageCommitment\": Whether to chain C-STORE with DICOM storage commitment to validate the success of the transmission: https://orthanc.uclouvain.be/book/users/storage-commitment.html#chaining-c-store-with-storage-commitment\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Timeout\": Timeout for the C-STORE command, in seconds\n\n        data\n            The Orthanc identifier of one resource to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/store\",\n            data=data,\n            json=json,\n        )\n\n    async def post_modalities_id_store_straight(\n        self,\n        id_: str,\n        content: RequestContent = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Straight C-STORE SCU\n\n        Synchronously send the DICOM instance in the POST body to the remote DICOM modality whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `storescu` from DCMTK or dcm4che.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        content\n                - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/modalities/{id_}/store-straight\",\n            content=content,\n        )\n\n    async def get_patients(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List the available patients\n\n        List the Orthanc identifiers of all the available DICOM patients\n        Tags: Patients\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported patients (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients\",\n            params=params,\n        )\n\n    async def delete_patients_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete some patient\n\n        Delete the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/patients/{id_}\",\n        )\n\n    async def get_patients_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get information about some patient\n\n        Get detailed information about the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM patient\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}\",\n            params=params,\n        )\n\n    async def post_patients_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Anonymize patient\n\n        Start a job that will anonymize all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/anonymize\",\n            json=json,\n        )\n\n    async def get_patients_id_archive(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Synchronously create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/archive\",\n            params=params,\n        )\n\n    async def post_patients_id_archive(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/archive\",\n            json=json,\n        )\n\n    async def get_patients_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List attachments\n\n        Get the list of attachments that are associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments\",\n            params=params,\n        )\n\n    async def delete_patients_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete attachment\n\n        Delete an attachment associated with the given DICOM patient. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given patient\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def put_patients_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set attachment\n\n        Attach a file to the given DICOM patient. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    async def post_patients_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compress\",\n        )\n\n    async def get_patients_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given patient. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given patient, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment on disk\n\n        Get the size of one attachment associated with the given patient, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment\n\n        Get the (binary) content of one attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get info about the attachment\n\n        Get all the information about the attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    async def get_patients_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment\n\n        Get the size of one attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    async def post_patients_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/uncompress\",\n        )\n\n    async def post_patients_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    async def get_patients_id_instances(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get child instances\n\n        Get detailed information about the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child instances\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM instances\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/instances\",\n            params=params,\n        )\n\n    async def get_patients_id_instances_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get tags of instances\n\n        Get the tags of all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/instances-tags\",\n            params=params,\n        )\n\n    async def get_patients_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List labels\n\n        Get the labels that are associated with the given patient (new in Orthanc 1.12.0)\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/labels\",\n        )\n\n    async def delete_patients_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Remove label\n\n        Remove a label associated with a patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/patients/{id_}/labels/{label}\",\n        )\n\n    async def get_patients_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Test label\n\n        Test whether the patient is associated with the given label\n        Tags: Patients\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/labels/{label}\",\n        )\n\n    async def put_patients_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Add label\n\n        Associate a label with a patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/patients/{id_}/labels/{label}\",\n        )\n\n    async def get_patients_id_media(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Synchronously create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/media\",\n            params=params,\n        )\n\n    async def post_patients_id_media(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/media\",\n            json=json,\n        )\n\n    async def get_patients_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List metadata\n\n        Get the list of metadata that are associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/metadata\",\n            params=params,\n        )\n\n    async def delete_patients_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete metadata\n\n        Delete some metadata associated with the given DICOM patient. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def get_patients_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get metadata\n\n        Get the value of a metadata that is associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def put_patients_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set metadata\n\n        Set the value of some metadata in the given DICOM patient. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    async def post_patients_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Modify patient\n\n        Start a job that will modify all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/modify\",\n            json=json,\n        )\n\n    async def get_patients_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get patient module\n\n        Get the patient module of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM patient\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/module\",\n            params=params,\n        )\n\n    async def get_patients_id_protected(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Is the patient protected against recycling?\n\n        Is the patient protected against recycling?\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `1` if protected, `0` if not protected\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/protected\",\n        )\n\n    async def put_patients_id_protected(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Protect/Unprotect a patient against recycling\n\n        Protects a patient by sending `1` or `true` in the payload request. Unprotects a patient by sending `0` or `false` in the payload requests. More info: https://orthanc.uclouvain.be/book/faq/features.html#recycling-protection\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/patients/{id_}/protected\",\n        )\n\n    async def post_patients_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Reconstruct tags &amp; optionally files of patient\n\n        Reconstruct the main DICOM tags in DB of the patient whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/patients/{id_}/reconstruct\",\n            json=json,\n        )\n\n    async def get_patients_id_series(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get child series\n\n        Get detailed information about the child series of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child series\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM series\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/series\",\n            params=params,\n        )\n\n    async def get_patients_id_shared_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get shared tags\n\n        Extract the DICOM tags whose value is constant across all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the values of the DICOM tags\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/shared-tags\",\n            params=params,\n        )\n\n    async def get_patients_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get patient statistics\n\n        Get statistics about the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/statistics\",\n        )\n\n    async def get_patients_id_studies(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get child studies\n\n        Get detailed information about the child studies of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child studies\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM studies\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/patients/{id_}/studies\",\n            params=params,\n        )\n\n    async def get_peers(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List Orthanc peers\n\n        List all the Orthanc peers that are known to Orthanc. This corresponds either to the content of the `OrthancPeers` configuration option, or to the information stored in the database if `OrthancPeersInDatabase` is `true`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual Orthanc peers\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the identifiers of the peers, or detailed information about the peers (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/peers\",\n            params=params,\n        )\n\n    async def delete_peers_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete Orthanc peer\n\n        Delete one Orthanc peer. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the Orthanc peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/peers/{id_}\",\n        )\n\n    async def get_peers_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on peer\n\n        List the operations that are available for an Orthanc peer.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/peers/{id_}\",\n        )\n\n    async def put_peers_id(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Update Orthanc peer\n\n        Define a new Orthanc peer, or update an existing one. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the new/updated Orthanc peer\n        json\n            Dictionary with the following keys:\n              \"CertificateFile\": SSL certificate for the HTTPS connections\n              \"CertificateKeyFile\": Key file for the SSL certificate for the HTTPS connections\n              \"CertificateKeyPassword\": Key password for the SSL certificate for the HTTPS connections\n              \"HttpHeaders\": HTTP headers to be used for the connections to the remote peer\n              \"Password\": Password for the credentials\n              \"URL\": URL of the root of the REST API of the remote Orthanc peer, for instance `http://localhost:8042/`\n              \"Username\": Username for the credentials\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._put(\n            route=f\"{self.url}/peers/{id_}\",\n            json=json,\n        )\n\n    async def get_peers_id_configuration(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get peer configuration\n\n        Get detailed information about the configuration of some Orthanc peer\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Configuration of the peer\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/peers/{id_}/configuration\",\n        )\n\n    async def post_peers_id_store(\n        self,\n        id_: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Send to Orthanc peer\n\n        Send DICOM resources stored locally to some remote Orthanc peer whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#sending-one-resource\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Compress\": Whether to compress the DICOM instances using gzip before the actual sending\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode to the provided DICOM transfer syntax before the actual sending\n\n        data\n            The Orthanc identifier of one resource to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/peers/{id_}/store\",\n            data=data,\n            json=json,\n        )\n\n    async def post_peers_id_store_straight(\n        self,\n        id_: str,\n        content: RequestContent = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Straight store to peer\n\n        Synchronously send the DICOM instance in the POST body to the Orthanc peer whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `curl`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        content\n                - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/peers/{id_}/store-straight\",\n            content=content,\n        )\n\n    async def get_peers_id_system(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get peer system information\n\n        Get system information about some Orthanc peer. This corresponds to doing a `GET` request against the `/system` URI of the remote peer. This route can be used to test connectivity.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            System information about the peer\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/peers/{id_}/system\",\n        )\n\n    async def get_plugins(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List plugins\n\n        List all the installed plugins\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the identifiers of the installed plugins\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/plugins\",\n        )\n\n    async def get_plugins_explorer_js(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) JavaScript extensions to Orthanc Explorer\n\n        Get the JavaScript extensions that are installed by all the plugins using the `OrthancPluginExtendOrthancExplorer()` function of the plugin SDK. This route is for internal use of Orthanc Explorer.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The JavaScript extensions\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/plugins/explorer.js\",\n        )\n\n    async def get_plugins_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get plugin\n\n        Get system information about the plugin whose identifier is provided in the URL\n        Tags: System\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing information about the plugin\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/plugins/{id_}\",\n        )\n\n    async def get_queries(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List query/retrieve operations\n\n        List the identifiers of all the query/retrieve operations on DICOM modalities, as initiated by calls to `/modalities/{id}/query`. The length of this list is bounded by the `QueryRetrieveSize` configuration option of Orthanc. https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n        Tags: Networking\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the identifiers\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries\",\n        )\n\n    async def delete_queries_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete a query\n\n        Delete the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/queries/{id_}\",\n        )\n\n    async def get_queries_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on a query\n\n        List the available operations for the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the list of operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries/{id_}\",\n        )\n\n    async def get_queries_id_answers(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List answers to a query\n\n        List the indices of all the available answers resulting from a query/retrieve operation on some DICOM modality, whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual answers\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the indices of the answers, or detailed information about the reported answers (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries/{id_}/answers\",\n            params=params,\n        )\n\n    async def get_queries_id_answers_index(\n        self,\n        id_: str,\n        index: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on an answer\n\n        List the available operations on an answer associated with the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the list of operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries/{id_}/answers/{index}\",\n        )\n\n    async def get_queries_id_answers_index_content(\n        self,\n        id_: str,\n        index: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get one answer\n\n        Get the content (DICOM tags) of one answer associated with the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags of the answer\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/content\",\n            params=params,\n        )\n\n    async def post_queries_id_answers_index_query_instances(\n        self,\n        id_: str,\n        index: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Query the child instances of an answer\n\n        Issue a second DICOM C-FIND operation, in order to query the child instances associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/query-instances\",\n            json=json,\n        )\n\n    async def post_queries_id_answers_index_query_series(\n        self,\n        id_: str,\n        index: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Query the child series of an answer\n\n        Issue a second DICOM C-FIND operation, in order to query the child series associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/query-series\",\n            json=json,\n        )\n\n    async def post_queries_id_answers_index_query_studies(\n        self,\n        id_: str,\n        index: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Query the child studies of an answer\n\n        Issue a second DICOM C-FIND operation, in order to query the child studies associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/query-studies\",\n            json=json,\n        )\n\n    async def post_queries_id_answers_index_retrieve(\n        self,\n        id_: str,\n        index: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Retrieve one answer with a C-MOVE or a C-GET SCU\n\n        Start a C-MOVE or a C-GET SCU command as a job, in order to retrieve one answer associated with the query/retrieve operation whose identifiers are provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n              \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n              \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n        data\n            AET of the target modality\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/retrieve\",\n            data=data,\n            json=json,\n        )\n\n    async def get_queries_id_level(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get level of original query\n\n        Get the query level (value of the `QueryRetrieveLevel` tag) of the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The level\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries/{id_}/level\",\n        )\n\n    async def get_queries_id_modality(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get modality of original query\n\n        Get the identifier of the DICOM modality that was targeted by the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The identifier of the DICOM modality\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries/{id_}/modality\",\n        )\n\n    async def get_queries_id_query(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get original query arguments\n\n        Get the original DICOM filter associated with the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Content of the original query\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/queries/{id_}/query\",\n            params=params,\n        )\n\n    async def post_queries_id_retrieve(\n        self,\n        id_: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Retrieve all answers with C-MOVE SCU\n\n        Start a C-MOVE SCU command as a job, in order to retrieve all the answers associated with the query/retrieve operation whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n              \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n              \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n        data\n            AET of the target modality\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/queries/{id_}/retrieve\",\n            data=data,\n            json=json,\n        )\n\n    async def get_series(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List the available series\n\n        List the Orthanc identifiers of all the available DICOM series\n        Tags: Series\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported series (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series\",\n            params=params,\n        )\n\n    async def delete_series_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete some series\n\n        Delete the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/series/{id_}\",\n        )\n\n    async def get_series_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get information about some series\n\n        Get detailed information about the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM series\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}\",\n            params=params,\n        )\n\n    async def post_series_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Anonymize series\n\n        Start a job that will anonymize all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/anonymize\",\n            json=json,\n        )\n\n    async def get_series_id_archive(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Synchronously create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/archive\",\n            params=params,\n        )\n\n    async def post_series_id_archive(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/archive\",\n            json=json,\n        )\n\n    async def get_series_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List attachments\n\n        Get the list of attachments that are associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments\",\n            params=params,\n        )\n\n    async def delete_series_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete attachment\n\n        Delete an attachment associated with the given DICOM series. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/series/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given series\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def put_series_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set attachment\n\n        Attach a file to the given DICOM series. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/series/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    async def post_series_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compress\",\n        )\n\n    async def get_series_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given series. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given series, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment on disk\n\n        Get the size of one attachment associated with the given series, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment\n\n        Get the (binary) content of one attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get info about the attachment\n\n        Get all the information about the attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    async def get_series_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment\n\n        Get the size of one attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    async def post_series_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/uncompress\",\n        )\n\n    async def post_series_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    async def get_series_id_instances(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get child instances\n\n        Get detailed information about the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child instances\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM instances\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/instances\",\n            params=params,\n        )\n\n    async def get_series_id_instances_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get tags of instances\n\n        Get the tags of all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/instances-tags\",\n            params=params,\n        )\n\n    async def get_series_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List labels\n\n        Get the labels that are associated with the given series (new in Orthanc 1.12.0)\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/labels\",\n        )\n\n    async def delete_series_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Remove label\n\n        Remove a label associated with a series\n        Tags: Series\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/series/{id_}/labels/{label}\",\n        )\n\n    async def get_series_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Test label\n\n        Test whether the series is associated with the given label\n        Tags: Series\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/labels/{label}\",\n        )\n\n    async def put_series_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Add label\n\n        Associate a label with a series\n        Tags: Series\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/series/{id_}/labels/{label}\",\n        )\n\n    async def get_series_id_media(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Synchronously create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/media\",\n            params=params,\n        )\n\n    async def post_series_id_media(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/media\",\n            json=json,\n        )\n\n    async def get_series_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List metadata\n\n        Get the list of metadata that are associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/metadata\",\n            params=params,\n        )\n\n    async def delete_series_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete metadata\n\n        Delete some metadata associated with the given DICOM series. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/series/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def get_series_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get metadata\n\n        Get the value of a metadata that is associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def put_series_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set metadata\n\n        Set the value of some metadata in the given DICOM series. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/series/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    async def post_series_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Modify series\n\n        Start a job that will modify all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/modify\",\n            json=json,\n        )\n\n    async def get_series_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get series module\n\n        Get the series module of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM series\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/module\",\n            params=params,\n        )\n\n    async def get_series_id_numpy(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Decode series for numpy\n\n        Decode the given DICOM series, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM resource of interest\n        params\n            Dictionary of optional parameters:\n                \"compress\" (bool): Compress the file as `.npz`\n                \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/numpy\",\n            params=params,\n        )\n\n    async def get_series_id_ordered_slices(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Order the slices\n\n        Sort the instances and frames (slices) of the DICOM series whose Orthanc identifier is provided in the URL. This URI is essentially used by the Orthanc Web viewer and by the Osimis Web viewer.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/ordered-slices\",\n        )\n\n    async def get_series_id_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get parent patient\n\n        Get detailed information about the parent patient of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM patient\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/patient\",\n            params=params,\n        )\n\n    async def post_series_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Reconstruct tags &amp; optionally files of series\n\n        Reconstruct the main DICOM tags in DB of the series whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/series/{id_}/reconstruct\",\n            json=json,\n        )\n\n    async def get_series_id_shared_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get shared tags\n\n        Extract the DICOM tags whose value is constant across all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the values of the DICOM tags\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/shared-tags\",\n            params=params,\n        )\n\n    async def get_series_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get series statistics\n\n        Get statistics about the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/statistics\",\n        )\n\n    async def get_series_id_study(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get parent study\n\n        Get detailed information about the parent study of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM study\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/series/{id_}/study\",\n            params=params,\n        )\n\n    async def get_statistics(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get database statistics\n\n        Get statistics related to the database of Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/statistics\",\n        )\n\n    async def get_storage_commitment_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get storage commitment report\n\n        Get the storage commitment report whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the storage commitment report\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/storage-commitment/{id_}\",\n        )\n\n    async def post_storage_commitment_id_remove(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Remove after storage commitment\n\n        Remove out of Orthanc, the DICOM instances that have been reported to have been properly received the storage commitment report whose identifier is provided in the URL. This is only possible if the `Status` of the storage commitment report is `Success`. https://orthanc.uclouvain.be/book/users/storage-commitment.html#removing-the-instances\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the storage commitment report\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/storage-commitment/{id_}/remove\",\n        )\n\n    async def get_studies(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List the available studies\n\n        List the Orthanc identifiers of all the available DICOM studies\n        Tags: Studies\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported studies (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies\",\n            params=params,\n        )\n\n    async def delete_studies_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete some study\n\n        Delete the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/studies/{id_}\",\n        )\n\n    async def get_studies_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get information about some study\n\n        Get detailed information about the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM study\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}\",\n            params=params,\n        )\n\n    async def post_studies_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Anonymize study\n\n        Start a job that will anonymize all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/anonymize\",\n            json=json,\n        )\n\n    async def get_studies_id_archive(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Synchronously create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/archive\",\n            params=params,\n        )\n\n    async def post_studies_id_archive(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/archive\",\n            json=json,\n        )\n\n    async def get_studies_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List attachments\n\n        Get the list of attachments that are associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments\",\n            params=params,\n        )\n\n    async def delete_studies_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete attachment\n\n        Delete an attachment associated with the given DICOM study. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given study\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    async def put_studies_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set attachment\n\n        Attach a file to the given DICOM study. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    async def post_studies_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compress\",\n        )\n\n    async def get_studies_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given study. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given study, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment on disk\n\n        Get the size of one attachment associated with the given study, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get attachment\n\n        Get the (binary) content of one attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get info about the attachment\n\n        Get all the information about the attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    async def get_studies_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get size of attachment\n\n        Get the size of one attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    async def post_studies_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/uncompress\",\n        )\n\n    async def post_studies_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    async def get_studies_id_instances(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get child instances\n\n        Get detailed information about the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child instances\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM instances\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/instances\",\n            params=params,\n        )\n\n    async def get_studies_id_instances_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get tags of instances\n\n        Get the tags of all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/instances-tags\",\n            params=params,\n        )\n\n    async def get_studies_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List labels\n\n        Get the labels that are associated with the given study (new in Orthanc 1.12.0)\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/labels\",\n        )\n\n    async def delete_studies_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Remove label\n\n        Remove a label associated with a study\n        Tags: Studies\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/studies/{id_}/labels/{label}\",\n        )\n\n    async def get_studies_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Test label\n\n        Test whether the study is associated with the given label\n        Tags: Studies\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/labels/{label}\",\n        )\n\n    async def put_studies_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Add label\n\n        Associate a label with a study\n        Tags: Studies\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/studies/{id_}/labels/{label}\",\n        )\n\n    async def get_studies_id_media(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Synchronously create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/media\",\n            params=params,\n        )\n\n    async def post_studies_id_media(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/media\",\n            json=json,\n        )\n\n    async def post_studies_id_merge(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Merge study\n\n        Start a new job so as to move some DICOM resources into the DICOM study whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#merging\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original resources in their source study. By default, the original resources are deleted from Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of DICOM resources (studies, series, and/or instances) to be merged into the study of interest (mandatory option)\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/merge\",\n            json=json,\n        )\n\n    async def get_studies_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List metadata\n\n        Get the list of metadata that are associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/metadata\",\n            params=params,\n        )\n\n    async def delete_studies_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete metadata\n\n        Delete some metadata associated with the given DICOM study. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._delete(\n            route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def get_studies_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get metadata\n\n        Get the value of a metadata that is associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    async def put_studies_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set metadata\n\n        Set the value of some metadata in the given DICOM study. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    async def post_studies_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Modify study\n\n        Start a job that will modify all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/modify\",\n            json=json,\n        )\n\n    async def get_studies_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get study module\n\n        Get the study module of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM study\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/module\",\n            params=params,\n        )\n\n    async def get_studies_id_module_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get patient module of study\n\n        Get the patient module of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM study\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/module-patient\",\n            params=params,\n        )\n\n    async def get_studies_id_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get parent patient\n\n        Get detailed information about the parent patient of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM patient\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/patient\",\n            params=params,\n        )\n\n    async def post_studies_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Reconstruct tags &amp; optionally files of study\n\n        Reconstruct the main DICOM tags in DB of the study whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/reconstruct\",\n            json=json,\n        )\n\n    async def get_studies_id_series(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get child series\n\n        Get detailed information about the child series of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child series\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM series\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/series\",\n            params=params,\n        )\n\n    async def get_studies_id_shared_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get shared tags\n\n        Extract the DICOM tags whose value is constant across all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the values of the DICOM tags\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/shared-tags\",\n            params=params,\n        )\n\n    async def post_studies_id_split(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Split study\n\n        Start a new job so as to split the DICOM study whose Orthanc identifier is provided in the URL, by taking some of its children series or instances out of it and putting them into a brand new study (this new study is created by setting the `StudyInstanceUID` tag to a random identifier): https://orthanc.uclouvain.be/book/users/anonymization.html#splitting\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Instances\": The list of instances to be separated from the parent study. These instances must all be children of the same source study, that is specified in the URI.\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original series/instances in the source study. By default, the original series/instances are deleted from Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Remove\": List of tags that must be removed in the new study (from the same modules as in the `Replace` option)\n              \"Replace\": Associative array to change the value of some DICOM tags in the new study. These tags must be part of the \"Patient Module Attributes\" or the \"General Study Module Attributes\", as specified by the DICOM 2011 standard in Tables C.7-1 and C.7-3.\n              \"Series\": The list of series to be separated from the parent study. These series must all be children of the same source study, that is specified in the URI.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/studies/{id_}/split\",\n            json=json,\n        )\n\n    async def get_studies_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get study statistics\n\n        Get statistics about the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/studies/{id_}/statistics\",\n        )\n\n    async def get_system(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get system information\n\n        Get system information about Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/system\",\n        )\n\n    async def get_tools(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) List operations\n\n        List the available operations under URI `/tools/`\n        Tags: Other\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools\",\n        )\n\n    async def get_tools_accepted_sop_classes(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get accepted SOPClassUID\n\n        Get the list of SOP Class UIDs that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedSopClasses` and `RejectedSopClasses`.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the SOP Class UIDs\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/accepted-sop-classes\",\n        )\n\n    async def get_tools_accepted_transfer_syntaxes(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get accepted transfer syntaxes\n\n        Get the list of UIDs of the DICOM transfer syntaxes that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedTransferSyntaxes` and `XXXTransferSyntaxAccepted`.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the transfer syntax UIDs\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n        )\n\n    async def put_tools_accepted_transfer_syntaxes(\n        self,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set accepted transfer syntaxes\n\n        Set the DICOM transfer syntaxes that accepted by Orthanc C-STORE SCP\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n\n        data\n            UID of the transfer syntax to be accepted. Wildcards `?` and `*` are accepted.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the now-accepted transfer syntax UIDs\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._put(\n            route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n            data=data,\n            json=json,\n        )\n\n    async def post_tools_bulk_anonymize(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Anonymize a set of resources\n\n        Start a job that will anonymize all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of all the resources that have been created by this anonymization\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/bulk-anonymize\",\n            json=json,\n        )\n\n    async def post_tools_bulk_content(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Describe a set of resources\n\n        Get the content all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field, in one single call.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Level\": This optional argument specifies the level of interest (can be `Patient`, `Study`, `Series` or `Instance`). Orthanc will loop over the items inside `Resources`, and explore upward or downward in the DICOM hierarchy in order to find the level of interest.\n              \"Metadata\": If set to `true` (default value), the metadata associated with the resources will also be retrieved.\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/bulk-content\",\n            json=json,\n        )\n\n    async def post_tools_bulk_delete(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Delete a set of resources\n\n        Delete all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/bulk-delete\",\n            json=json,\n        )\n\n    async def post_tools_bulk_modify(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Modify a set of resources\n\n        Start a job that will modify all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Level\": Level of the modification (`Patient`, `Study`, `Series` or `Instance`). If absent, the level defaults to `Instance`, but is set to `Patient` if `PatientID` is modified, to `Study` if `StudyInstanceUID` is modified, or to `Series` if `SeriesInstancesUID` is modified. (new in Orthanc 1.9.7)\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of all the resources that have been altered by this modification\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/bulk-modify\",\n            json=json,\n        )\n\n    async def post_tools_count_resources(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Count local resources\n\n        This URI can be used to count the resources that are matching criteria on the content of the local Orthanc server, in a way that is similar to tools/find\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n              \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n              \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n              \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n              \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            A JSON object with the `Count` of matching resources\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/count-resources\",\n            json=json,\n        )\n\n    async def get_tools_create_archive(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the ZIP archive.\n                \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/create-archive\",\n            params=params,\n        )\n\n    async def post_tools_create_archive(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create ZIP archive\n\n        Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of Orthanc identifiers of interest.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/create-archive\",\n            json=json,\n        )\n\n    async def post_tools_create_dicom(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create one DICOM instance\n\n        Create one DICOM instance, and store it into Orthanc\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Content\": This field can be used to embed an image (pixel data encoded as PNG or JPEG), a PDF, or a 3D manufactoring model (MTL/OBJ/STL) inside the created DICOM instance. The file to be encapsulated must be provided using its [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme). This field can possibly contain a JSON array, in which case a DICOM series is created containing one DICOM instance for each item in the `Content` field.\n              \"Force\": Avoid the consistency checks for the DICOM tags that enforce the DICOM model of the real-world. You can notably use this flag if you need to manually set the tags `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`. Be careful with this feature.\n              \"InterpretBinaryTags\": If some value in the `Tags` associative array is formatted according to some [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme), whether this value is decoded to a binary value or kept as such (`true` by default)\n              \"Parent\": If present, the newly created instance will be attached to the parent DICOM resource whose Orthanc identifier is contained in this field. The DICOM tags of the parent modules in the DICOM hierarchy will be automatically copied to the newly created instance.\n              \"PrivateCreator\": The private creator to be used for private tags in `Tags`\n              \"Tags\": Associative array containing the tags of the new instance to be created\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/create-dicom\",\n            json=json,\n        )\n\n    async def get_tools_create_media(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n                \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/create-media\",\n            params=params,\n        )\n\n    async def post_tools_create_media(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of Orthanc identifiers of interest.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/create-media\",\n            json=json,\n        )\n\n    async def get_tools_create_media_extended(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n                \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/create-media-extended\",\n            params=params,\n        )\n\n    async def post_tools_create_media_extended(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `true`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of Orthanc identifiers of interest.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/create-media-extended\",\n            json=json,\n        )\n\n    async def get_tools_default_encoding(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get default encoding\n\n        Get the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The name of the encoding\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/default-encoding\",\n        )\n\n    async def put_tools_default_encoding(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set default encoding\n\n        Change the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            The name of the encoding. Check out configuration option `DefaultEncoding` for the allowed values.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/default-encoding\",\n            data=data,\n        )\n\n    async def get_tools_dicom_conformance(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get DICOM conformance\n\n        Get the DICOM conformance statement of Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The DICOM conformance statement\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/dicom-conformance\",\n        )\n\n    async def post_tools_dicom_echo(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Trigger C-ECHO SCU\n\n        Trigger C-ECHO SCU command against a DICOM modality described in the POST body, without having to register the modality in some `/modalities/{id}` (new in Orthanc 1.8.1)\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"AET\": AET of the remote DICOM modality\n              \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n              \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n              \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n              \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n              \"Port\": TCP port of the remote DICOM modality\n              \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n              \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/dicom-echo\",\n            json=json,\n        )\n\n    async def post_tools_execute_script(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Execute Lua script\n\n        Execute the provided Lua script by the Orthanc server. This is very insecure for Orthanc servers that are remotely accessible.  Since Orthanc 1.5.8, this route is disabled by default and can be enabled thanks to the `ExecuteLuaEnabled` configuration.\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            The Lua script to be executed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Output of the Lua script\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/tools/execute-script\",\n            data=data,\n        )\n\n    async def post_tools_find(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Look for local resources\n\n        This URI can be used to perform a search on the content of the local Orthanc server, in a way that is similar to querying remote DICOM modalities using C-FIND SCU: https://orthanc.uclouvain.be/book/users/rest.html#performing-finds-within-orthanc\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"CaseSensitive\": Enable case-sensitive search for PN value representations (defaults to configuration option `CaseSensitivePN`)\n              \"Expand\": If set to \"true\", retrieve detailed information about the individual resources, not only their Orthanc identifiers\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n              \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"Limit\": Limit the number of reported resources\n              \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n              \"OrderBy\": Array of associative arrays containing the requested ordering (new in Orthanc 1.12.5)\n              \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n              \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n              \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"RequestedTags\": A list of DICOM tags to include in the response (applicable only if \"Expand\" is set to true).  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n              \"ResponseContent\": Defines the content of response for each returned resource. (this field, if present, overrides the \"Expand\" field).  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.(new in Orthanc 1.12.5)\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n              \"Since\": Show only the resources since the provided index (in conjunction with `Limit`)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported resources (if `Expand` argument is `true`)\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/find\",\n            json=json,\n        )\n\n    async def get_tools_generate_uid(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Generate an identifier\n\n        Generate a random DICOM identifier\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"level\" (str): Type of DICOM resource among: `patient`, `study`, `series` or `instance`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The generated identifier\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/generate-uid_\",\n            params=params,\n        )\n\n    async def post_tools_invalid_ate_tags(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Invalidate DICOM-as-JSON summaries\n\n        Remove all the attachments of the type \"DICOM-as-JSON\" that are associated will all the DICOM instances stored in Orthanc. These summaries will be automatically re-created on the next access. This is notably useful after changes to the `Dictionary` configuration option. https://orthanc.uclouvain.be/book/faq/orthanc-storage.html#storage-area\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/tools/invalid_ate-tags\",\n        )\n\n    async def get_tools_labels(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get all the used labels\n\n        List all the labels that are associated with any resource of the Orthanc database\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the labels\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/labels\",\n        )\n\n    async def get_tools_log_level(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get main log level\n\n        Get the main log level of Orthanc\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level\",\n        )\n\n    async def put_tools_log_level(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set main log level\n\n        Set the main log level of Orthanc\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level\",\n            data=data,\n        )\n\n    async def get_tools_log_level_dicom(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get log level for `dicom`\n\n        Get the log level of the log category `dicom`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level-dicom\",\n        )\n\n    async def put_tools_log_level_dicom(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set log level for `dicom`\n\n        Set the log level of the log category `dicom`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level-dicom\",\n            data=data,\n        )\n\n    async def get_tools_log_level_generic(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get log level for `generic`\n\n        Get the log level of the log category `generic`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level-generic\",\n        )\n\n    async def put_tools_log_level_generic(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set log level for `generic`\n\n        Set the log level of the log category `generic`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level-generic\",\n            data=data,\n        )\n\n    async def get_tools_log_level_http(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get log level for `http`\n\n        Get the log level of the log category `http`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level-http\",\n        )\n\n    async def put_tools_log_level_http(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set log level for `http`\n\n        Set the log level of the log category `http`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level-http\",\n            data=data,\n        )\n\n    async def get_tools_log_level_jobs(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get log level for `jobs`\n\n        Get the log level of the log category `jobs`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level-jobs\",\n        )\n\n    async def put_tools_log_level_jobs(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set log level for `jobs`\n\n        Set the log level of the log category `jobs`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level-jobs\",\n            data=data,\n        )\n\n    async def get_tools_log_level_lua(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get log level for `lua`\n\n        Get the log level of the log category `lua`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level-lua\",\n        )\n\n    async def put_tools_log_level_lua(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set log level for `lua`\n\n        Set the log level of the log category `lua`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level-lua\",\n            data=data,\n        )\n\n    async def get_tools_log_level_plugins(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get log level for `plugins`\n\n        Get the log level of the log category `plugins`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level-plugins\",\n        )\n\n    async def put_tools_log_level_plugins(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set log level for `plugins`\n\n        Set the log level of the log category `plugins`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level-plugins\",\n            data=data,\n        )\n\n    async def get_tools_log_level_sqlite(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get log level for `sqlite`\n\n        Get the log level of the log category `sqlite`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/log-level-sqlite\",\n        )\n\n    async def put_tools_log_level_sqlite(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set log level for `sqlite`\n\n        Set the log level of the log category `sqlite`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/log-level-sqlite\",\n            data=data,\n        )\n\n    async def post_tools_lookup(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Look for DICOM identifiers\n\n        This URI can be used to convert one DICOM identifier to a list of matching Orthanc resources\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            The DICOM identifier of interest (i.e. the value of `PatientID`, `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing a list of matching Orthanc resources, each item in the list corresponding to a JSON object with the fields `Type`, `ID` and `Path` identifying one DICOM resource that is stored by Orthanc\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/tools/lookup\",\n            data=data,\n        )\n\n    async def get_tools_metrics(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Are metrics collected?\n\n        Returns a Boolean specifying whether Prometheus metrics are collected and exposed at `/tools/metrics-prometheus`\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `1` if metrics are collected, `0` if metrics are disabled\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/metrics\",\n        )\n\n    async def put_tools_metrics(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Enable collection of metrics\n\n        Enable or disable the collection and publication of metrics at `/tools/metrics-prometheus`\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            `1` if metrics are collected, `0` if metrics are disabled\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/metrics\",\n            data=data,\n        )\n\n    async def get_tools_metrics_prometheus(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get usage metrics\n\n        Get usage metrics of Orthanc in the Prometheus file format (OpenMetrics): https://orthanc.uclouvain.be/book/users/advanced-rest.html#instrumentation-with-prometheus\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            No description\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/metrics-prometheus\",\n        )\n\n    async def get_tools_now(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get UTC time\n\n        Get UTC time\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The UTC time\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/now\",\n        )\n\n    async def get_tools_now_local(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Get local time\n\n        Get local time\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The local time\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/now-local\",\n        )\n\n    async def post_tools_reconstruct(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Reconstruct all the index\n\n        Reconstruct the index of all the tags of all the DICOM instances that are stored in Orthanc. This is notably useful after the deletion of resources whose children resources have inconsistent values with their sibling resources. Beware that this is a highly time-consuming operation, as all the DICOM instances will be parsed again, and as all the Orthanc index will be regenerated. If you have a large database to process, it is advised to use the Housekeeper plugin to perform this action resource by resource\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return await self._post(\n            route=f\"{self.url}/tools/reconstruct\",\n            json=json,\n        )\n\n    async def post_tools_reset(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Restart Orthanc\n\n        Restart Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/tools/reset\",\n        )\n\n    async def post_tools_shutdown(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Shutdown Orthanc\n\n        Shutdown Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._post(\n            route=f\"{self.url}/tools/shutdown\",\n        )\n\n    async def get_tools_unknown_sop_class_accepted(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Is unknown SOP class accepted?\n\n        Shall Orthanc C-STORE SCP accept DICOM instances with an unknown SOP class UID?\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `1` if accepted, `0` if not accepted\n        \"\"\"\n        return await self._get(\n            route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n        )\n\n    async def put_tools_unknown_sop_class_accepted(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"(async) Set unknown SOP class accepted\n\n        Set whether Orthanc C-STORE SCP should accept DICOM instances with an unknown SOP class UID\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            `1` if accepted, `0` if not accepted\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return await self._put(\n            route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n            data=data,\n        )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.__init__","title":"<code>__init__(url, username=None, password=None, return_raw_response=False, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>server's URL</p> required <code>username</code> <code>Optional[str]</code> <p>Orthanc's username</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Orthanc's password</p> <code>None</code> <code>return_raw_response</code> <code>bool</code> <p>All Orthanc's methods will return a raw httpx.Response rather than the serialized result</p> <code>False</code> <code>*args</code> <p>Parameters passed to the httpx.Client (headers, timeout, etc.)</p> <code>()</code> <code>**kwargs</code> <p>Parameters passed to the httpx.Client (headers, timeout, etc.)</p> <code>()</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    return_raw_response: bool = False,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Parameters\n    ----------\n    url\n        server's URL\n    username\n        Orthanc's username\n    password\n        Orthanc's password\n    return_raw_response\n        All Orthanc's methods will return a raw httpx.Response rather than the serialized result\n    *args, **kwargs\n        Parameters passed to the httpx.Client (headers, timeout, etc.)\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.url = url\n    self.version = \"1.12.6\"\n    self.return_raw_response = return_raw_response\n\n    if username and password:\n        self.setup_credentials(username, password)\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_changes","title":"<code>delete_changes()</code>  <code>async</code>","text":"<p>(async) Clear changes</p> <p>Clear the full history stored in the changes log Tags: Tracking changes</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_changes(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Clear changes\n\n    Clear the full history stored in the changes log\n    Tags: Tracking changes\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/changes\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_exports","title":"<code>delete_exports()</code>  <code>async</code>","text":"<p>(async) Clear exports</p> <p>Clear the full history stored in the exports log Tags: Tracking changes</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_exports(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Clear exports\n\n    Clear the full history stored in the exports log\n    Tags: Tracking changes\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/exports\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_instances_id","title":"<code>delete_instances_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete some instance</p> <p>Delete the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_instances_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete some instance\n\n    Delete the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/instances/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_instances_id_attachments_name","title":"<code>delete_instances_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete attachment</p> <p>Delete an attachment associated with the given DICOM instance. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_instances_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete attachment\n\n    Delete an attachment associated with the given DICOM instance. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_instances_id_labels_label","title":"<code>delete_instances_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Remove label</p> <p>Remove a label associated with a instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_instances_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Remove label\n\n    Remove a label associated with a instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/instances/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_instances_id_metadata_name","title":"<code>delete_instances_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete metadata</p> <p>Delete some metadata associated with the given DICOM instance. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_instances_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete metadata\n\n    Delete some metadata associated with the given DICOM instance. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_jobs_id","title":"<code>delete_jobs_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete a job from history</p> <p>Delete the job from the jobs history.  Only a completed job can be deleted. If the job has not run or not completed yet, you must cancel it first. If the job has outputs, all outputs will be deleted as well. Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_jobs_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete a job from history\n\n    Delete the job from the jobs history.  Only a completed job can be deleted. If the job has not run or not completed yet, you must cancel it first. If the job has outputs, all outputs will be deleted as well.\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/jobs/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_jobs_id_key","title":"<code>delete_jobs_id_key(id_, key)</code>  <code>async</code>","text":"<p>(async) Delete a job output</p> <p>Delete the output produced by a job. As of Orthanc 1.12.1, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with <code>key</code> equals to <code>archive</code>). Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of the output of interest</p> required <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_jobs_id_key(\n    self,\n    id_: str,\n    key: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete a job output\n\n    Delete the output produced by a job. As of Orthanc 1.12.1, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n    Tags: Jobs\n\n    Parameters\n    ----------\n    key\n        Name of the output of interest\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/jobs/{id_}/{key}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_modalities_id","title":"<code>delete_modalities_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete DICOM modality</p> <p>Delete one DICOM modality. This change is permanent iff. <code>DicomModalitiesInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the DICOM modality of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_modalities_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete DICOM modality\n\n    Delete one DICOM modality. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the DICOM modality of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/modalities/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_patients_id","title":"<code>delete_patients_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete some patient</p> <p>Delete the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_patients_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete some patient\n\n    Delete the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/patients/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_patients_id_attachments_name","title":"<code>delete_patients_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete attachment</p> <p>Delete an attachment associated with the given DICOM patient. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_patients_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete attachment\n\n    Delete an attachment associated with the given DICOM patient. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_patients_id_labels_label","title":"<code>delete_patients_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Remove label</p> <p>Remove a label associated with a patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_patients_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Remove label\n\n    Remove a label associated with a patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/patients/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_patients_id_metadata_name","title":"<code>delete_patients_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete metadata</p> <p>Delete some metadata associated with the given DICOM patient. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_patients_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete metadata\n\n    Delete some metadata associated with the given DICOM patient. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_peers_id","title":"<code>delete_peers_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete Orthanc peer</p> <p>Delete one Orthanc peer. This change is permanent iff. <code>OrthancPeersInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the Orthanc peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_peers_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete Orthanc peer\n\n    Delete one Orthanc peer. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the Orthanc peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/peers/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_queries_id","title":"<code>delete_queries_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete a query</p> <p>Delete the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_queries_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete a query\n\n    Delete the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/queries/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_series_id","title":"<code>delete_series_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete some series</p> <p>Delete the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_series_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete some series\n\n    Delete the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/series/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_series_id_attachments_name","title":"<code>delete_series_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete attachment</p> <p>Delete an attachment associated with the given DICOM series. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_series_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete attachment\n\n    Delete an attachment associated with the given DICOM series. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/series/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_series_id_labels_label","title":"<code>delete_series_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Remove label</p> <p>Remove a label associated with a series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_series_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Remove label\n\n    Remove a label associated with a series\n    Tags: Series\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/series/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_series_id_metadata_name","title":"<code>delete_series_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete metadata</p> <p>Delete some metadata associated with the given DICOM series. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_series_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete metadata\n\n    Delete some metadata associated with the given DICOM series. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/series/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_studies_id","title":"<code>delete_studies_id(id_)</code>  <code>async</code>","text":"<p>(async) Delete some study</p> <p>Delete the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_studies_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete some study\n\n    Delete the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/studies/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_studies_id_attachments_name","title":"<code>delete_studies_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete attachment</p> <p>Delete an attachment associated with the given DICOM study. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_studies_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete attachment\n\n    Delete an attachment associated with the given DICOM study. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_studies_id_labels_label","title":"<code>delete_studies_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Remove label</p> <p>Remove a label associated with a study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_studies_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Remove label\n\n    Remove a label associated with a study\n    Tags: Studies\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/studies/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.delete_studies_id_metadata_name","title":"<code>delete_studies_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Delete metadata</p> <p>Delete some metadata associated with the given DICOM study. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def delete_studies_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete metadata\n\n    Delete some metadata associated with the given DICOM study. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._delete(\n        route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_changes","title":"<code>get_changes(params=None)</code>  <code>async</code>","text":"<p>(async) List changes</p> <p>Whenever Orthanc receives a new DICOM instance, this event is recorded in the so-called Changes Log. This enables remote scripts to react to the arrival of new DICOM resources. A typical application is auto-routing, where an external script waits for a new DICOM instance to arrive into Orthanc, then forward this instance to another modality. Please note that, when resources are deleted, their corresponding change entries are also removed from the Changes Log, which helps ensuring that this log does not grow indefinitely. Tags: Tracking changes</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"last\" (float): Request only the last change id (this argument must be used alone)     \"limit\" (float): Limit the number of results     \"since\" (float): Show only the resources since the provided index excluded     \"to\" (float): Show only the resources till the provided index included (only available if your DB backend supports ExtendedChanges)     \"type\" (str): Show only the changes of the provided type (only available if your DB backend supports ExtendedChanges).  Multiple values can be provided and must be separated by a ';'.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of changes</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_changes(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List changes\n\n    Whenever Orthanc receives a new DICOM instance, this event is recorded in the so-called _Changes Log_. This enables remote scripts to react to the arrival of new DICOM resources. A typical application is auto-routing, where an external script waits for a new DICOM instance to arrive into Orthanc, then forward this instance to another modality. Please note that, when resources are deleted, their corresponding change entries are also removed from the Changes Log, which helps ensuring that this log does not grow indefinitely.\n    Tags: Tracking changes\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"last\" (float): Request only the last change id (this argument must be used alone)\n            \"limit\" (float): Limit the number of results\n            \"since\" (float): Show only the resources since the provided index excluded\n            \"to\" (float): Show only the resources till the provided index included (only available if your DB backend supports ExtendedChanges)\n            \"type\" (str): Show only the changes of the provided type (only available if your DB backend supports ExtendedChanges).  Multiple values can be provided and must be separated by a ';'.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of changes\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/changes\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_exports","title":"<code>get_exports(params=None)</code>  <code>async</code>","text":"<p>(async) List exports</p> <p>For medical traceability, Orthanc can be configured to store a log of all the resources that have been exported to remote modalities. In auto-routing scenarios, it is important to prevent this log to grow indefinitely as incoming instances are routed. You can either disable this logging by setting the option <code>LogExportedResources</code> to <code>false</code> in the configuration file, or periodically clear this log by <code>DELETE</code>-ing this URI. This route might be removed in future versions of Orthanc. Tags: Tracking changes</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"limit\" (float): Limit the number of results     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of exports</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_exports(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List exports\n\n    For medical traceability, Orthanc can be configured to store a log of all the resources that have been exported to remote modalities. In auto-routing scenarios, it is important to prevent this log to grow indefinitely as incoming instances are routed. You can either disable this logging by setting the option `LogExportedResources` to `false` in the configuration file, or periodically clear this log by `DELETE`-ing this URI. This route might be removed in future versions of Orthanc.\n    Tags: Tracking changes\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"limit\" (float): Limit the number of results\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of exports\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/exports\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances","title":"<code>get_instances(params=None)</code>  <code>async</code>","text":"<p>(async) List the available instances</p> <p>List the Orthanc identifiers of all the available DICOM instances Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported instances (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List the available instances\n\n    List the Orthanc identifiers of all the available DICOM instances\n    Tags: Instances\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported instances (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id","title":"<code>get_instances_id(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get information about some instance</p> <p>Get detailed information about the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM instance</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get information about some instance\n\n    Get detailed information about the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM instance\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments","title":"<code>get_instances_id_attachments(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List attachments</p> <p>Get the list of attachments that are associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List attachments\n\n    Get the list of attachments that are associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name","title":"<code>get_instances_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given instance Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given instance\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_compressed_data","title":"<code>get_instances_id_attachments_name_compressed_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given instance. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given instance. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_compressed_md5","title":"<code>get_instances_id_attachments_name_compressed_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given instance, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given instance, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_compressed_size","title":"<code>get_instances_id_attachments_name_compressed_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given instance, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment on disk\n\n    Get the size of one attachment associated with the given instance, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_data","title":"<code>get_instances_id_attachments_name_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment</p> <p>Get the (binary) content of one attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment\n\n    Get the (binary) content of one attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_info","title":"<code>get_instances_id_attachments_name_info(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get info about the attachment</p> <p>Get all the information about the attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get info about the attachment\n\n    Get all the information about the attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_is_compressed","title":"<code>get_instances_id_attachments_name_is_compressed(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_md5","title":"<code>get_instances_id_attachments_name_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_attachments_name_size","title":"<code>get_instances_id_attachments_name_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment</p> <p>Get the size of one attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment\n\n    Get the size of one attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_content_path","title":"<code>get_instances_id_content_path(id_, path)</code>  <code>async</code>","text":"<p>(async) Get raw tag</p> <p>Get the raw content of one DICOM tag in the hierarchy of DICOM dataset Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, <code>/0008-1140/1/0008-1150</code></p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The raw value of the tag of intereset (binary data, whose memory layout depends on the underlying transfer syntax), or JSON array containing the list of available tags if accessing a dataset</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_content_path(\n    self,\n    id_: str,\n    path: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get raw tag\n\n    Get the raw content of one DICOM tag in the hierarchy of DICOM dataset\n    Tags: Instances\n\n    Parameters\n    ----------\n    path\n        Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, `/0008-1140/1/0008-1150`\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The raw value of the tag of intereset (binary data, whose memory layout depends on the underlying transfer syntax), or JSON array containing the list of available tags if accessing a dataset\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/content/{path}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_file","title":"<code>get_instances_id_file(id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Download DICOM</p> <p>Download one DICOM instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"transcode\" (str): If present, the DICOM file will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): This HTTP header can be set to retrieve the DICOM instance in DICOMweb format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The DICOM instance The DICOM instance, in DICOMweb JSON format The DICOM instance, in DICOMweb XML format</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_file(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Download DICOM\n\n    Download one DICOM instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"transcode\" (str): If present, the DICOM file will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): This HTTP header can be set to retrieve the DICOM instance in DICOMweb format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The DICOM instance\n        The DICOM instance, in DICOMweb JSON format\n        The DICOM instance, in DICOMweb XML format\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/file\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames","title":"<code>get_instances_id_frames(id_)</code>  <code>async</code>","text":"<p>(async) List available frames</p> <p>List the frames that are available in the DICOM instance of interest Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of the indices of the available frames</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List available frames\n\n    List the frames that are available in the DICOM instance of interest\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of the indices of the available frames\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame","title":"<code>get_instances_id_frames_frame(frame, id_)</code>  <code>async</code>","text":"<p>(async) List operations</p> <p>List the available operations under URI <code>/instances/{id}/frames/{frame}/</code> Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>str</code> required <code>id_</code> <code>str</code> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame(\n    self,\n    frame: str,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations\n\n    List the available operations under URI `/instances/{id}/frames/{frame}/`\n    Tags: Other\n\n    Parameters\n    ----------\n    frame\n\n    id_\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_image_int16","title":"<code>get_instances_id_frames_frame_image_int16(frame, id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode a frame (int16)</p> <p>Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_image_int16(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode a frame (int16)\n\n    Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/image-int16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_image_uint16","title":"<code>get_instances_id_frames_frame_image_uint16(frame, id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode a frame (uint16)</p> <p>Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_image_uint16(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode a frame (uint16)\n\n    Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_image_uint8","title":"<code>get_instances_id_frames_frame_image_uint8(frame, id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode a frame (uint8)</p> <p>Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_image_uint8(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode a frame (uint8)\n\n    Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint8\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_matlab","title":"<code>get_instances_id_frames_frame_matlab(frame, id_)</code>  <code>async</code>","text":"<p>(async) Decode frame for Matlab</p> <p>Decode one frame of interest from the given DICOM instance, and export this frame as a Octave/Matlab matrix to be imported with <code>eval()</code>: https://orthanc.uclouvain.be/book/faq/matlab.html Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Octave/Matlab matrix</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_matlab(\n    self,\n    frame: float,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode frame for Matlab\n\n    Decode one frame of interest from the given DICOM instance, and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Octave/Matlab matrix\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/matlab\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_numpy","title":"<code>get_instances_id_frames_frame_numpy(frame, id_, params=None)</code>  <code>async</code>","text":"<p>(async) Decode frame for numpy</p> <p>Decode one frame of interest from the given DICOM instance, for use with numpy in Python. The numpy array has 3 dimensions: (height, width, color channel). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM resource of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"compress\" (bool): Compress the file as <code>.npz</code>     \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_numpy(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode frame for numpy\n\n    Decode one frame of interest from the given DICOM instance, for use with numpy in Python. The numpy array has 3 dimensions: (height, width, color channel).\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM resource of interest\n    params\n        Dictionary of optional parameters:\n            \"compress\" (bool): Compress the file as `.npz`\n            \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/numpy\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_preview","title":"<code>get_instances_id_frames_frame_preview(frame, id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode a frame (preview)</p> <p>Decode one frame of interest from the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_preview(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode a frame (preview)\n\n    Decode one frame of interest from the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/preview\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_raw","title":"<code>get_instances_id_frames_frame_raw(frame, id_)</code>  <code>async</code>","text":"<p>(async) Access raw frame</p> <p>Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The raw frame</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_raw(\n    self,\n    frame: float,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Access raw frame\n\n    Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The raw frame\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/raw\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_raw_gz","title":"<code>get_instances_id_frames_frame_raw_gz(frame, id_)</code>  <code>async</code>","text":"<p>(async) Access raw frame (compressed)</p> <p>Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. The image is compressed using gzip Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The raw frame, compressed using gzip</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_raw_gz(\n    self,\n    frame: float,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Access raw frame (compressed)\n\n    Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. The image is compressed using gzip\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The raw frame, compressed using gzip\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/raw.gz\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_frames_frame_rendered","title":"<code>get_instances_id_frames_frame_rendered(frame, id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Render a frame</p> <p>Render one frame of interest from the given DICOM instance. This function takes scaling into account (<code>RescaleSlope</code> and <code>RescaleIntercept</code> tags), as well as the default windowing stored in the DICOM file (<code>WindowCenter</code> and <code>WindowWidth</code>tags), and can be used to resize the resulting image. Color images are not affected by windowing. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"height\" (float): Height of the resized image     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)     \"smooth\" (bool): Whether to smooth image on resize     \"width\" (float): Width of the resized image     \"window-center\" (float): Windowing center     \"window-width\" (float): Windowing width</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_frames_frame_rendered(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Render a frame\n\n    Render one frame of interest from the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"height\" (float): Height of the resized image\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n            \"smooth\" (bool): Whether to smooth image on resize\n            \"width\" (float): Width of the resized image\n            \"window-center\" (float): Windowing center\n            \"window-width\" (float): Windowing width\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/rendered\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_header","title":"<code>get_instances_id_header(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get DICOM meta-header</p> <p>Get the DICOM tags in the meta-header of the DICOM instance. By default, the <code>full</code> format is used, which combines hexadecimal tags with human-readable description. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags and their associated value</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_header(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get DICOM meta-header\n\n    Get the DICOM tags in the meta-header of the DICOM instance. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags and their associated value\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/header\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_image_int16","title":"<code>get_instances_id_image_int16(id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode an image (int16)</p> <p>Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_image_int16(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode an image (int16)\n\n    Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/image-int16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_image_uint16","title":"<code>get_instances_id_image_uint16(id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode an image (uint16)</p> <p>Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_image_uint16(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode an image (uint16)\n\n    Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/image-uint16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_image_uint8","title":"<code>get_instances_id_image_uint8(id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode an image (uint8)</p> <p>Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_image_uint8(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode an image (uint8)\n\n    Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/image-uint8\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_labels","title":"<code>get_instances_id_labels(id_)</code>  <code>async</code>","text":"<p>(async) List labels</p> <p>Get the labels that are associated with the given instance (new in Orthanc 1.12.0) Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List labels\n\n    Get the labels that are associated with the given instance (new in Orthanc 1.12.0)\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_labels_label","title":"<code>get_instances_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Test label</p> <p>Test whether the instance is associated with the given label Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Test label\n\n    Test whether the instance is associated with the given label\n    Tags: Instances\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_matlab","title":"<code>get_instances_id_matlab(id_)</code>  <code>async</code>","text":"<p>(async) Decode frame for Matlab</p> <p>Decode the first frame of the given DICOM instance., and export this frame as a Octave/Matlab matrix to be imported with <code>eval()</code>: https://orthanc.uclouvain.be/book/faq/matlab.html Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Octave/Matlab matrix</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_matlab(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode frame for Matlab\n\n    Decode the first frame of the given DICOM instance., and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Octave/Matlab matrix\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/matlab\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_metadata","title":"<code>get_instances_id_metadata(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List metadata</p> <p>Get the list of metadata that are associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List metadata\n\n    Get the list of metadata that are associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_metadata_name","title":"<code>get_instances_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get metadata</p> <p>Get the value of a metadata that is associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get metadata\n\n    Get the value of a metadata that is associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_module","title":"<code>get_instances_id_module(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get instance module</p> <p>Get the instance module of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM instance</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get instance module\n\n    Get the instance module of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM instance\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_numpy","title":"<code>get_instances_id_numpy(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Decode instance for numpy</p> <p>Decode the given DICOM instance, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM resource of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"compress\" (bool): Compress the file as <code>.npz</code>     \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_numpy(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode instance for numpy\n\n    Decode the given DICOM instance, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM resource of interest\n    params\n        Dictionary of optional parameters:\n            \"compress\" (bool): Compress the file as `.npz`\n            \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/numpy\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_patient","title":"<code>get_instances_id_patient(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get parent patient</p> <p>Get detailed information about the parent patient of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM patient</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get parent patient\n\n    Get detailed information about the parent patient of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM patient\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_pdf","title":"<code>get_instances_id_pdf(id_)</code>  <code>async</code>","text":"<p>(async) Get embedded PDF</p> <p>Get the PDF file that is embedded in one DICOM instance. If the DICOM instance doesn't contain the <code>EncapsulatedDocument</code> tag or if the <code>MIMETypeOfEncapsulatedDocument</code> tag doesn't correspond to the PDF type, a <code>404</code> HTTP error is raised. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>PDF file</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_pdf(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get embedded PDF\n\n    Get the PDF file that is embedded in one DICOM instance. If the DICOM instance doesn't contain the `EncapsulatedDocument` tag or if the `MIMETypeOfEncapsulatedDocument` tag doesn't correspond to the PDF type, a `404` HTTP error is raised.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        PDF file\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/pdf\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_preview","title":"<code>get_instances_id_preview(id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Decode an image (preview)</p> <p>Decode the first frame of the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_preview(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode an image (preview)\n\n    Decode the first frame of the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/preview\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_rendered","title":"<code>get_instances_id_rendered(id_, params=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Render an image</p> <p>Render the first frame of the given DICOM instance. This function takes scaling into account (<code>RescaleSlope</code> and <code>RescaleIntercept</code> tags), as well as the default windowing stored in the DICOM file (<code>WindowCenter</code> and <code>WindowWidth</code>tags), and can be used to resize the resulting image. Color images are not affected by windowing. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"height\" (float): Height of the resized image     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)     \"smooth\" (bool): Whether to smooth image on resize     \"width\" (float): Width of the resized image     \"window-center\" (float): Windowing center     \"window-width\" (float): Windowing width</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_rendered(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Render an image\n\n    Render the first frame of the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"height\" (float): Height of the resized image\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n            \"smooth\" (bool): Whether to smooth image on resize\n            \"width\" (float): Width of the resized image\n            \"window-center\" (float): Windowing center\n            \"window-width\" (float): Windowing width\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/rendered\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_series","title":"<code>get_instances_id_series(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get parent series</p> <p>Get detailed information about the parent series of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM series</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_series(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get parent series\n\n    Get detailed information about the parent series of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM series\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_simplified_tags","title":"<code>get_instances_id_simplified_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get human-readable tags</p> <p>Get the DICOM tags in human-readable format (same as the <code>/instances/{id}/tags?simplify</code> route) Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags and their associated value</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_simplified_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get human-readable tags\n\n    Get the DICOM tags in human-readable format (same as the `/instances/{id}/tags?simplify` route)\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags and their associated value\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/simplified-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_statistics","title":"<code>get_instances_id_statistics(id_)</code>  <code>async</code>","text":"<p>(async) Get instance statistics</p> <p>Get statistics about the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get instance statistics\n\n    Get statistics about the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_study","title":"<code>get_instances_id_study(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get parent study</p> <p>Get detailed information about the parent study of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM study</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_study(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get parent study\n\n    Get detailed information about the parent study of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM study\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/study\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_instances_id_tags","title":"<code>get_instances_id_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get DICOM tags</p> <p>Get the DICOM tags in the specified format. By default, the <code>full</code> format is used, which combines hexadecimal tags with human-readable description. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)     \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags and their associated value</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_instances_id_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get DICOM tags\n\n    Get the DICOM tags in the specified format. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n            \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags and their associated value\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/instances/{id_}/tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_jobs","title":"<code>get_jobs(params=None)</code>  <code>async</code>","text":"<p>(async) List jobs</p> <p>List all the available jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual jobs</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the jobs identifiers, or detailed information about the reported jobs (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_jobs(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List jobs\n\n    List all the available jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual jobs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the jobs identifiers, or detailed information about the reported jobs (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/jobs\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_jobs_id","title":"<code>get_jobs_id(id_)</code>  <code>async</code>","text":"<p>(async) Get job</p> <p>Retrieve detailed information about the job whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object detailing the job</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_jobs_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get job\n\n    Retrieve detailed information about the job whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object detailing the job\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/jobs/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_jobs_id_key","title":"<code>get_jobs_id_key(id_, key)</code>  <code>async</code>","text":"<p>(async) Get job output</p> <p>Retrieve some output produced by a job. As of Orthanc 1.8.2, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with <code>key</code> equals to <code>archive</code>). Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of the output of interest</p> required <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Content of the output of the job</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_jobs_id_key(\n    self,\n    id_: str,\n    key: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get job output\n\n    Retrieve some output produced by a job. As of Orthanc 1.8.2, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n    Tags: Jobs\n\n    Parameters\n    ----------\n    key\n        Name of the output of interest\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Content of the output of the job\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/jobs/{id_}/{key}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_modalities","title":"<code>get_modalities(params=None)</code>  <code>async</code>","text":"<p>(async) List DICOM modalities</p> <p>List all the DICOM modalities that are known to Orthanc. This corresponds either to the content of the <code>DicomModalities</code> configuration option, or to the information stored in the database if <code>DicomModalitiesInDatabase</code> is <code>true</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual DICOM modalities</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the identifiers of the modalities, or detailed information about the modalities (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_modalities(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List DICOM modalities\n\n    List all the DICOM modalities that are known to Orthanc. This corresponds either to the content of the `DicomModalities` configuration option, or to the information stored in the database if `DicomModalitiesInDatabase` is `true`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual DICOM modalities\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the identifiers of the modalities, or detailed information about the modalities (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/modalities\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_modalities_id","title":"<code>get_modalities_id(id_)</code>  <code>async</code>","text":"<p>(async) List operations on modality</p> <p>List the operations that are available for a DICOM modality. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the DICOM modality of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_modalities_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on modality\n\n    List the operations that are available for a DICOM modality.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the DICOM modality of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/modalities/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_modalities_id_configuration","title":"<code>get_modalities_id_configuration(id_)</code>  <code>async</code>","text":"<p>(async) Get modality configuration</p> <p>Get detailed information about the configuration of some DICOM modality Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Configuration of the modality</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_modalities_id_configuration(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get modality configuration\n\n    Get detailed information about the configuration of some DICOM modality\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Configuration of the modality\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/modalities/{id_}/configuration\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients","title":"<code>get_patients(params=None)</code>  <code>async</code>","text":"<p>(async) List the available patients</p> <p>List the Orthanc identifiers of all the available DICOM patients Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported patients (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List the available patients\n\n    List the Orthanc identifiers of all the available DICOM patients\n    Tags: Patients\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported patients (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id","title":"<code>get_patients_id(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get information about some patient</p> <p>Get detailed information about the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM patient</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get information about some patient\n\n    Get detailed information about the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM patient\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_archive","title":"<code>get_patients_id_archive(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Synchronously create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_archive(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Synchronously create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments","title":"<code>get_patients_id_attachments(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List attachments</p> <p>Get the list of attachments that are associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List attachments\n\n    Get the list of attachments that are associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name","title":"<code>get_patients_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given patient Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given patient\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_compressed_data","title":"<code>get_patients_id_attachments_name_compressed_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given patient. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given patient. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_compressed_md5","title":"<code>get_patients_id_attachments_name_compressed_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given patient, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given patient, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_compressed_size","title":"<code>get_patients_id_attachments_name_compressed_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given patient, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment on disk\n\n    Get the size of one attachment associated with the given patient, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_data","title":"<code>get_patients_id_attachments_name_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment</p> <p>Get the (binary) content of one attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment\n\n    Get the (binary) content of one attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_info","title":"<code>get_patients_id_attachments_name_info(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get info about the attachment</p> <p>Get all the information about the attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get info about the attachment\n\n    Get all the information about the attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_is_compressed","title":"<code>get_patients_id_attachments_name_is_compressed(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_md5","title":"<code>get_patients_id_attachments_name_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_attachments_name_size","title":"<code>get_patients_id_attachments_name_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment</p> <p>Get the size of one attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment\n\n    Get the size of one attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_instances","title":"<code>get_patients_id_instances(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get child instances</p> <p>Get detailed information about the child instances of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child instances     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM instances</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_instances(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get child instances\n\n    Get detailed information about the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child instances\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM instances\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_instances_tags","title":"<code>get_patients_id_instances_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get tags of instances</p> <p>Get the tags of all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_instances_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get tags of instances\n\n    Get the tags of all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/instances-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_labels","title":"<code>get_patients_id_labels(id_)</code>  <code>async</code>","text":"<p>(async) List labels</p> <p>Get the labels that are associated with the given patient (new in Orthanc 1.12.0) Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List labels\n\n    Get the labels that are associated with the given patient (new in Orthanc 1.12.0)\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_labels_label","title":"<code>get_patients_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Test label</p> <p>Test whether the patient is associated with the given label Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Test label\n\n    Test whether the patient is associated with the given label\n    Tags: Patients\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_media","title":"<code>get_patients_id_media(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Synchronously create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"extended\" (str): If present, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_media(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Synchronously create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_metadata","title":"<code>get_patients_id_metadata(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List metadata</p> <p>Get the list of metadata that are associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List metadata\n\n    Get the list of metadata that are associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_metadata_name","title":"<code>get_patients_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get metadata</p> <p>Get the value of a metadata that is associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get metadata\n\n    Get the value of a metadata that is associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_module","title":"<code>get_patients_id_module(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get patient module</p> <p>Get the patient module of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM patient</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get patient module\n\n    Get the patient module of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM patient\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_protected","title":"<code>get_patients_id_protected(id_)</code>  <code>async</code>","text":"<p>(async) Is the patient protected against recycling?</p> <p>Is the patient protected against recycling? Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>1</code> if protected, <code>0</code> if not protected</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_protected(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Is the patient protected against recycling?\n\n    Is the patient protected against recycling?\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `1` if protected, `0` if not protected\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/protected\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_series","title":"<code>get_patients_id_series(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get child series</p> <p>Get detailed information about the child series of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child series     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM series</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_series(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get child series\n\n    Get detailed information about the child series of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child series\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM series\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_shared_tags","title":"<code>get_patients_id_shared_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get shared tags</p> <p>Extract the DICOM tags whose value is constant across all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the values of the DICOM tags</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_shared_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get shared tags\n\n    Extract the DICOM tags whose value is constant across all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the values of the DICOM tags\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/shared-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_statistics","title":"<code>get_patients_id_statistics(id_)</code>  <code>async</code>","text":"<p>(async) Get patient statistics</p> <p>Get statistics about the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get patient statistics\n\n    Get statistics about the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_patients_id_studies","title":"<code>get_patients_id_studies(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get child studies</p> <p>Get detailed information about the child studies of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child studies     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM studies</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_patients_id_studies(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get child studies\n\n    Get detailed information about the child studies of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child studies\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM studies\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/patients/{id_}/studies\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_peers","title":"<code>get_peers(params=None)</code>  <code>async</code>","text":"<p>(async) List Orthanc peers</p> <p>List all the Orthanc peers that are known to Orthanc. This corresponds either to the content of the <code>OrthancPeers</code> configuration option, or to the information stored in the database if <code>OrthancPeersInDatabase</code> is <code>true</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual Orthanc peers</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the identifiers of the peers, or detailed information about the peers (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_peers(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List Orthanc peers\n\n    List all the Orthanc peers that are known to Orthanc. This corresponds either to the content of the `OrthancPeers` configuration option, or to the information stored in the database if `OrthancPeersInDatabase` is `true`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual Orthanc peers\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the identifiers of the peers, or detailed information about the peers (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/peers\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_peers_id","title":"<code>get_peers_id(id_)</code>  <code>async</code>","text":"<p>(async) List operations on peer</p> <p>List the operations that are available for an Orthanc peer. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_peers_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on peer\n\n    List the operations that are available for an Orthanc peer.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/peers/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_peers_id_configuration","title":"<code>get_peers_id_configuration(id_)</code>  <code>async</code>","text":"<p>(async) Get peer configuration</p> <p>Get detailed information about the configuration of some Orthanc peer Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Configuration of the peer</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_peers_id_configuration(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get peer configuration\n\n    Get detailed information about the configuration of some Orthanc peer\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Configuration of the peer\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/peers/{id_}/configuration\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_peers_id_system","title":"<code>get_peers_id_system(id_)</code>  <code>async</code>","text":"<p>(async) Get peer system information</p> <p>Get system information about some Orthanc peer. This corresponds to doing a <code>GET</code> request against the <code>/system</code> URI of the remote peer. This route can be used to test connectivity. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>System information about the peer</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_peers_id_system(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get peer system information\n\n    Get system information about some Orthanc peer. This corresponds to doing a `GET` request against the `/system` URI of the remote peer. This route can be used to test connectivity.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        System information about the peer\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/peers/{id_}/system\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_plugins","title":"<code>get_plugins()</code>  <code>async</code>","text":"<p>(async) List plugins</p> <p>List all the installed plugins Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the identifiers of the installed plugins</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_plugins(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List plugins\n\n    List all the installed plugins\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the identifiers of the installed plugins\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/plugins\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_plugins_explorer_js","title":"<code>get_plugins_explorer_js()</code>  <code>async</code>","text":"<p>(async) JavaScript extensions to Orthanc Explorer</p> <p>Get the JavaScript extensions that are installed by all the plugins using the <code>OrthancPluginExtendOrthancExplorer()</code> function of the plugin SDK. This route is for internal use of Orthanc Explorer. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The JavaScript extensions</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_plugins_explorer_js(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) JavaScript extensions to Orthanc Explorer\n\n    Get the JavaScript extensions that are installed by all the plugins using the `OrthancPluginExtendOrthancExplorer()` function of the plugin SDK. This route is for internal use of Orthanc Explorer.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The JavaScript extensions\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/plugins/explorer.js\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_plugins_id","title":"<code>get_plugins_id(id_)</code>  <code>async</code>","text":"<p>(async) Get plugin</p> <p>Get system information about the plugin whose identifier is provided in the URL Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing information about the plugin</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_plugins_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get plugin\n\n    Get system information about the plugin whose identifier is provided in the URL\n    Tags: System\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing information about the plugin\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/plugins/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries","title":"<code>get_queries()</code>  <code>async</code>","text":"<p>(async) List query/retrieve operations</p> <p>List the identifiers of all the query/retrieve operations on DICOM modalities, as initiated by calls to <code>/modalities/{id}/query</code>. The length of this list is bounded by the <code>QueryRetrieveSize</code> configuration option of Orthanc. https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest Tags: Networking</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the identifiers</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List query/retrieve operations\n\n    List the identifiers of all the query/retrieve operations on DICOM modalities, as initiated by calls to `/modalities/{id}/query`. The length of this list is bounded by the `QueryRetrieveSize` configuration option of Orthanc. https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n    Tags: Networking\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the identifiers\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries_id","title":"<code>get_queries_id(id_)</code>  <code>async</code>","text":"<p>(async) List operations on a query</p> <p>List the available operations for the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the list of operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on a query\n\n    List the available operations for the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the list of operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries_id_answers","title":"<code>get_queries_id_answers(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List answers to a query</p> <p>List the indices of all the available answers resulting from a query/retrieve operation on some DICOM modality, whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual answers     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the indices of the answers, or detailed information about the reported answers (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries_id_answers(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List answers to a query\n\n    List the indices of all the available answers resulting from a query/retrieve operation on some DICOM modality, whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual answers\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the indices of the answers, or detailed information about the reported answers (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries/{id_}/answers\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries_id_answers_index","title":"<code>get_queries_id_answers_index(id_, index)</code>  <code>async</code>","text":"<p>(async) List operations on an answer</p> <p>List the available operations on an answer associated with the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the list of operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries_id_answers_index(\n    self,\n    id_: str,\n    index: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on an answer\n\n    List the available operations on an answer associated with the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the list of operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries/{id_}/answers/{index}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries_id_answers_index_content","title":"<code>get_queries_id_answers_index_content(id_, index, params=None)</code>  <code>async</code>","text":"<p>(async) Get one answer</p> <p>Get the content (DICOM tags) of one answer associated with the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags of the answer</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries_id_answers_index_content(\n    self,\n    id_: str,\n    index: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get one answer\n\n    Get the content (DICOM tags) of one answer associated with the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags of the answer\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/content\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries_id_level","title":"<code>get_queries_id_level(id_)</code>  <code>async</code>","text":"<p>(async) Get level of original query</p> <p>Get the query level (value of the <code>QueryRetrieveLevel</code> tag) of the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The level</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries_id_level(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get level of original query\n\n    Get the query level (value of the `QueryRetrieveLevel` tag) of the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The level\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries/{id_}/level\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries_id_modality","title":"<code>get_queries_id_modality(id_)</code>  <code>async</code>","text":"<p>(async) Get modality of original query</p> <p>Get the identifier of the DICOM modality that was targeted by the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The identifier of the DICOM modality</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries_id_modality(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get modality of original query\n\n    Get the identifier of the DICOM modality that was targeted by the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The identifier of the DICOM modality\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries/{id_}/modality\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_queries_id_query","title":"<code>get_queries_id_query(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get original query arguments</p> <p>Get the original DICOM filter associated with the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Content of the original query</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_queries_id_query(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get original query arguments\n\n    Get the original DICOM filter associated with the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Content of the original query\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/queries/{id_}/query\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series","title":"<code>get_series(params=None)</code>  <code>async</code>","text":"<p>(async) List the available series</p> <p>List the Orthanc identifiers of all the available DICOM series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported series (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List the available series\n\n    List the Orthanc identifiers of all the available DICOM series\n    Tags: Series\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported series (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id","title":"<code>get_series_id(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get information about some series</p> <p>Get detailed information about the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM series</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get information about some series\n\n    Get detailed information about the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM series\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_archive","title":"<code>get_series_id_archive(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Synchronously create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_archive(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Synchronously create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments","title":"<code>get_series_id_attachments(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List attachments</p> <p>Get the list of attachments that are associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List attachments\n\n    Get the list of attachments that are associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name","title":"<code>get_series_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given series Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given series\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_compressed_data","title":"<code>get_series_id_attachments_name_compressed_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given series. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given series. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_compressed_md5","title":"<code>get_series_id_attachments_name_compressed_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given series, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given series, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_compressed_size","title":"<code>get_series_id_attachments_name_compressed_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given series, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment on disk\n\n    Get the size of one attachment associated with the given series, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_data","title":"<code>get_series_id_attachments_name_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment</p> <p>Get the (binary) content of one attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment\n\n    Get the (binary) content of one attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_info","title":"<code>get_series_id_attachments_name_info(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get info about the attachment</p> <p>Get all the information about the attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get info about the attachment\n\n    Get all the information about the attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_is_compressed","title":"<code>get_series_id_attachments_name_is_compressed(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_md5","title":"<code>get_series_id_attachments_name_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_attachments_name_size","title":"<code>get_series_id_attachments_name_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment</p> <p>Get the size of one attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment\n\n    Get the size of one attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_instances","title":"<code>get_series_id_instances(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get child instances</p> <p>Get detailed information about the child instances of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child instances     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM instances</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_instances(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get child instances\n\n    Get detailed information about the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child instances\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM instances\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_instances_tags","title":"<code>get_series_id_instances_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get tags of instances</p> <p>Get the tags of all the child instances of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_instances_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get tags of instances\n\n    Get the tags of all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/instances-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_labels","title":"<code>get_series_id_labels(id_)</code>  <code>async</code>","text":"<p>(async) List labels</p> <p>Get the labels that are associated with the given series (new in Orthanc 1.12.0) Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List labels\n\n    Get the labels that are associated with the given series (new in Orthanc 1.12.0)\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_labels_label","title":"<code>get_series_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Test label</p> <p>Test whether the series is associated with the given label Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Test label\n\n    Test whether the series is associated with the given label\n    Tags: Series\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_media","title":"<code>get_series_id_media(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Synchronously create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"extended\" (str): If present, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_media(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Synchronously create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_metadata","title":"<code>get_series_id_metadata(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List metadata</p> <p>Get the list of metadata that are associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List metadata\n\n    Get the list of metadata that are associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_metadata_name","title":"<code>get_series_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get metadata</p> <p>Get the value of a metadata that is associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get metadata\n\n    Get the value of a metadata that is associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_module","title":"<code>get_series_id_module(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get series module</p> <p>Get the series module of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM series</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get series module\n\n    Get the series module of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM series\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_numpy","title":"<code>get_series_id_numpy(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Decode series for numpy</p> <p>Decode the given DICOM series, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM resource of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"compress\" (bool): Compress the file as <code>.npz</code>     \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_numpy(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Decode series for numpy\n\n    Decode the given DICOM series, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM resource of interest\n    params\n        Dictionary of optional parameters:\n            \"compress\" (bool): Compress the file as `.npz`\n            \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/numpy\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_ordered_slices","title":"<code>get_series_id_ordered_slices(id_)</code>  <code>async</code>","text":"<p>(async) Order the slices</p> <p>Sort the instances and frames (slices) of the DICOM series whose Orthanc identifier is provided in the URL. This URI is essentially used by the Orthanc Web viewer and by the Osimis Web viewer. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_ordered_slices(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Order the slices\n\n    Sort the instances and frames (slices) of the DICOM series whose Orthanc identifier is provided in the URL. This URI is essentially used by the Orthanc Web viewer and by the Osimis Web viewer.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/ordered-slices\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_patient","title":"<code>get_series_id_patient(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get parent patient</p> <p>Get detailed information about the parent patient of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM patient</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get parent patient\n\n    Get detailed information about the parent patient of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM patient\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_shared_tags","title":"<code>get_series_id_shared_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get shared tags</p> <p>Extract the DICOM tags whose value is constant across all the child instances of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the values of the DICOM tags</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_shared_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get shared tags\n\n    Extract the DICOM tags whose value is constant across all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the values of the DICOM tags\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/shared-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_statistics","title":"<code>get_series_id_statistics(id_)</code>  <code>async</code>","text":"<p>(async) Get series statistics</p> <p>Get statistics about the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get series statistics\n\n    Get statistics about the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_series_id_study","title":"<code>get_series_id_study(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get parent study</p> <p>Get detailed information about the parent study of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM study</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_series_id_study(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get parent study\n\n    Get detailed information about the parent study of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM study\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/series/{id_}/study\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_statistics","title":"<code>get_statistics()</code>  <code>async</code>","text":"<p>(async) Get database statistics</p> <p>Get statistics related to the database of Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_statistics(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get database statistics\n\n    Get statistics related to the database of Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/statistics\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_storage_commitment_id","title":"<code>get_storage_commitment_id(id_)</code>  <code>async</code>","text":"<p>(async) Get storage commitment report</p> <p>Get the storage commitment report whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the storage commitment report</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_storage_commitment_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get storage commitment report\n\n    Get the storage commitment report whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the storage commitment report\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/storage-commitment/{id_}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies","title":"<code>get_studies(params=None)</code>  <code>async</code>","text":"<p>(async) List the available studies</p> <p>List the Orthanc identifiers of all the available DICOM studies Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported studies (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List the available studies\n\n    List the Orthanc identifiers of all the available DICOM studies\n    Tags: Studies\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported studies (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id","title":"<code>get_studies_id(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get information about some study</p> <p>Get detailed information about the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM study</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get information about some study\n\n    Get detailed information about the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM study\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_archive","title":"<code>get_studies_id_archive(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Synchronously create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_archive(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Synchronously create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments","title":"<code>get_studies_id_attachments(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List attachments</p> <p>Get the list of attachments that are associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List attachments\n\n    Get the list of attachments that are associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name","title":"<code>get_studies_id_attachments_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given study Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given study\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_compressed_data","title":"<code>get_studies_id_attachments_name_compressed_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given study. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given study. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_compressed_md5","title":"<code>get_studies_id_attachments_name_compressed_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given study, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given study, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_compressed_size","title":"<code>get_studies_id_attachments_name_compressed_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given study, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment on disk\n\n    Get the size of one attachment associated with the given study, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_data","title":"<code>get_studies_id_attachments_name_data(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get attachment</p> <p>Get the (binary) content of one attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get attachment\n\n    Get the (binary) content of one attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_info","title":"<code>get_studies_id_attachments_name_info(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get info about the attachment</p> <p>Get all the information about the attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get info about the attachment\n\n    Get all the information about the attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_is_compressed","title":"<code>get_studies_id_attachments_name_is_compressed(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_md5","title":"<code>get_studies_id_attachments_name_md5(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_attachments_name_size","title":"<code>get_studies_id_attachments_name_size(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get size of attachment</p> <p>Get the size of one attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get size of attachment\n\n    Get the size of one attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_instances","title":"<code>get_studies_id_instances(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get child instances</p> <p>Get detailed information about the child instances of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child instances     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM instances</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_instances(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get child instances\n\n    Get detailed information about the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child instances\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM instances\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_instances_tags","title":"<code>get_studies_id_instances_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get tags of instances</p> <p>Get the tags of all the child instances of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_instances_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get tags of instances\n\n    Get the tags of all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/instances-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_labels","title":"<code>get_studies_id_labels(id_)</code>  <code>async</code>","text":"<p>(async) List labels</p> <p>Get the labels that are associated with the given study (new in Orthanc 1.12.0) Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List labels\n\n    Get the labels that are associated with the given study (new in Orthanc 1.12.0)\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_labels_label","title":"<code>get_studies_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Test label</p> <p>Test whether the study is associated with the given label Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Test label\n\n    Test whether the study is associated with the given label\n    Tags: Studies\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_media","title":"<code>get_studies_id_media(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Synchronously create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"extended\" (str): If present, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_media(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Synchronously create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_metadata","title":"<code>get_studies_id_metadata(id_, params=None)</code>  <code>async</code>","text":"<p>(async) List metadata</p> <p>Get the list of metadata that are associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List metadata\n\n    Get the list of metadata that are associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_metadata_name","title":"<code>get_studies_id_metadata_name(id_, name, headers=None)</code>  <code>async</code>","text":"<p>(async) Get metadata</p> <p>Get the value of a metadata that is associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get metadata\n\n    Get the value of a metadata that is associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_module","title":"<code>get_studies_id_module(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get study module</p> <p>Get the study module of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM study</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get study module\n\n    Get the study module of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM study\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_module_patient","title":"<code>get_studies_id_module_patient(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get patient module of study</p> <p>Get the patient module of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM study</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_module_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get patient module of study\n\n    Get the patient module of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM study\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/module-patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_patient","title":"<code>get_studies_id_patient(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get parent patient</p> <p>Get detailed information about the parent patient of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM patient</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get parent patient\n\n    Get detailed information about the parent patient of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM patient\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_series","title":"<code>get_studies_id_series(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get child series</p> <p>Get detailed information about the child series of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child series     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM series</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_series(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get child series\n\n    Get detailed information about the child series of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child series\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM series\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_shared_tags","title":"<code>get_studies_id_shared_tags(id_, params=None)</code>  <code>async</code>","text":"<p>(async) Get shared tags</p> <p>Extract the DICOM tags whose value is constant across all the child instances of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the values of the DICOM tags</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_shared_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get shared tags\n\n    Extract the DICOM tags whose value is constant across all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the values of the DICOM tags\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/shared-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_studies_id_statistics","title":"<code>get_studies_id_statistics(id_)</code>  <code>async</code>","text":"<p>(async) Get study statistics</p> <p>Get statistics about the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_studies_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get study statistics\n\n    Get statistics about the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/studies/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_system","title":"<code>get_system()</code>  <code>async</code>","text":"<p>(async) Get system information</p> <p>Get system information about Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_system(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get system information\n\n    Get system information about Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/system\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools","title":"<code>get_tools()</code>  <code>async</code>","text":"<p>(async) List operations</p> <p>List the available operations under URI <code>/tools/</code> Tags: Other</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) List operations\n\n    List the available operations under URI `/tools/`\n    Tags: Other\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_accepted_sop_classes","title":"<code>get_tools_accepted_sop_classes()</code>  <code>async</code>","text":"<p>(async) Get accepted SOPClassUID</p> <p>Get the list of SOP Class UIDs that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options <code>AcceptedSopClasses</code> and <code>RejectedSopClasses</code>. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the SOP Class UIDs</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_accepted_sop_classes(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get accepted SOPClassUID\n\n    Get the list of SOP Class UIDs that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedSopClasses` and `RejectedSopClasses`.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the SOP Class UIDs\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/accepted-sop-classes\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_accepted_transfer_syntaxes","title":"<code>get_tools_accepted_transfer_syntaxes()</code>  <code>async</code>","text":"<p>(async) Get accepted transfer syntaxes</p> <p>Get the list of UIDs of the DICOM transfer syntaxes that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options <code>AcceptedTransferSyntaxes</code> and <code>XXXTransferSyntaxAccepted</code>. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the transfer syntax UIDs</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_accepted_transfer_syntaxes(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get accepted transfer syntaxes\n\n    Get the list of UIDs of the DICOM transfer syntaxes that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedTransferSyntaxes` and `XXXTransferSyntaxAccepted`.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the transfer syntax UIDs\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_create_archive","title":"<code>get_tools_create_archive(params=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the ZIP archive.     \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_create_archive(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the ZIP archive.\n            \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/create-archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_create_media","title":"<code>get_tools_create_media(params=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.     \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_create_media(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n            \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/create-media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_create_media_extended","title":"<code>get_tools_create_media_extended(params=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.     \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_create_media_extended(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n            \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/create-media-extended\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_default_encoding","title":"<code>get_tools_default_encoding()</code>  <code>async</code>","text":"<p>(async) Get default encoding</p> <p>Get the default encoding that is used by Orthanc if parsing a DICOM instance without the <code>SpecificCharacterEncoding</code> tag, or during C-FIND. This corresponds to the configuration option <code>DefaultEncoding</code>. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The name of the encoding</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_default_encoding(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get default encoding\n\n    Get the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The name of the encoding\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/default-encoding\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_dicom_conformance","title":"<code>get_tools_dicom_conformance()</code>  <code>async</code>","text":"<p>(async) Get DICOM conformance</p> <p>Get the DICOM conformance statement of Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The DICOM conformance statement</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_dicom_conformance(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get DICOM conformance\n\n    Get the DICOM conformance statement of Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The DICOM conformance statement\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/dicom-conformance\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_generate_uid","title":"<code>get_tools_generate_uid(params=None)</code>  <code>async</code>","text":"<p>(async) Generate an identifier</p> <p>Generate a random DICOM identifier Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"level\" (str): Type of DICOM resource among: <code>patient</code>, <code>study</code>, <code>series</code> or <code>instance</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The generated identifier</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_generate_uid(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Generate an identifier\n\n    Generate a random DICOM identifier\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"level\" (str): Type of DICOM resource among: `patient`, `study`, `series` or `instance`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The generated identifier\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/generate-uid_\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_labels","title":"<code>get_tools_labels()</code>  <code>async</code>","text":"<p>(async) Get all the used labels</p> <p>List all the labels that are associated with any resource of the Orthanc database Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the labels</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_labels(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get all the used labels\n\n    List all the labels that are associated with any resource of the Orthanc database\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the labels\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/labels\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level","title":"<code>get_tools_log_level()</code>  <code>async</code>","text":"<p>(async) Get main log level</p> <p>Get the main log level of Orthanc Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get main log level\n\n    Get the main log level of Orthanc\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level_dicom","title":"<code>get_tools_log_level_dicom()</code>  <code>async</code>","text":"<p>(async) Get log level for <code>dicom</code></p> <p>Get the log level of the log category <code>dicom</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level_dicom(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get log level for `dicom`\n\n    Get the log level of the log category `dicom`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level-dicom\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level_generic","title":"<code>get_tools_log_level_generic()</code>  <code>async</code>","text":"<p>(async) Get log level for <code>generic</code></p> <p>Get the log level of the log category <code>generic</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level_generic(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get log level for `generic`\n\n    Get the log level of the log category `generic`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level-generic\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level_http","title":"<code>get_tools_log_level_http()</code>  <code>async</code>","text":"<p>(async) Get log level for <code>http</code></p> <p>Get the log level of the log category <code>http</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level_http(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get log level for `http`\n\n    Get the log level of the log category `http`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level-http\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level_jobs","title":"<code>get_tools_log_level_jobs()</code>  <code>async</code>","text":"<p>(async) Get log level for <code>jobs</code></p> <p>Get the log level of the log category <code>jobs</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level_jobs(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get log level for `jobs`\n\n    Get the log level of the log category `jobs`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level-jobs\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level_lua","title":"<code>get_tools_log_level_lua()</code>  <code>async</code>","text":"<p>(async) Get log level for <code>lua</code></p> <p>Get the log level of the log category <code>lua</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level_lua(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get log level for `lua`\n\n    Get the log level of the log category `lua`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level-lua\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level_plugins","title":"<code>get_tools_log_level_plugins()</code>  <code>async</code>","text":"<p>(async) Get log level for <code>plugins</code></p> <p>Get the log level of the log category <code>plugins</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level_plugins(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get log level for `plugins`\n\n    Get the log level of the log category `plugins`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level-plugins\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_log_level_sqlite","title":"<code>get_tools_log_level_sqlite()</code>  <code>async</code>","text":"<p>(async) Get log level for <code>sqlite</code></p> <p>Get the log level of the log category <code>sqlite</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_log_level_sqlite(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get log level for `sqlite`\n\n    Get the log level of the log category `sqlite`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/log-level-sqlite\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_metrics","title":"<code>get_tools_metrics()</code>  <code>async</code>","text":"<p>(async) Are metrics collected?</p> <p>Returns a Boolean specifying whether Prometheus metrics are collected and exposed at <code>/tools/metrics-prometheus</code> Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>1</code> if metrics are collected, <code>0</code> if metrics are disabled</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_metrics(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Are metrics collected?\n\n    Returns a Boolean specifying whether Prometheus metrics are collected and exposed at `/tools/metrics-prometheus`\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `1` if metrics are collected, `0` if metrics are disabled\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/metrics\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_metrics_prometheus","title":"<code>get_tools_metrics_prometheus()</code>  <code>async</code>","text":"<p>(async) Get usage metrics</p> <p>Get usage metrics of Orthanc in the Prometheus file format (OpenMetrics): https://orthanc.uclouvain.be/book/users/advanced-rest.html#instrumentation-with-prometheus Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>No description</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_metrics_prometheus(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get usage metrics\n\n    Get usage metrics of Orthanc in the Prometheus file format (OpenMetrics): https://orthanc.uclouvain.be/book/users/advanced-rest.html#instrumentation-with-prometheus\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        No description\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/metrics-prometheus\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_now","title":"<code>get_tools_now()</code>  <code>async</code>","text":"<p>(async) Get UTC time</p> <p>Get UTC time Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The UTC time</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_now(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get UTC time\n\n    Get UTC time\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The UTC time\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/now\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_now_local","title":"<code>get_tools_now_local()</code>  <code>async</code>","text":"<p>(async) Get local time</p> <p>Get local time Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The local time</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_now_local(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Get local time\n\n    Get local time\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The local time\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/now-local\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.get_tools_unknown_sop_class_accepted","title":"<code>get_tools_unknown_sop_class_accepted()</code>  <code>async</code>","text":"<p>(async) Is unknown SOP class accepted?</p> <p>Shall Orthanc C-STORE SCP accept DICOM instances with an unknown SOP class UID? Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>1</code> if accepted, <code>0</code> if not accepted</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def get_tools_unknown_sop_class_accepted(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Is unknown SOP class accepted?\n\n    Shall Orthanc C-STORE SCP accept DICOM instances with an unknown SOP class UID?\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `1` if accepted, `0` if not accepted\n    \"\"\"\n    return await self._get(\n        route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances","title":"<code>post_instances(content=None)</code>  <code>async</code>","text":"<p>(async) Upload DICOM instances</p> <p>Upload DICOM instances Tags: Instances</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the uploaded instance, or list of information for each uploaded instance in the case of ZIP archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances(\n    self,\n    content: RequestContent = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Upload DICOM instances\n\n    Upload DICOM instances\n    Tags: Instances\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the uploaded instance, or list of information for each uploaded instance in the case of ZIP archive\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/instances\",\n        content=content,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances_id_anonymize","title":"<code>post_instances_id_anonymize(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Anonymize instance</p> <p>Download an anonymized version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-a-single-instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The anonymized DICOM instance</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Anonymize instance\n\n    Download an anonymized version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-a-single-instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    json\n        Dictionary with the following keys:\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The anonymized DICOM instance\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/instances/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances_id_attachments_name_compress","title":"<code>post_instances_id_attachments_name_compress(id_, name)</code>  <code>async</code>","text":"<p>(async) Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances_id_attachments_name_uncompress","title":"<code>post_instances_id_attachments_name_uncompress(id_, name)</code>  <code>async</code>","text":"<p>(async) Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances_id_attachments_name_verify_md5","title":"<code>post_instances_id_attachments_name_verify_md5(id_, name)</code>  <code>async</code>","text":"<p>(async) Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances_id_export","title":"<code>post_instances_id_export(id_, data=None)</code>  <code>async</code>","text":"<p>(async) Write DICOM onto filesystem</p> <p>Write the DICOM file onto the filesystem where Orthanc is running.  This is insecure for Orthanc servers that are remotely accessible since one could overwrite any system file.  Since Orthanc 1.12.0, this route is disabled by default, but can be enabled using the <code>RestApiWriteToFileSystemEnabled</code> configuration option. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>data</code> <code>RequestData</code> <p>Target path on the filesystem</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances_id_export(\n    self,\n    id_: str,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Write DICOM onto filesystem\n\n    Write the DICOM file onto the filesystem where Orthanc is running.  This is insecure for Orthanc servers that are remotely accessible since one could overwrite any system file.  Since Orthanc 1.12.0, this route is disabled by default, but can be enabled using the `RestApiWriteToFileSystemEnabled` configuration option.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    data\n        Target path on the filesystem\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/instances/{id_}/export\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances_id_modify","title":"<code>post_instances_id_modify(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Modify instance</p> <p>Download a modified version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-a-single-instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The modified DICOM instance</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Modify instance\n\n    Download a modified version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-a-single-instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    json\n        Dictionary with the following keys:\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The modified DICOM instance\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/instances/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_instances_id_reconstruct","title":"<code>post_instances_id_reconstruct(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Reconstruct tags &amp; optionally files of instance</p> <p>Reconstruct the main DICOM tags in DB of the instance whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_instances_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Reconstruct tags &amp; optionally files of instance\n\n    Reconstruct the main DICOM tags in DB of the instance whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/instances/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_jobs_id_cancel","title":"<code>post_jobs_id_cancel(id_)</code>  <code>async</code>","text":"<p>(async) Cancel job</p> <p>Cancel the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_jobs_id_cancel(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Cancel job\n\n    Cancel the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/jobs/{id_}/cancel\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_jobs_id_pause","title":"<code>post_jobs_id_pause(id_)</code>  <code>async</code>","text":"<p>(async) Pause job</p> <p>Pause the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_jobs_id_pause(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Pause job\n\n    Pause the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/jobs/{id_}/pause\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_jobs_id_resubmit","title":"<code>post_jobs_id_resubmit(id_)</code>  <code>async</code>","text":"<p>(async) Resubmit job</p> <p>Resubmit the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_jobs_id_resubmit(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Resubmit job\n\n    Resubmit the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/jobs/{id_}/resubmit\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_jobs_id_resume","title":"<code>post_jobs_id_resume(id_)</code>  <code>async</code>","text":"<p>(async) Resume job</p> <p>Resume the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_jobs_id_resume(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Resume job\n\n    Resume the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/jobs/{id_}/resume\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_echo","title":"<code>post_modalities_id_echo(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Trigger C-ECHO SCU</p> <p>Trigger C-ECHO SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-echo Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the <code>DicomEchoChecksFind</code> configuration option. New in Orthanc 1.8.1.   \"Timeout\": Timeout for the C-ECHO command, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_echo(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Trigger C-ECHO SCU\n\n    Trigger C-ECHO SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-echo\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n          \"Timeout\": Timeout for the C-ECHO command, in seconds\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/echo\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_find","title":"<code>post_modalities_id_find(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Hierarchical C-FIND SCU</p> <p>Trigger a sequence of C-FIND SCU commands against the DICOM modality whose identifier is provided in URL, in order to discover a hierarchy of matching patients/studies/series. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching patients, embedding the matching studies, then the matching series.</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_find(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Hierarchical C-FIND SCU\n\n    Trigger a sequence of C-FIND SCU commands against the DICOM modality whose identifier is provided in URL, in order to discover a hierarchy of matching patients/studies/series. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching patients, embedding the matching studies, then the matching series.\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/find\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_find_instance","title":"<code>post_modalities_id_find_instance(id_, json=None)</code>  <code>async</code>","text":"<p>(async) C-FIND SCU for instances</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find an instance. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching instances</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_find_instance(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) C-FIND SCU for instances\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find an instance. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching instances\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/find-instance\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_find_patient","title":"<code>post_modalities_id_find_patient(id_, json=None)</code>  <code>async</code>","text":"<p>(async) C-FIND SCU for patients</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a patient. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching patients</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_find_patient(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) C-FIND SCU for patients\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a patient. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching patients\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/find-patient\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_find_series","title":"<code>post_modalities_id_find_series(id_, json=None)</code>  <code>async</code>","text":"<p>(async) C-FIND SCU for series</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a series. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching series</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_find_series(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) C-FIND SCU for series\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a series. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching series\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/find-series\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_find_study","title":"<code>post_modalities_id_find_study(id_, json=None)</code>  <code>async</code>","text":"<p>(async) C-FIND SCU for studies</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a study. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching studies</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_find_study(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) C-FIND SCU for studies\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a study. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching studies\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/find-study\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_find_worklist","title":"<code>post_modalities_id_find_worklist(id_, json=None)</code>  <code>async</code>","text":"<p>(async) C-FIND SCU for worklist</p> <p>Trigger C-FIND SCU command against the remote worklists of the DICOM modality whose identifier is provided in URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching worklists</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_find_worklist(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) C-FIND SCU for worklist\n\n    Trigger C-FIND SCU command against the remote worklists of the DICOM modality whose identifier is provided in URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching worklists\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/find-worklist\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_get","title":"<code>post_modalities_id_get(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Trigger C-GET SCU</p> <p>Start a C-GET SCU command as a job, in order to retrieve DICOM resources from a remote DICOM modality whose identifier is provided in the URL: Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of queries identifying all the DICOM resources to be sent.  Usage of wildcards is prohibited and the query shall only contain DICOM ID tags.  Additionally, you may provide SOPClassesInStudy to limit the scope of the DICOM negotiation to certain SOPClassUID or to present uncommon SOPClassUID during the DICOM negotation.  By default, Orhanc will propose the most 120 common SOPClassUIDs.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Timeout\": Timeout for the C-GET command, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_get(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Trigger C-GET SCU\n\n    Start a C-GET SCU command as a job, in order to retrieve DICOM resources from a remote DICOM modality whose identifier is provided in the URL:\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of queries identifying all the DICOM resources to be sent.  Usage of wildcards is prohibited and the query shall only contain DICOM ID tags.  Additionally, you may provide SOPClassesInStudy to limit the scope of the DICOM negotiation to certain SOPClassUID or to present uncommon SOPClassUID during the DICOM negotation.  By default, Orhanc will propose the most 120 common SOPClassUIDs.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Timeout\": Timeout for the C-GET command, in seconds\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/get\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_move","title":"<code>post_modalities_id_move(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Trigger C-MOVE SCU</p> <p>Start a C-MOVE SCU command as a job, in order to drive the execution of a sequence of C-STORE commands by some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-move Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of queries identifying all the DICOM resources to be sent   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"TargetAet\": Target AET that will be used by the remote DICOM modality as a target for its C-STORE SCU commands, defaults to <code>DicomAet</code> configuration option in order to do a simple query/retrieve   \"Timeout\": Timeout for the C-MOVE command, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_move(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Trigger C-MOVE SCU\n\n    Start a C-MOVE SCU command as a job, in order to drive the execution of a sequence of C-STORE commands by some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-move\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of queries identifying all the DICOM resources to be sent\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"TargetAet\": Target AET that will be used by the remote DICOM modality as a target for its C-STORE SCU commands, defaults to `DicomAet` configuration option in order to do a simple query/retrieve\n          \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/move\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_query","title":"<code>post_modalities_id_query(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Trigger C-FIND SCU</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"Normalize\": Whether to normalize the query, i.e. whether to wipe out from the query, the DICOM tags that are not applicable for the query-retrieve level of interest   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command and subsequent C-MOVE retrievals, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_query(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Trigger C-FIND SCU\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"Normalize\": Whether to normalize the query, i.e. whether to wipe out from the query, the DICOM tags that are not applicable for the query-retrieve level of interest\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command and subsequent C-MOVE retrievals, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/query\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_storage_commitment","title":"<code>post_modalities_id_storage_commitment(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Trigger storage commitment request</p> <p>Trigger a storage commitment request to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"DicomInstances\": List of DICOM resources that are not necessarily stored within Orthanc, but that must be checked by storage commitment. This is a list of JSON objects that must contain the <code>SOPClassUID</code> and <code>SOPInstanceUID</code> fields.   \"Resources\": List of the Orthanc identifiers of the DICOM resources to be checked by storage commitment   \"Timeout\": Timeout for the storage commitment command (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_storage_commitment(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Trigger storage commitment request\n\n    Trigger a storage commitment request to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"DicomInstances\": List of DICOM resources that are not necessarily stored within Orthanc, but that must be checked by storage commitment. This is a list of JSON objects that must contain the `SOPClassUID` and `SOPInstanceUID` fields.\n          \"Resources\": List of the Orthanc identifiers of the DICOM resources to be checked by storage commitment\n          \"Timeout\": Timeout for the storage commitment command (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/storage-commitment\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_store","title":"<code>post_modalities_id_store(id_, data=None, json=None)</code>  <code>async</code>","text":"<p>(async) Trigger C-STORE SCU</p> <p>Start a C-STORE SCU command as a job, in order to send DICOM resources stored locally to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#rest-store-scu Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"CalledAet\": Called AET that is used for this commands, defaults to <code>AET</code> configuration option. Allows you to overwrite the destination AET for a specific operation.   \"Host\": Host that is used for this commands, defaults to <code>Host</code> configuration option. Allows you to overwrite the destination host for a specific operation.   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"MoveOriginatorAet\": Move originator AET that is used for this commands, in order to fake a C-MOVE SCU   \"MoveOriginatorID\": Move originator ID that is used for this commands, in order to fake a C-MOVE SCU   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Port\": Port that is used for this command, defaults to <code>Port</code> configuration option. Allows you to overwrite the destination port for a specific operation.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent   \"StorageCommitment\": Whether to chain C-STORE with DICOM storage commitment to validate the success of the transmission: https://orthanc.uclouvain.be/book/users/storage-commitment.html#chaining-c-store-with-storage-commitment   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Timeout\": Timeout for the C-STORE command, in seconds</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>The Orthanc identifier of one resource to be sent</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_store(\n    self,\n    id_: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Trigger C-STORE SCU\n\n    Start a C-STORE SCU command as a job, in order to send DICOM resources stored locally to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#rest-store-scu\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"CalledAet\": Called AET that is used for this commands, defaults to `AET` configuration option. Allows you to overwrite the destination AET for a specific operation.\n          \"Host\": Host that is used for this commands, defaults to `Host` configuration option. Allows you to overwrite the destination host for a specific operation.\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"MoveOriginatorAet\": Move originator AET that is used for this commands, in order to fake a C-MOVE SCU\n          \"MoveOriginatorID\": Move originator ID that is used for this commands, in order to fake a C-MOVE SCU\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Port\": Port that is used for this command, defaults to `Port` configuration option. Allows you to overwrite the destination port for a specific operation.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n          \"StorageCommitment\": Whether to chain C-STORE with DICOM storage commitment to validate the success of the transmission: https://orthanc.uclouvain.be/book/users/storage-commitment.html#chaining-c-store-with-storage-commitment\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Timeout\": Timeout for the C-STORE command, in seconds\n\n    data\n        The Orthanc identifier of one resource to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/store\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_modalities_id_store_straight","title":"<code>post_modalities_id_store_straight(id_, content=None)</code>  <code>async</code>","text":"<p>(async) Straight C-STORE SCU</p> <p>Synchronously send the DICOM instance in the POST body to the remote DICOM modality whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as <code>storescu</code> from DCMTK or dcm4che. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/dicom\") DICOM instance to be sent\n</code></pre> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_modalities_id_store_straight(\n    self,\n    id_: str,\n    content: RequestContent = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Straight C-STORE SCU\n\n    Synchronously send the DICOM instance in the POST body to the remote DICOM modality whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `storescu` from DCMTK or dcm4che.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    content\n            - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/modalities/{id_}/store-straight\",\n        content=content,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_anonymize","title":"<code>post_patients_id_anonymize(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Anonymize patient</p> <p>Start a job that will anonymize all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Anonymize patient\n\n    Start a job that will anonymize all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_archive","title":"<code>post_patients_id_archive(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_archive(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_attachments_name_compress","title":"<code>post_patients_id_attachments_name_compress(id_, name)</code>  <code>async</code>","text":"<p>(async) Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_attachments_name_uncompress","title":"<code>post_patients_id_attachments_name_uncompress(id_, name)</code>  <code>async</code>","text":"<p>(async) Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_attachments_name_verify_md5","title":"<code>post_patients_id_attachments_name_verify_md5(id_, name)</code>  <code>async</code>","text":"<p>(async) Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_media","title":"<code>post_patients_id_media(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_media(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_modify","title":"<code>post_patients_id_modify(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Modify patient</p> <p>Start a job that will modify all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Modify patient\n\n    Start a job that will modify all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_patients_id_reconstruct","title":"<code>post_patients_id_reconstruct(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Reconstruct tags &amp; optionally files of patient</p> <p>Reconstruct the main DICOM tags in DB of the patient whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_patients_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Reconstruct tags &amp; optionally files of patient\n\n    Reconstruct the main DICOM tags in DB of the patient whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/patients/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_peers_id_store","title":"<code>post_peers_id_store(id_, data=None, json=None)</code>  <code>async</code>","text":"<p>(async) Send to Orthanc peer</p> <p>Send DICOM resources stored locally to some remote Orthanc peer whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#sending-one-resource Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Compress\": Whether to compress the DICOM instances using gzip before the actual sending   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode to the provided DICOM transfer syntax before the actual sending</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>The Orthanc identifier of one resource to be sent</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_peers_id_store(\n    self,\n    id_: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Send to Orthanc peer\n\n    Send DICOM resources stored locally to some remote Orthanc peer whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#sending-one-resource\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Compress\": Whether to compress the DICOM instances using gzip before the actual sending\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode to the provided DICOM transfer syntax before the actual sending\n\n    data\n        The Orthanc identifier of one resource to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/peers/{id_}/store\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_peers_id_store_straight","title":"<code>post_peers_id_store_straight(id_, content=None)</code>  <code>async</code>","text":"<p>(async) Straight store to peer</p> <p>Synchronously send the DICOM instance in the POST body to the Orthanc peer whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as <code>curl</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/dicom\") DICOM instance to be sent\n</code></pre> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_peers_id_store_straight(\n    self,\n    id_: str,\n    content: RequestContent = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Straight store to peer\n\n    Synchronously send the DICOM instance in the POST body to the Orthanc peer whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `curl`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    content\n            - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/peers/{id_}/store-straight\",\n        content=content,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_queries_id_answers_index_query_instances","title":"<code>post_queries_id_answers_index_query_instances(id_, index, json=None)</code>  <code>async</code>","text":"<p>(async) Query the child instances of an answer</p> <p>Issue a second DICOM C-FIND operation, in order to query the child instances associated with one answer to some query/retrieve operation whose identifiers are provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_queries_id_answers_index_query_instances(\n    self,\n    id_: str,\n    index: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Query the child instances of an answer\n\n    Issue a second DICOM C-FIND operation, in order to query the child instances associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/query-instances\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_queries_id_answers_index_query_series","title":"<code>post_queries_id_answers_index_query_series(id_, index, json=None)</code>  <code>async</code>","text":"<p>(async) Query the child series of an answer</p> <p>Issue a second DICOM C-FIND operation, in order to query the child series associated with one answer to some query/retrieve operation whose identifiers are provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_queries_id_answers_index_query_series(\n    self,\n    id_: str,\n    index: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Query the child series of an answer\n\n    Issue a second DICOM C-FIND operation, in order to query the child series associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/query-series\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_queries_id_answers_index_query_studies","title":"<code>post_queries_id_answers_index_query_studies(id_, index, json=None)</code>  <code>async</code>","text":"<p>(async) Query the child studies of an answer</p> <p>Issue a second DICOM C-FIND operation, in order to query the child studies associated with one answer to some query/retrieve operation whose identifiers are provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_queries_id_answers_index_query_studies(\n    self,\n    id_: str,\n    index: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Query the child studies of an answer\n\n    Issue a second DICOM C-FIND operation, in order to query the child studies associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/query-studies\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_queries_id_answers_index_retrieve","title":"<code>post_queries_id_answers_index_retrieve(id_, index, data=None, json=None)</code>  <code>async</code>","text":"<p>(async) Retrieve one answer with a C-MOVE or a C-GET SCU</p> <p>Start a C-MOVE or a C-GET SCU command as a job, in order to retrieve one answer associated with the query/retrieve operation whose identifiers are provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod   \"Simplify\": If set to <code>true</code>, report the DICOM tags in human-readable format (using the symbolic name of the tags)   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the <code>DicomAet</code> configuration option.   \"Timeout\": Timeout for the C-MOVE command, in seconds</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>AET of the target modality</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_queries_id_answers_index_retrieve(\n    self,\n    id_: str,\n    index: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Retrieve one answer with a C-MOVE or a C-GET SCU\n\n    Start a C-MOVE or a C-GET SCU command as a job, in order to retrieve one answer associated with the query/retrieve operation whose identifiers are provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n          \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n          \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n    data\n        AET of the target modality\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/retrieve\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_queries_id_retrieve","title":"<code>post_queries_id_retrieve(id_, data=None, json=None)</code>  <code>async</code>","text":"<p>(async) Retrieve all answers with C-MOVE SCU</p> <p>Start a C-MOVE SCU command as a job, in order to retrieve all the answers associated with the query/retrieve operation whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod   \"Simplify\": If set to <code>true</code>, report the DICOM tags in human-readable format (using the symbolic name of the tags)   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the <code>DicomAet</code> configuration option.   \"Timeout\": Timeout for the C-MOVE command, in seconds</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>AET of the target modality</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_queries_id_retrieve(\n    self,\n    id_: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Retrieve all answers with C-MOVE SCU\n\n    Start a C-MOVE SCU command as a job, in order to retrieve all the answers associated with the query/retrieve operation whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n          \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n          \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n    data\n        AET of the target modality\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/queries/{id_}/retrieve\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_anonymize","title":"<code>post_series_id_anonymize(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Anonymize series</p> <p>Start a job that will anonymize all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Anonymize series\n\n    Start a job that will anonymize all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_archive","title":"<code>post_series_id_archive(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_archive(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_attachments_name_compress","title":"<code>post_series_id_attachments_name_compress(id_, name)</code>  <code>async</code>","text":"<p>(async) Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_attachments_name_uncompress","title":"<code>post_series_id_attachments_name_uncompress(id_, name)</code>  <code>async</code>","text":"<p>(async) Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_attachments_name_verify_md5","title":"<code>post_series_id_attachments_name_verify_md5(id_, name)</code>  <code>async</code>","text":"<p>(async) Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_media","title":"<code>post_series_id_media(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_media(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_modify","title":"<code>post_series_id_modify(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Modify series</p> <p>Start a job that will modify all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Modify series\n\n    Start a job that will modify all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_series_id_reconstruct","title":"<code>post_series_id_reconstruct(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Reconstruct tags &amp; optionally files of series</p> <p>Reconstruct the main DICOM tags in DB of the series whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_series_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Reconstruct tags &amp; optionally files of series\n\n    Reconstruct the main DICOM tags in DB of the series whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/series/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_storage_commitment_id_remove","title":"<code>post_storage_commitment_id_remove(id_)</code>  <code>async</code>","text":"<p>(async) Remove after storage commitment</p> <p>Remove out of Orthanc, the DICOM instances that have been reported to have been properly received the storage commitment report whose identifier is provided in the URL. This is only possible if the <code>Status</code> of the storage commitment report is <code>Success</code>. https://orthanc.uclouvain.be/book/users/storage-commitment.html#removing-the-instances Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the storage commitment report</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_storage_commitment_id_remove(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Remove after storage commitment\n\n    Remove out of Orthanc, the DICOM instances that have been reported to have been properly received the storage commitment report whose identifier is provided in the URL. This is only possible if the `Status` of the storage commitment report is `Success`. https://orthanc.uclouvain.be/book/users/storage-commitment.html#removing-the-instances\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the storage commitment report\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/storage-commitment/{id_}/remove\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_anonymize","title":"<code>post_studies_id_anonymize(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Anonymize study</p> <p>Start a job that will anonymize all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Anonymize study\n\n    Start a job that will anonymize all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_archive","title":"<code>post_studies_id_archive(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_archive(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_attachments_name_compress","title":"<code>post_studies_id_attachments_name_compress(id_, name)</code>  <code>async</code>","text":"<p>(async) Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_attachments_name_uncompress","title":"<code>post_studies_id_attachments_name_uncompress(id_, name)</code>  <code>async</code>","text":"<p>(async) Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_attachments_name_verify_md5","title":"<code>post_studies_id_attachments_name_verify_md5(id_, name)</code>  <code>async</code>","text":"<p>(async) Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_media","title":"<code>post_studies_id_media(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_media(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_merge","title":"<code>post_studies_id_merge(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Merge study</p> <p>Start a new job so as to move some DICOM resources into the DICOM study whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#merging Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"KeepSource\": If set to <code>true</code>, instructs Orthanc to keep a copy of the original resources in their source study. By default, the original resources are deleted from Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of DICOM resources (studies, series, and/or instances) to be merged into the study of interest (mandatory option)   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_merge(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Merge study\n\n    Start a new job so as to move some DICOM resources into the DICOM study whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#merging\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original resources in their source study. By default, the original resources are deleted from Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of DICOM resources (studies, series, and/or instances) to be merged into the study of interest (mandatory option)\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/merge\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_modify","title":"<code>post_studies_id_modify(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Modify study</p> <p>Start a job that will modify all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Modify study\n\n    Start a job that will modify all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_reconstruct","title":"<code>post_studies_id_reconstruct(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Reconstruct tags &amp; optionally files of study</p> <p>Reconstruct the main DICOM tags in DB of the study whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Reconstruct tags &amp; optionally files of study\n\n    Reconstruct the main DICOM tags in DB of the study whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_studies_id_split","title":"<code>post_studies_id_split(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Split study</p> <p>Start a new job so as to split the DICOM study whose Orthanc identifier is provided in the URL, by taking some of its children series or instances out of it and putting them into a brand new study (this new study is created by setting the <code>StudyInstanceUID</code> tag to a random identifier): https://orthanc.uclouvain.be/book/users/anonymization.html#splitting Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Instances\": The list of instances to be separated from the parent study. These instances must all be children of the same source study, that is specified in the URI.   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepSource\": If set to <code>true</code>, instructs Orthanc to keep a copy of the original series/instances in the source study. By default, the original series/instances are deleted from Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Remove\": List of tags that must be removed in the new study (from the same modules as in the <code>Replace</code> option)   \"Replace\": Associative array to change the value of some DICOM tags in the new study. These tags must be part of the \"Patient Module Attributes\" or the \"General Study Module Attributes\", as specified by the DICOM 2011 standard in Tables C.7-1 and C.7-3.   \"Series\": The list of series to be separated from the parent study. These series must all be children of the same source study, that is specified in the URI.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_studies_id_split(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Split study\n\n    Start a new job so as to split the DICOM study whose Orthanc identifier is provided in the URL, by taking some of its children series or instances out of it and putting them into a brand new study (this new study is created by setting the `StudyInstanceUID` tag to a random identifier): https://orthanc.uclouvain.be/book/users/anonymization.html#splitting\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Instances\": The list of instances to be separated from the parent study. These instances must all be children of the same source study, that is specified in the URI.\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original series/instances in the source study. By default, the original series/instances are deleted from Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Remove\": List of tags that must be removed in the new study (from the same modules as in the `Replace` option)\n          \"Replace\": Associative array to change the value of some DICOM tags in the new study. These tags must be part of the \"Patient Module Attributes\" or the \"General Study Module Attributes\", as specified by the DICOM 2011 standard in Tables C.7-1 and C.7-3.\n          \"Series\": The list of series to be separated from the parent study. These series must all be children of the same source study, that is specified in the URI.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/studies/{id_}/split\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_bulk_anonymize","title":"<code>post_tools_bulk_anonymize(json=None)</code>  <code>async</code>","text":"<p>(async) Anonymize a set of resources</p> <p>Start a job that will anonymize all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of all the resources that have been created by this anonymization</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_bulk_anonymize(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Anonymize a set of resources\n\n    Start a job that will anonymize all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of all the resources that have been created by this anonymization\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/bulk-anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_bulk_content","title":"<code>post_tools_bulk_content(json=None)</code>  <code>async</code>","text":"<p>(async) Describe a set of resources</p> <p>Get the content all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field, in one single call. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Level\": This optional argument specifies the level of interest (can be <code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>). Orthanc will loop over the items inside <code>Resources</code>, and explore upward or downward in the DICOM hierarchy in order to find the level of interest.   \"Metadata\": If set to <code>true</code> (default value), the metadata associated with the resources will also be retrieved.   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_bulk_content(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Describe a set of resources\n\n    Get the content all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field, in one single call.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Level\": This optional argument specifies the level of interest (can be `Patient`, `Study`, `Series` or `Instance`). Orthanc will loop over the items inside `Resources`, and explore upward or downward in the DICOM hierarchy in order to find the level of interest.\n          \"Metadata\": If set to `true` (default value), the metadata associated with the resources will also be retrieved.\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/bulk-content\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_bulk_delete","title":"<code>post_tools_bulk_delete(json=None)</code>  <code>async</code>","text":"<p>(async) Delete a set of resources</p> <p>Delete all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_bulk_delete(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Delete a set of resources\n\n    Delete all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/bulk-delete\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_bulk_modify","title":"<code>post_tools_bulk_modify(json=None)</code>  <code>async</code>","text":"<p>(async) Modify a set of resources</p> <p>Start a job that will modify all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Level\": Level of the modification (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>). If absent, the level defaults to <code>Instance</code>, but is set to <code>Patient</code> if <code>PatientID</code> is modified, to <code>Study</code> if <code>StudyInstanceUID</code> is modified, or to <code>Series</code> if <code>SeriesInstancesUID</code> is modified. (new in Orthanc 1.9.7)   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of all the resources that have been altered by this modification</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_bulk_modify(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Modify a set of resources\n\n    Start a job that will modify all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Level\": Level of the modification (`Patient`, `Study`, `Series` or `Instance`). If absent, the level defaults to `Instance`, but is set to `Patient` if `PatientID` is modified, to `Study` if `StudyInstanceUID` is modified, or to `Series` if `SeriesInstancesUID` is modified. (new in Orthanc 1.9.7)\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of all the resources that have been altered by this modification\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/bulk-modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_count_resources","title":"<code>post_tools_count_resources(json=None)</code>  <code>async</code>","text":"<p>(async) Count local resources</p> <p>This URI can be used to count the resources that are matching criteria on the content of the local Orthanc server, in a way that is similar to tools/find Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)   \"LabelsConstraint\": Constraint on the labels, can be <code>All</code>, <code>Any</code>, or <code>None</code> (defaults to <code>All</code>, new in Orthanc 1.12.0)   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)   \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)   \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)   \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>A JSON object with the <code>Count</code> of matching resources</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_count_resources(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Count local resources\n\n    This URI can be used to count the resources that are matching criteria on the content of the local Orthanc server, in a way that is similar to tools/find\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n          \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n          \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n          \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n          \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        A JSON object with the `Count` of matching resources\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/count-resources\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_create_archive","title":"<code>post_tools_create_archive(json=None)</code>  <code>async</code>","text":"<p>(async) Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of Orthanc identifiers of interest.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_create_archive(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create ZIP archive\n\n    Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of Orthanc identifiers of interest.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/create-archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_create_dicom","title":"<code>post_tools_create_dicom(json=None)</code>  <code>async</code>","text":"<p>(async) Create one DICOM instance</p> <p>Create one DICOM instance, and store it into Orthanc Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Content\": This field can be used to embed an image (pixel data encoded as PNG or JPEG), a PDF, or a 3D manufactoring model (MTL/OBJ/STL) inside the created DICOM instance. The file to be encapsulated must be provided using its data URI scheme encoding. This field can possibly contain a JSON array, in which case a DICOM series is created containing one DICOM instance for each item in the <code>Content</code> field.   \"Force\": Avoid the consistency checks for the DICOM tags that enforce the DICOM model of the real-world. You can notably use this flag if you need to manually set the tags <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code>, or <code>SOPInstanceUID</code>. Be careful with this feature.   \"InterpretBinaryTags\": If some value in the <code>Tags</code> associative array is formatted according to some data URI scheme encoding, whether this value is decoded to a binary value or kept as such (<code>true</code> by default)   \"Parent\": If present, the newly created instance will be attached to the parent DICOM resource whose Orthanc identifier is contained in this field. The DICOM tags of the parent modules in the DICOM hierarchy will be automatically copied to the newly created instance.   \"PrivateCreator\": The private creator to be used for private tags in <code>Tags</code>   \"Tags\": Associative array containing the tags of the new instance to be created</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_create_dicom(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create one DICOM instance\n\n    Create one DICOM instance, and store it into Orthanc\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Content\": This field can be used to embed an image (pixel data encoded as PNG or JPEG), a PDF, or a 3D manufactoring model (MTL/OBJ/STL) inside the created DICOM instance. The file to be encapsulated must be provided using its [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme). This field can possibly contain a JSON array, in which case a DICOM series is created containing one DICOM instance for each item in the `Content` field.\n          \"Force\": Avoid the consistency checks for the DICOM tags that enforce the DICOM model of the real-world. You can notably use this flag if you need to manually set the tags `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`. Be careful with this feature.\n          \"InterpretBinaryTags\": If some value in the `Tags` associative array is formatted according to some [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme), whether this value is decoded to a binary value or kept as such (`true` by default)\n          \"Parent\": If present, the newly created instance will be attached to the parent DICOM resource whose Orthanc identifier is contained in this field. The DICOM tags of the parent modules in the DICOM hierarchy will be automatically copied to the newly created instance.\n          \"PrivateCreator\": The private creator to be used for private tags in `Tags`\n          \"Tags\": Associative array containing the tags of the new instance to be created\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/create-dicom\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_create_media","title":"<code>post_tools_create_media(json=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of Orthanc identifiers of interest.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_create_media(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of Orthanc identifiers of interest.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/create-media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_create_media_extended","title":"<code>post_tools_create_media_extended(json=None)</code>  <code>async</code>","text":"<p>(async) Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>true</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of Orthanc identifiers of interest.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_create_media_extended(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `true`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of Orthanc identifiers of interest.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/create-media-extended\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_dicom_echo","title":"<code>post_tools_dicom_echo(json=None)</code>  <code>async</code>","text":"<p>(async) Trigger C-ECHO SCU</p> <p>Trigger C-ECHO SCU command against a DICOM modality described in the POST body, without having to register the modality in some <code>/modalities/{id}</code> (new in Orthanc 1.8.1) Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"AET\": AET of the remote DICOM modality   \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the <code>DicomEchoChecksFind</code> configuration option. New in Orthanc 1.8.1.   \"Host\": Host address of the remote DICOM modality (typically, an IP address)   \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality   \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option <code>DicomModalities</code> for possible values   \"Port\": TCP port of the remote DICOM modality   \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality   \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_dicom_echo(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Trigger C-ECHO SCU\n\n    Trigger C-ECHO SCU command against a DICOM modality described in the POST body, without having to register the modality in some `/modalities/{id}` (new in Orthanc 1.8.1)\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"AET\": AET of the remote DICOM modality\n          \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n          \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n          \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n          \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n          \"Port\": TCP port of the remote DICOM modality\n          \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n          \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/dicom-echo\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_execute_script","title":"<code>post_tools_execute_script(data=None)</code>  <code>async</code>","text":"<p>(async) Execute Lua script</p> <p>Execute the provided Lua script by the Orthanc server. This is very insecure for Orthanc servers that are remotely accessible.  Since Orthanc 1.5.8, this route is disabled by default and can be enabled thanks to the <code>ExecuteLuaEnabled</code> configuration. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>The Lua script to be executed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Output of the Lua script</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_execute_script(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Execute Lua script\n\n    Execute the provided Lua script by the Orthanc server. This is very insecure for Orthanc servers that are remotely accessible.  Since Orthanc 1.5.8, this route is disabled by default and can be enabled thanks to the `ExecuteLuaEnabled` configuration.\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        The Lua script to be executed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Output of the Lua script\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/tools/execute-script\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_find","title":"<code>post_tools_find(json=None)</code>  <code>async</code>","text":"<p>(async) Look for local resources</p> <p>This URI can be used to perform a search on the content of the local Orthanc server, in a way that is similar to querying remote DICOM modalities using C-FIND SCU: https://orthanc.uclouvain.be/book/users/rest.html#performing-finds-within-orthanc Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"CaseSensitive\": Enable case-sensitive search for PN value representations (defaults to configuration option <code>CaseSensitivePN</code>)   \"Expand\": If set to \"true\", retrieve detailed information about the individual resources, not only their Orthanc identifiers   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)   \"LabelsConstraint\": Constraint on the labels, can be <code>All</code>, <code>Any</code>, or <code>None</code> (defaults to <code>All</code>, new in Orthanc 1.12.0)   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"Limit\": Limit the number of reported resources   \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)   \"OrderBy\": Array of associative arrays containing the requested ordering (new in Orthanc 1.12.5)   \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)   \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)   \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"RequestedTags\": A list of DICOM tags to include in the response (applicable only if \"Expand\" is set to true).  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.   \"ResponseContent\": Defines the content of response for each returned resource. (this field, if present, overrides the \"Expand\" field).  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.(new in Orthanc 1.12.5)   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format   \"Since\": Show only the resources since the provided index (in conjunction with <code>Limit</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported resources (if <code>Expand</code> argument is <code>true</code>)</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_find(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Look for local resources\n\n    This URI can be used to perform a search on the content of the local Orthanc server, in a way that is similar to querying remote DICOM modalities using C-FIND SCU: https://orthanc.uclouvain.be/book/users/rest.html#performing-finds-within-orthanc\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"CaseSensitive\": Enable case-sensitive search for PN value representations (defaults to configuration option `CaseSensitivePN`)\n          \"Expand\": If set to \"true\", retrieve detailed information about the individual resources, not only their Orthanc identifiers\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n          \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"Limit\": Limit the number of reported resources\n          \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n          \"OrderBy\": Array of associative arrays containing the requested ordering (new in Orthanc 1.12.5)\n          \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n          \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n          \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"RequestedTags\": A list of DICOM tags to include in the response (applicable only if \"Expand\" is set to true).  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n          \"ResponseContent\": Defines the content of response for each returned resource. (this field, if present, overrides the \"Expand\" field).  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.(new in Orthanc 1.12.5)\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n          \"Since\": Show only the resources since the provided index (in conjunction with `Limit`)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported resources (if `Expand` argument is `true`)\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/find\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_invalid_ate_tags","title":"<code>post_tools_invalid_ate_tags()</code>  <code>async</code>","text":"<p>(async) Invalidate DICOM-as-JSON summaries</p> <p>Remove all the attachments of the type \"DICOM-as-JSON\" that are associated will all the DICOM instances stored in Orthanc. These summaries will be automatically re-created on the next access. This is notably useful after changes to the <code>Dictionary</code> configuration option. https://orthanc.uclouvain.be/book/faq/orthanc-storage.html#storage-area Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_invalid_ate_tags(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Invalidate DICOM-as-JSON summaries\n\n    Remove all the attachments of the type \"DICOM-as-JSON\" that are associated will all the DICOM instances stored in Orthanc. These summaries will be automatically re-created on the next access. This is notably useful after changes to the `Dictionary` configuration option. https://orthanc.uclouvain.be/book/faq/orthanc-storage.html#storage-area\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/tools/invalid_ate-tags\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_lookup","title":"<code>post_tools_lookup(data=None)</code>  <code>async</code>","text":"<p>(async) Look for DICOM identifiers</p> <p>This URI can be used to convert one DICOM identifier to a list of matching Orthanc resources Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>The DICOM identifier of interest (i.e. the value of <code>PatientID</code>, <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code>, or <code>SOPInstanceUID</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing a list of matching Orthanc resources, each item in the list corresponding to a JSON object with the fields <code>Type</code>, <code>ID</code> and <code>Path</code> identifying one DICOM resource that is stored by Orthanc</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_lookup(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Look for DICOM identifiers\n\n    This URI can be used to convert one DICOM identifier to a list of matching Orthanc resources\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        The DICOM identifier of interest (i.e. the value of `PatientID`, `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing a list of matching Orthanc resources, each item in the list corresponding to a JSON object with the fields `Type`, `ID` and `Path` identifying one DICOM resource that is stored by Orthanc\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/tools/lookup\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_reconstruct","title":"<code>post_tools_reconstruct(json=None)</code>  <code>async</code>","text":"<p>(async) Reconstruct all the index</p> <p>Reconstruct the index of all the tags of all the DICOM instances that are stored in Orthanc. This is notably useful after the deletion of resources whose children resources have inconsistent values with their sibling resources. Beware that this is a highly time-consuming operation, as all the DICOM instances will be parsed again, and as all the Orthanc index will be regenerated. If you have a large database to process, it is advised to use the Housekeeper plugin to perform this action resource by resource Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_reconstruct(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Reconstruct all the index\n\n    Reconstruct the index of all the tags of all the DICOM instances that are stored in Orthanc. This is notably useful after the deletion of resources whose children resources have inconsistent values with their sibling resources. Beware that this is a highly time-consuming operation, as all the DICOM instances will be parsed again, and as all the Orthanc index will be regenerated. If you have a large database to process, it is advised to use the Housekeeper plugin to perform this action resource by resource\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._post(\n        route=f\"{self.url}/tools/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_reset","title":"<code>post_tools_reset()</code>  <code>async</code>","text":"<p>(async) Restart Orthanc</p> <p>Restart Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_reset(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Restart Orthanc\n\n    Restart Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/tools/reset\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.post_tools_shutdown","title":"<code>post_tools_shutdown()</code>  <code>async</code>","text":"<p>(async) Shutdown Orthanc</p> <p>Shutdown Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def post_tools_shutdown(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Shutdown Orthanc\n\n    Shutdown Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._post(\n        route=f\"{self.url}/tools/shutdown\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_instances_id_attachments_name","title":"<code>put_instances_id_attachments_name(id_, name, content=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set attachment</p> <p>Attach a file to the given DICOM instance. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_instances_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set attachment\n\n    Attach a file to the given DICOM instance. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_instances_id_labels_label","title":"<code>put_instances_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Add label</p> <p>Associate a label with a instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_instances_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Add label\n\n    Associate a label with a instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/instances/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_instances_id_metadata_name","title":"<code>put_instances_id_metadata_name(id_, name, data=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set metadata</p> <p>Set the value of some metadata in the given DICOM instance. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_instances_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set metadata\n\n    Set the value of some metadata in the given DICOM instance. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_modalities_id","title":"<code>put_modalities_id(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Update DICOM modality</p> <p>Define a new DICOM modality, or update an existing one. This change is permanent iff. <code>DicomModalitiesInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the new/updated DICOM modality</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"AET\": AET of the remote DICOM modality   \"AllowEcho\": Whether to accept C-ECHO SCU commands issued by the remote modality   \"AllowFind\": Whether to accept C-FIND SCU commands issued by the remote modality   \"AllowFindWorklist\": Whether to accept C-FIND SCU commands for worklists issued by the remote modality   \"AllowGet\": Whether to accept C-GET SCU commands issued by the remote modality   \"AllowMove\": Whether to accept C-MOVE SCU commands issued by the remote modality   \"AllowStorageCommitment\": Whether to accept storage commitment requests issued by the remote modality   \"AllowStore\": Whether to accept C-STORE SCU commands issued by the remote modality   \"AllowTranscoding\": Whether to allow transcoding for operations initiated by this modality. This option applies to Orthanc C-GET SCP and to Orthanc C-STORE SCU. It only has an effect if the global option <code>EnableTranscoding</code> is set to <code>true</code>.   \"Host\": Host address of the remote DICOM modality (typically, an IP address)   \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality   \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option <code>DicomModalities</code> for possible values   \"Port\": TCP port of the remote DICOM modality   \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality   \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_modalities_id(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Update DICOM modality\n\n    Define a new DICOM modality, or update an existing one. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the new/updated DICOM modality\n    json\n        Dictionary with the following keys:\n          \"AET\": AET of the remote DICOM modality\n          \"AllowEcho\": Whether to accept C-ECHO SCU commands issued by the remote modality\n          \"AllowFind\": Whether to accept C-FIND SCU commands issued by the remote modality\n          \"AllowFindWorklist\": Whether to accept C-FIND SCU commands for worklists issued by the remote modality\n          \"AllowGet\": Whether to accept C-GET SCU commands issued by the remote modality\n          \"AllowMove\": Whether to accept C-MOVE SCU commands issued by the remote modality\n          \"AllowStorageCommitment\": Whether to accept storage commitment requests issued by the remote modality\n          \"AllowStore\": Whether to accept C-STORE SCU commands issued by the remote modality\n          \"AllowTranscoding\": Whether to allow transcoding for operations initiated by this modality. This option applies to Orthanc C-GET SCP and to Orthanc C-STORE SCU. It only has an effect if the global option `EnableTranscoding` is set to `true`.\n          \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n          \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n          \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n          \"Port\": TCP port of the remote DICOM modality\n          \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n          \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._put(\n        route=f\"{self.url}/modalities/{id_}\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_patients_id_attachments_name","title":"<code>put_patients_id_attachments_name(id_, name, content=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set attachment</p> <p>Attach a file to the given DICOM patient. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_patients_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set attachment\n\n    Attach a file to the given DICOM patient. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_patients_id_labels_label","title":"<code>put_patients_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Add label</p> <p>Associate a label with a patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_patients_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Add label\n\n    Associate a label with a patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/patients/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_patients_id_metadata_name","title":"<code>put_patients_id_metadata_name(id_, name, data=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set metadata</p> <p>Set the value of some metadata in the given DICOM patient. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_patients_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set metadata\n\n    Set the value of some metadata in the given DICOM patient. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_patients_id_protected","title":"<code>put_patients_id_protected(id_)</code>  <code>async</code>","text":"<p>(async) Protect/Unprotect a patient against recycling</p> <p>Protects a patient by sending <code>1</code> or <code>true</code> in the payload request. Unprotects a patient by sending <code>0</code> or <code>false</code> in the payload requests. More info: https://orthanc.uclouvain.be/book/faq/features.html#recycling-protection Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_patients_id_protected(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Protect/Unprotect a patient against recycling\n\n    Protects a patient by sending `1` or `true` in the payload request. Unprotects a patient by sending `0` or `false` in the payload requests. More info: https://orthanc.uclouvain.be/book/faq/features.html#recycling-protection\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/patients/{id_}/protected\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_peers_id","title":"<code>put_peers_id(id_, json=None)</code>  <code>async</code>","text":"<p>(async) Update Orthanc peer</p> <p>Define a new Orthanc peer, or update an existing one. This change is permanent iff. <code>OrthancPeersInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the new/updated Orthanc peer</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"CertificateFile\": SSL certificate for the HTTPS connections   \"CertificateKeyFile\": Key file for the SSL certificate for the HTTPS connections   \"CertificateKeyPassword\": Key password for the SSL certificate for the HTTPS connections   \"HttpHeaders\": HTTP headers to be used for the connections to the remote peer   \"Password\": Password for the credentials   \"URL\": URL of the root of the REST API of the remote Orthanc peer, for instance <code>http://localhost:8042/</code>   \"Username\": Username for the credentials</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_peers_id(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Update Orthanc peer\n\n    Define a new Orthanc peer, or update an existing one. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the new/updated Orthanc peer\n    json\n        Dictionary with the following keys:\n          \"CertificateFile\": SSL certificate for the HTTPS connections\n          \"CertificateKeyFile\": Key file for the SSL certificate for the HTTPS connections\n          \"CertificateKeyPassword\": Key password for the SSL certificate for the HTTPS connections\n          \"HttpHeaders\": HTTP headers to be used for the connections to the remote peer\n          \"Password\": Password for the credentials\n          \"URL\": URL of the root of the REST API of the remote Orthanc peer, for instance `http://localhost:8042/`\n          \"Username\": Username for the credentials\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._put(\n        route=f\"{self.url}/peers/{id_}\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_series_id_attachments_name","title":"<code>put_series_id_attachments_name(id_, name, content=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set attachment</p> <p>Attach a file to the given DICOM series. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_series_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set attachment\n\n    Attach a file to the given DICOM series. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/series/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_series_id_labels_label","title":"<code>put_series_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Add label</p> <p>Associate a label with a series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_series_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Add label\n\n    Associate a label with a series\n    Tags: Series\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/series/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_series_id_metadata_name","title":"<code>put_series_id_metadata_name(id_, name, data=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set metadata</p> <p>Set the value of some metadata in the given DICOM series. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_series_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set metadata\n\n    Set the value of some metadata in the given DICOM series. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/series/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_studies_id_attachments_name","title":"<code>put_studies_id_attachments_name(id_, name, content=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set attachment</p> <p>Attach a file to the given DICOM study. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_studies_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set attachment\n\n    Attach a file to the given DICOM study. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_studies_id_labels_label","title":"<code>put_studies_id_labels_label(id_, label)</code>  <code>async</code>","text":"<p>(async) Add label</p> <p>Associate a label with a study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_studies_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Add label\n\n    Associate a label with a study\n    Tags: Studies\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/studies/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_studies_id_metadata_name","title":"<code>put_studies_id_metadata_name(id_, name, data=None, headers=None)</code>  <code>async</code>","text":"<p>(async) Set metadata</p> <p>Set the value of some metadata in the given DICOM study. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_studies_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set metadata\n\n    Set the value of some metadata in the given DICOM study. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_accepted_transfer_syntaxes","title":"<code>put_tools_accepted_transfer_syntaxes(data=None, json=None)</code>  <code>async</code>","text":"<p>(async) Set accepted transfer syntaxes</p> <p>Set the DICOM transfer syntaxes that accepted by Orthanc C-STORE SCP Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>UID of the transfer syntax to be accepted. Wildcards <code>?</code> and <code>*</code> are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the now-accepted transfer syntax UIDs</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_accepted_transfer_syntaxes(\n    self,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set accepted transfer syntaxes\n\n    Set the DICOM transfer syntaxes that accepted by Orthanc C-STORE SCP\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n\n    data\n        UID of the transfer syntax to be accepted. Wildcards `?` and `*` are accepted.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the now-accepted transfer syntax UIDs\n    \"\"\"\n    if json is None:\n        json = {}\n    return await self._put(\n        route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_default_encoding","title":"<code>put_tools_default_encoding(data=None)</code>  <code>async</code>","text":"<p>(async) Set default encoding</p> <p>Change the default encoding that is used by Orthanc if parsing a DICOM instance without the <code>SpecificCharacterEncoding</code> tag, or during C-FIND. This corresponds to the configuration option <code>DefaultEncoding</code>. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>The name of the encoding. Check out configuration option <code>DefaultEncoding</code> for the allowed values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_default_encoding(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set default encoding\n\n    Change the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        The name of the encoding. Check out configuration option `DefaultEncoding` for the allowed values.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/default-encoding\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level","title":"<code>put_tools_log_level(data=None)</code>  <code>async</code>","text":"<p>(async) Set main log level</p> <p>Set the main log level of Orthanc Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set main log level\n\n    Set the main log level of Orthanc\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level_dicom","title":"<code>put_tools_log_level_dicom(data=None)</code>  <code>async</code>","text":"<p>(async) Set log level for <code>dicom</code></p> <p>Set the log level of the log category <code>dicom</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level_dicom(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set log level for `dicom`\n\n    Set the log level of the log category `dicom`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level-dicom\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level_generic","title":"<code>put_tools_log_level_generic(data=None)</code>  <code>async</code>","text":"<p>(async) Set log level for <code>generic</code></p> <p>Set the log level of the log category <code>generic</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level_generic(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set log level for `generic`\n\n    Set the log level of the log category `generic`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level-generic\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level_http","title":"<code>put_tools_log_level_http(data=None)</code>  <code>async</code>","text":"<p>(async) Set log level for <code>http</code></p> <p>Set the log level of the log category <code>http</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level_http(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set log level for `http`\n\n    Set the log level of the log category `http`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level-http\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level_jobs","title":"<code>put_tools_log_level_jobs(data=None)</code>  <code>async</code>","text":"<p>(async) Set log level for <code>jobs</code></p> <p>Set the log level of the log category <code>jobs</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level_jobs(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set log level for `jobs`\n\n    Set the log level of the log category `jobs`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level-jobs\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level_lua","title":"<code>put_tools_log_level_lua(data=None)</code>  <code>async</code>","text":"<p>(async) Set log level for <code>lua</code></p> <p>Set the log level of the log category <code>lua</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level_lua(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set log level for `lua`\n\n    Set the log level of the log category `lua`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level-lua\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level_plugins","title":"<code>put_tools_log_level_plugins(data=None)</code>  <code>async</code>","text":"<p>(async) Set log level for <code>plugins</code></p> <p>Set the log level of the log category <code>plugins</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level_plugins(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set log level for `plugins`\n\n    Set the log level of the log category `plugins`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level-plugins\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_log_level_sqlite","title":"<code>put_tools_log_level_sqlite(data=None)</code>  <code>async</code>","text":"<p>(async) Set log level for <code>sqlite</code></p> <p>Set the log level of the log category <code>sqlite</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_log_level_sqlite(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set log level for `sqlite`\n\n    Set the log level of the log category `sqlite`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/log-level-sqlite\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_metrics","title":"<code>put_tools_metrics(data=None)</code>  <code>async</code>","text":"<p>(async) Enable collection of metrics</p> <p>Enable or disable the collection and publication of metrics at <code>/tools/metrics-prometheus</code> Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p><code>1</code> if metrics are collected, <code>0</code> if metrics are disabled</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_metrics(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Enable collection of metrics\n\n    Enable or disable the collection and publication of metrics at `/tools/metrics-prometheus`\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        `1` if metrics are collected, `0` if metrics are disabled\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/metrics\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.put_tools_unknown_sop_class_accepted","title":"<code>put_tools_unknown_sop_class_accepted(data=None)</code>  <code>async</code>","text":"<p>(async) Set unknown SOP class accepted</p> <p>Set whether Orthanc C-STORE SCP should accept DICOM instances with an unknown SOP class UID Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p><code>1</code> if accepted, <code>0</code> if not accepted</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/async_client.py</code> <pre><code>async def put_tools_unknown_sop_class_accepted(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"(async) Set unknown SOP class accepted\n\n    Set whether Orthanc C-STORE SCP should accept DICOM instances with an unknown SOP class UID\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        `1` if accepted, `0` if not accepted\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return await self._put(\n        route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/async_client/#pyorthanc.AsyncOrthanc.setup_credentials","title":"<code>setup_credentials(username, password)</code>","text":"<p>Set credentials needed for HTTP requests</p> Source code in <code>pyorthanc/async_client.py</code> <pre><code>def setup_credentials(self, username: str, password: str) -&gt; None:\n    \"\"\"Set credentials needed for HTTP requests\"\"\"\n    self._auth = httpx.BasicAuth(username, password)\n</code></pre>"},{"location":"api/client/","title":"Orthanc","text":""},{"location":"api/client/#pyorthanc.Orthanc","title":"<code>pyorthanc.Orthanc</code>","text":"<p>               Bases: <code>Client</code></p> <p>Orthanc API</p> <p>version 1.12.6 This is the full documentation of the REST API of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A shorter cheat sheet is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is still available, but is not up-to-date anymore (source).</p> Source code in <code>pyorthanc/client.py</code> <pre><code>class Orthanc(httpx.Client):\n    \"\"\"Orthanc API\n\n    version 1.12.6\n    This is the full documentation of the [REST API](https://orthanc.uclouvain.be/book/users/rest.html) of Orthanc.&lt;p&gt;This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://orthanc.uclouvain.be/book/users/rest-cheatsheet.html) is part of the Orthanc Book.&lt;p&gt;An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).\n\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        return_raw_response: bool = False,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        url\n            server's URL\n        username\n            Orthanc's username\n        password\n            Orthanc's password\n        return_raw_response\n            All Orthanc's methods will return a raw httpx.Response rather than the serialized result\n        *args, **kwargs\n            Parameters passed to the httpx.Client (headers, timeout, etc.)\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.url = url\n        self.version = \"1.12.6\"\n        self.return_raw_response = return_raw_response\n\n        if username and password:\n            self.setup_credentials(username, password)\n\n    def setup_credentials(self, username: str, password: str) -&gt; None:\n        \"\"\"Set credentials needed for HTTP requests\"\"\"\n        self._auth = httpx.BasicAuth(username, password)\n\n    def _get(\n        self,\n        route: str,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"GET request with specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        params\n            Parameters for the HTTP request.\n        headers\n            Headers for the HTTP request.\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP GET request or httpx.Response.\n        \"\"\"\n        response = self.get(url=route, params=params, headers=headers, cookies=cookies)\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with content: {response.text}\"\n        )\n\n    def _delete(\n        self,\n        route: str,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"DELETE to specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        params\n            Parameters for the HTTP request.\n        headers\n            Headers for the HTTP request.\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP DELETE request or httpx.Response.\n        \"\"\"\n        response = self.delete(route, params=params, headers=headers, cookies=cookies)\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with content: {response.text}\"\n        )\n\n    def _post(\n        self,\n        route: str,\n        content: Optional[RequestContent] = None,\n        data: Optional[RequestData] = None,\n        files: Optional[RequestFiles] = None,\n        json: Optional[Any] = None,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"POST to specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        content\n        data\n            Dictionary to send in the body of request.\n        files\n        json\n        params\n        headers\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP POST request or httpx.Response.\n        \"\"\"\n        response = self.post(\n            route,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n        )\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with text: {response.text}\"\n        )\n\n    def _put(\n        self,\n        route: str,\n        content: RequestContent = None,\n        data: RequestData = None,\n        files: Optional[RequestFiles] = None,\n        json: Optional[Any] = None,\n        params: Optional[QueryParamTypes] = None,\n        headers: Optional[HeaderTypes] = None,\n        cookies: Optional[CookieTypes] = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"PUT to specified route\n\n        Parameters\n        ----------\n        route\n            HTTP route.\n        content\n        data\n            Dictionary to send in the body of request.\n        files\n        json\n        params\n        headers\n        cookies\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Serialized response of the HTTP PUT request or httpx.Response.\n        \"\"\"\n        response = self.put(\n            route,\n            content=content,\n            data=data,\n            files=files,\n            json=json,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n        )\n\n        if self.return_raw_response:\n            return response\n\n        if 200 &lt;= response.status_code &lt; 300:\n            if \"application/json\" in response.headers[\"content-type\"]:\n                return response.json()\n            elif \"text/plain\" in response.headers[\"content-type\"]:\n                return response.text\n            else:\n                return response.content\n\n        raise httpx.HTTPError(\n            f\"HTTP code: {response.status_code}, with text: {response.text}\"\n        )\n\n    def delete_changes(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Clear changes\n\n        Clear the full history stored in the changes log\n        Tags: Tracking changes\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/changes\",\n        )\n\n    def get_changes(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List changes\n\n        Whenever Orthanc receives a new DICOM instance, this event is recorded in the so-called _Changes Log_. This enables remote scripts to react to the arrival of new DICOM resources. A typical application is auto-routing, where an external script waits for a new DICOM instance to arrive into Orthanc, then forward this instance to another modality. Please note that, when resources are deleted, their corresponding change entries are also removed from the Changes Log, which helps ensuring that this log does not grow indefinitely.\n        Tags: Tracking changes\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"last\" (float): Request only the last change id (this argument must be used alone)\n                \"limit\" (float): Limit the number of results\n                \"since\" (float): Show only the resources since the provided index excluded\n                \"to\" (float): Show only the resources till the provided index included (only available if your DB backend supports ExtendedChanges)\n                \"type\" (str): Show only the changes of the provided type (only available if your DB backend supports ExtendedChanges).  Multiple values can be provided and must be separated by a ';'.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of changes\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/changes\",\n            params=params,\n        )\n\n    def delete_exports(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Clear exports\n\n        Clear the full history stored in the exports log\n        Tags: Tracking changes\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/exports\",\n        )\n\n    def get_exports(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List exports\n\n        For medical traceability, Orthanc can be configured to store a log of all the resources that have been exported to remote modalities. In auto-routing scenarios, it is important to prevent this log to grow indefinitely as incoming instances are routed. You can either disable this logging by setting the option `LogExportedResources` to `false` in the configuration file, or periodically clear this log by `DELETE`-ing this URI. This route might be removed in future versions of Orthanc.\n        Tags: Tracking changes\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"limit\" (float): Limit the number of results\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of exports\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/exports\",\n            params=params,\n        )\n\n    def get_instances(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List the available instances\n\n        List the Orthanc identifiers of all the available DICOM instances\n        Tags: Instances\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported instances (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances\",\n            params=params,\n        )\n\n    def post_instances(\n        self,\n        content: RequestContent = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Upload DICOM instances\n\n        Upload DICOM instances\n        Tags: Instances\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the uploaded instance, or list of information for each uploaded instance in the case of ZIP archive\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/instances\",\n            content=content,\n        )\n\n    def delete_instances_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete some instance\n\n        Delete the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/instances/{id_}\",\n        )\n\n    def get_instances_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get information about some instance\n\n        Get detailed information about the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM instance\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}\",\n            params=params,\n        )\n\n    def post_instances_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Anonymize instance\n\n        Download an anonymized version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-a-single-instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        json\n            Dictionary with the following keys:\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The anonymized DICOM instance\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/instances/{id_}/anonymize\",\n            json=json,\n        )\n\n    def get_instances_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List attachments\n\n        Get the list of attachments that are associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments\",\n            params=params,\n        )\n\n    def delete_instances_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete attachment\n\n        Delete an attachment associated with the given DICOM instance. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given instance\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def put_instances_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set attachment\n\n        Attach a file to the given DICOM instance. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    def post_instances_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compress\",\n        )\n\n    def get_instances_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given instance. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given instance, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment on disk\n\n        Get the size of one attachment associated with the given instance, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment\n\n        Get the (binary) content of one attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get info about the attachment\n\n        Get all the information about the attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    def get_instances_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment\n\n        Get the size of one attachment associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    def post_instances_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/uncompress\",\n        )\n\n    def post_instances_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/instances/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    def get_instances_id_content_path(\n        self,\n        id_: str,\n        path: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get raw tag\n\n        Get the raw content of one DICOM tag in the hierarchy of DICOM dataset\n        Tags: Instances\n\n        Parameters\n        ----------\n        path\n            Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, `/0008-1140/1/0008-1150`\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The raw value of the tag of intereset (binary data, whose memory layout depends on the underlying transfer syntax), or JSON array containing the list of available tags if accessing a dataset\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/content/{path}\",\n        )\n\n    def post_instances_id_export(\n        self,\n        id_: str,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Write DICOM onto filesystem\n\n        Write the DICOM file onto the filesystem where Orthanc is running.  This is insecure for Orthanc servers that are remotely accessible since one could overwrite any system file.  Since Orthanc 1.12.0, this route is disabled by default, but can be enabled using the `RestApiWriteToFileSystemEnabled` configuration option.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        data\n            Target path on the filesystem\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/instances/{id_}/export\",\n            data=data,\n        )\n\n    def get_instances_id_file(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Download DICOM\n\n        Download one DICOM instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"transcode\" (str): If present, the DICOM file will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): This HTTP header can be set to retrieve the DICOM instance in DICOMweb format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The DICOM instance\n            The DICOM instance, in DICOMweb JSON format\n            The DICOM instance, in DICOMweb XML format\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/file\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_frames(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List available frames\n\n        List the frames that are available in the DICOM instance of interest\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of the indices of the available frames\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames\",\n        )\n\n    def get_instances_id_frames_frame(\n        self,\n        frame: str,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations\n\n        List the available operations under URI `/instances/{id}/frames/{frame}/`\n        Tags: Other\n\n        Parameters\n        ----------\n        frame\n\n        id_\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}\",\n        )\n\n    def get_instances_id_frames_frame_image_int16(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode a frame (int16)\n\n        Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/image-int16\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_frames_frame_image_uint16(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode a frame (uint16)\n\n        Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint16\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_frames_frame_image_uint8(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode a frame (uint8)\n\n        Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint8\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_frames_frame_matlab(\n        self,\n        frame: float,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode frame for Matlab\n\n        Decode one frame of interest from the given DICOM instance, and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Octave/Matlab matrix\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/matlab\",\n        )\n\n    def get_instances_id_frames_frame_numpy(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode frame for numpy\n\n        Decode one frame of interest from the given DICOM instance, for use with numpy in Python. The numpy array has 3 dimensions: (height, width, color channel).\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM resource of interest\n        params\n            Dictionary of optional parameters:\n                \"compress\" (bool): Compress the file as `.npz`\n                \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/numpy\",\n            params=params,\n        )\n\n    def get_instances_id_frames_frame_preview(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode a frame (preview)\n\n        Decode one frame of interest from the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/preview\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_frames_frame_raw(\n        self,\n        frame: float,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Access raw frame\n\n        Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The raw frame\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/raw\",\n        )\n\n    def get_instances_id_frames_frame_raw_gz(\n        self,\n        frame: float,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Access raw frame (compressed)\n\n        Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. The image is compressed using gzip\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The raw frame, compressed using gzip\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/raw.gz\",\n        )\n\n    def get_instances_id_frames_frame_rendered(\n        self,\n        frame: float,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Render a frame\n\n        Render one frame of interest from the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n        Tags: Instances\n\n        Parameters\n        ----------\n        frame\n            Index of the frame (starts at `0`)\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"height\" (float): Height of the resized image\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n                \"smooth\" (bool): Whether to smooth image on resize\n                \"width\" (float): Width of the resized image\n                \"window-center\" (float): Windowing center\n                \"window-width\" (float): Windowing width\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/frames/{frame}/rendered\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_header(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get DICOM meta-header\n\n        Get the DICOM tags in the meta-header of the DICOM instance. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags and their associated value\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/header\",\n            params=params,\n        )\n\n    def get_instances_id_image_int16(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode an image (int16)\n\n        Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/image-int16\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_image_uint16(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode an image (uint16)\n\n        Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/image-uint16\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_image_uint8(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode an image (uint8)\n\n        Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/image-uint8\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List labels\n\n        Get the labels that are associated with the given instance (new in Orthanc 1.12.0)\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/labels\",\n        )\n\n    def delete_instances_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Remove label\n\n        Remove a label associated with a instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/instances/{id_}/labels/{label}\",\n        )\n\n    def get_instances_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Test label\n\n        Test whether the instance is associated with the given label\n        Tags: Instances\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/labels/{label}\",\n        )\n\n    def put_instances_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Add label\n\n        Associate a label with a instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/instances/{id_}/labels/{label}\",\n        )\n\n    def get_instances_id_matlab(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode frame for Matlab\n\n        Decode the first frame of the given DICOM instance., and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Octave/Matlab matrix\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/matlab\",\n        )\n\n    def get_instances_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List metadata\n\n        Get the list of metadata that are associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/metadata\",\n            params=params,\n        )\n\n    def delete_instances_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete metadata\n\n        Delete some metadata associated with the given DICOM instance. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def get_instances_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get metadata\n\n        Get the value of a metadata that is associated with the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def put_instances_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set metadata\n\n        Set the value of some metadata in the given DICOM instance. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Instances\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the instance of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    def post_instances_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Modify instance\n\n        Download a modified version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-a-single-instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        json\n            Dictionary with the following keys:\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The modified DICOM instance\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/instances/{id_}/modify\",\n            json=json,\n        )\n\n    def get_instances_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get instance module\n\n        Get the instance module of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM instance\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/module\",\n            params=params,\n        )\n\n    def get_instances_id_numpy(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode instance for numpy\n\n        Decode the given DICOM instance, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM resource of interest\n        params\n            Dictionary of optional parameters:\n                \"compress\" (bool): Compress the file as `.npz`\n                \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/numpy\",\n            params=params,\n        )\n\n    def get_instances_id_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get parent patient\n\n        Get detailed information about the parent patient of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM patient\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/patient\",\n            params=params,\n        )\n\n    def get_instances_id_pdf(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get embedded PDF\n\n        Get the PDF file that is embedded in one DICOM instance. If the DICOM instance doesn't contain the `EncapsulatedDocument` tag or if the `MIMETypeOfEncapsulatedDocument` tag doesn't correspond to the PDF type, a `404` HTTP error is raised.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            PDF file\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/pdf\",\n        )\n\n    def get_instances_id_preview(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode an image (preview)\n\n        Decode the first frame of the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/preview\",\n            params=params,\n            headers=headers,\n        )\n\n    def post_instances_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Reconstruct tags &amp; optionally files of instance\n\n        Reconstruct the main DICOM tags in DB of the instance whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/instances/{id_}/reconstruct\",\n            json=json,\n        )\n\n    def get_instances_id_rendered(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Render an image\n\n        Render the first frame of the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"height\" (float): Height of the resized image\n                \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n                \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n                \"smooth\" (bool): Whether to smooth image on resize\n                \"width\" (float): Width of the resized image\n                \"window-center\" (float): Windowing center\n                \"window-width\" (float): Windowing width\n        headers\n            Dictionary of optional headers:\n                \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JPEG image\n            PNG image\n            PAM image (Portable Arbitrary Map)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/rendered\",\n            params=params,\n            headers=headers,\n        )\n\n    def get_instances_id_series(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get parent series\n\n        Get detailed information about the parent series of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM series\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/series\",\n            params=params,\n        )\n\n    def get_instances_id_simplified_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get human-readable tags\n\n        Get the DICOM tags in human-readable format (same as the `/instances/{id}/tags?simplify` route)\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags and their associated value\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/simplified-tags\",\n            params=params,\n        )\n\n    def get_instances_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get instance statistics\n\n        Get statistics about the given instance\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/statistics\",\n        )\n\n    def get_instances_id_study(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get parent study\n\n        Get detailed information about the parent study of the DICOM instance whose Orthanc identifier is provided in the URL\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the instance of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM study\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/study\",\n            params=params,\n        )\n\n    def get_instances_id_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get DICOM tags\n\n        Get the DICOM tags in the specified format. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n        Tags: Instances\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM instance of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n                \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags and their associated value\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/instances/{id_}/tags\",\n            params=params,\n        )\n\n    def get_jobs(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List jobs\n\n        List all the available jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual jobs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the jobs identifiers, or detailed information about the reported jobs (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/jobs\",\n            params=params,\n        )\n\n    def delete_jobs_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete a job from history\n\n        Delete the job from the jobs history.  Only a completed job can be deleted. If the job has not run or not completed yet, you must cancel it first. If the job has outputs, all outputs will be deleted as well.\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/jobs/{id_}\",\n        )\n\n    def get_jobs_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get job\n\n        Retrieve detailed information about the job whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object detailing the job\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/jobs/{id_}\",\n        )\n\n    def post_jobs_id_cancel(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Cancel job\n\n        Cancel the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/jobs/{id_}/cancel\",\n        )\n\n    def post_jobs_id_pause(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Pause job\n\n        Pause the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/jobs/{id_}/pause\",\n        )\n\n    def post_jobs_id_resubmit(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Resubmit job\n\n        Resubmit the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/jobs/{id_}/resubmit\",\n        )\n\n    def post_jobs_id_resume(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Resume job\n\n        Resume the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        Tags: Jobs\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/jobs/{id_}/resume\",\n        )\n\n    def delete_jobs_id_key(\n        self,\n        id_: str,\n        key: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete a job output\n\n        Delete the output produced by a job. As of Orthanc 1.12.1, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n        Tags: Jobs\n\n        Parameters\n        ----------\n        key\n            Name of the output of interest\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/jobs/{id_}/{key}\",\n        )\n\n    def get_jobs_id_key(\n        self,\n        id_: str,\n        key: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get job output\n\n        Retrieve some output produced by a job. As of Orthanc 1.8.2, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n        Tags: Jobs\n\n        Parameters\n        ----------\n        key\n            Name of the output of interest\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Content of the output of the job\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/jobs/{id_}/{key}\",\n        )\n\n    def get_modalities(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List DICOM modalities\n\n        List all the DICOM modalities that are known to Orthanc. This corresponds either to the content of the `DicomModalities` configuration option, or to the information stored in the database if `DicomModalitiesInDatabase` is `true`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual DICOM modalities\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the identifiers of the modalities, or detailed information about the modalities (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/modalities\",\n            params=params,\n        )\n\n    def delete_modalities_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete DICOM modality\n\n        Delete one DICOM modality. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the DICOM modality of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/modalities/{id_}\",\n        )\n\n    def get_modalities_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on modality\n\n        List the operations that are available for a DICOM modality.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the DICOM modality of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/modalities/{id_}\",\n        )\n\n    def put_modalities_id(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Update DICOM modality\n\n        Define a new DICOM modality, or update an existing one. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the new/updated DICOM modality\n        json\n            Dictionary with the following keys:\n              \"AET\": AET of the remote DICOM modality\n              \"AllowEcho\": Whether to accept C-ECHO SCU commands issued by the remote modality\n              \"AllowFind\": Whether to accept C-FIND SCU commands issued by the remote modality\n              \"AllowFindWorklist\": Whether to accept C-FIND SCU commands for worklists issued by the remote modality\n              \"AllowGet\": Whether to accept C-GET SCU commands issued by the remote modality\n              \"AllowMove\": Whether to accept C-MOVE SCU commands issued by the remote modality\n              \"AllowStorageCommitment\": Whether to accept storage commitment requests issued by the remote modality\n              \"AllowStore\": Whether to accept C-STORE SCU commands issued by the remote modality\n              \"AllowTranscoding\": Whether to allow transcoding for operations initiated by this modality. This option applies to Orthanc C-GET SCP and to Orthanc C-STORE SCU. It only has an effect if the global option `EnableTranscoding` is set to `true`.\n              \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n              \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n              \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n              \"Port\": TCP port of the remote DICOM modality\n              \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n              \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._put(\n            route=f\"{self.url}/modalities/{id_}\",\n            json=json,\n        )\n\n    def get_modalities_id_configuration(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get modality configuration\n\n        Get detailed information about the configuration of some DICOM modality\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Configuration of the modality\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/modalities/{id_}/configuration\",\n        )\n\n    def post_modalities_id_echo(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Trigger C-ECHO SCU\n\n        Trigger C-ECHO SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-echo\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n              \"Timeout\": Timeout for the C-ECHO command, in seconds\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/echo\",\n            json=json,\n        )\n\n    def post_modalities_id_find(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Hierarchical C-FIND SCU\n\n        Trigger a sequence of C-FIND SCU commands against the DICOM modality whose identifier is provided in URL, in order to discover a hierarchy of matching patients/studies/series. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching patients, embedding the matching studies, then the matching series.\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/find\",\n            json=json,\n        )\n\n    def post_modalities_id_find_instance(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"C-FIND SCU for instances\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find an instance. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching instances\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/find-instance\",\n            json=json,\n        )\n\n    def post_modalities_id_find_patient(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"C-FIND SCU for patients\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a patient. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching patients\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/find-patient\",\n            json=json,\n        )\n\n    def post_modalities_id_find_series(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"C-FIND SCU for series\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a series. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching series\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/find-series\",\n            json=json,\n        )\n\n    def post_modalities_id_find_study(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"C-FIND SCU for studies\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a study. Deprecated in favor of `/modalities/{id}/query`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching studies\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/find-study\",\n            json=json,\n        )\n\n    def post_modalities_id_find_worklist(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"C-FIND SCU for worklist\n\n        Trigger C-FIND SCU command against the remote worklists of the DICOM modality whose identifier is provided in URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array describing the DICOM tags of the matching worklists\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/find-worklist\",\n            json=json,\n        )\n\n    def post_modalities_id_get(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Trigger C-GET SCU\n\n        Start a C-GET SCU command as a job, in order to retrieve DICOM resources from a remote DICOM modality whose identifier is provided in the URL:\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of queries identifying all the DICOM resources to be sent.  Usage of wildcards is prohibited and the query shall only contain DICOM ID tags.  Additionally, you may provide SOPClassesInStudy to limit the scope of the DICOM negotiation to certain SOPClassUID or to present uncommon SOPClassUID during the DICOM negotation.  By default, Orhanc will propose the most 120 common SOPClassUIDs.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Timeout\": Timeout for the C-GET command, in seconds\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/get\",\n            json=json,\n        )\n\n    def post_modalities_id_move(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Trigger C-MOVE SCU\n\n        Start a C-MOVE SCU command as a job, in order to drive the execution of a sequence of C-STORE commands by some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-move\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of queries identifying all the DICOM resources to be sent\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"TargetAet\": Target AET that will be used by the remote DICOM modality as a target for its C-STORE SCU commands, defaults to `DicomAet` configuration option in order to do a simple query/retrieve\n              \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/move\",\n            json=json,\n        )\n\n    def post_modalities_id_query(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Trigger C-FIND SCU\n\n        Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"Normalize\": Whether to normalize the query, i.e. whether to wipe out from the query, the DICOM tags that are not applicable for the query-retrieve level of interest\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command and subsequent C-MOVE retrievals, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/query\",\n            json=json,\n        )\n\n    def post_modalities_id_storage_commitment(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Trigger storage commitment request\n\n        Trigger a storage commitment request to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"DicomInstances\": List of DICOM resources that are not necessarily stored within Orthanc, but that must be checked by storage commitment. This is a list of JSON objects that must contain the `SOPClassUID` and `SOPInstanceUID` fields.\n              \"Resources\": List of the Orthanc identifiers of the DICOM resources to be checked by storage commitment\n              \"Timeout\": Timeout for the storage commitment command (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/storage-commitment\",\n            json=json,\n        )\n\n    def post_modalities_id_store(\n        self,\n        id_: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Trigger C-STORE SCU\n\n        Start a C-STORE SCU command as a job, in order to send DICOM resources stored locally to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#rest-store-scu\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"CalledAet\": Called AET that is used for this commands, defaults to `AET` configuration option. Allows you to overwrite the destination AET for a specific operation.\n              \"Host\": Host that is used for this commands, defaults to `Host` configuration option. Allows you to overwrite the destination host for a specific operation.\n              \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n              \"MoveOriginatorAet\": Move originator AET that is used for this commands, in order to fake a C-MOVE SCU\n              \"MoveOriginatorID\": Move originator ID that is used for this commands, in order to fake a C-MOVE SCU\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Port\": Port that is used for this command, defaults to `Port` configuration option. Allows you to overwrite the destination port for a specific operation.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n              \"StorageCommitment\": Whether to chain C-STORE with DICOM storage commitment to validate the success of the transmission: https://orthanc.uclouvain.be/book/users/storage-commitment.html#chaining-c-store-with-storage-commitment\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Timeout\": Timeout for the C-STORE command, in seconds\n\n        data\n            The Orthanc identifier of one resource to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/store\",\n            data=data,\n            json=json,\n        )\n\n    def post_modalities_id_store_straight(\n        self,\n        id_: str,\n        content: RequestContent = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Straight C-STORE SCU\n\n        Synchronously send the DICOM instance in the POST body to the remote DICOM modality whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `storescu` from DCMTK or dcm4che.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        content\n                - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/modalities/{id_}/store-straight\",\n            content=content,\n        )\n\n    def get_patients(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List the available patients\n\n        List the Orthanc identifiers of all the available DICOM patients\n        Tags: Patients\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported patients (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients\",\n            params=params,\n        )\n\n    def delete_patients_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete some patient\n\n        Delete the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/patients/{id_}\",\n        )\n\n    def get_patients_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get information about some patient\n\n        Get detailed information about the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM patient\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}\",\n            params=params,\n        )\n\n    def post_patients_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Anonymize patient\n\n        Start a job that will anonymize all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/anonymize\",\n            json=json,\n        )\n\n    def get_patients_id_archive(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Synchronously create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/archive\",\n            params=params,\n        )\n\n    def post_patients_id_archive(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/archive\",\n            json=json,\n        )\n\n    def get_patients_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List attachments\n\n        Get the list of attachments that are associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments\",\n            params=params,\n        )\n\n    def delete_patients_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete attachment\n\n        Delete an attachment associated with the given DICOM patient. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given patient\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def put_patients_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set attachment\n\n        Attach a file to the given DICOM patient. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    def post_patients_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compress\",\n        )\n\n    def get_patients_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given patient. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given patient, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment on disk\n\n        Get the size of one attachment associated with the given patient, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment\n\n        Get the (binary) content of one attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get info about the attachment\n\n        Get all the information about the attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    def get_patients_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment\n\n        Get the size of one attachment associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    def post_patients_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/uncompress\",\n        )\n\n    def post_patients_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    def get_patients_id_instances(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get child instances\n\n        Get detailed information about the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child instances\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM instances\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/instances\",\n            params=params,\n        )\n\n    def get_patients_id_instances_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get tags of instances\n\n        Get the tags of all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/instances-tags\",\n            params=params,\n        )\n\n    def get_patients_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List labels\n\n        Get the labels that are associated with the given patient (new in Orthanc 1.12.0)\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/labels\",\n        )\n\n    def delete_patients_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Remove label\n\n        Remove a label associated with a patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/patients/{id_}/labels/{label}\",\n        )\n\n    def get_patients_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Test label\n\n        Test whether the patient is associated with the given label\n        Tags: Patients\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/labels/{label}\",\n        )\n\n    def put_patients_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Add label\n\n        Associate a label with a patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/patients/{id_}/labels/{label}\",\n        )\n\n    def get_patients_id_media(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Synchronously create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/media\",\n            params=params,\n        )\n\n    def post_patients_id_media(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/media\",\n            json=json,\n        )\n\n    def get_patients_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List metadata\n\n        Get the list of metadata that are associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/metadata\",\n            params=params,\n        )\n\n    def delete_patients_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete metadata\n\n        Delete some metadata associated with the given DICOM patient. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def get_patients_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get metadata\n\n        Get the value of a metadata that is associated with the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def put_patients_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set metadata\n\n        Set the value of some metadata in the given DICOM patient. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Patients\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the patient of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    def post_patients_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Modify patient\n\n        Start a job that will modify all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/modify\",\n            json=json,\n        )\n\n    def get_patients_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get patient module\n\n        Get the patient module of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM patient\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/module\",\n            params=params,\n        )\n\n    def get_patients_id_protected(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Is the patient protected against recycling?\n\n        Is the patient protected against recycling?\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `1` if protected, `0` if not protected\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/protected\",\n        )\n\n    def put_patients_id_protected(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Protect/Unprotect a patient against recycling\n\n        Protects a patient by sending `1` or `true` in the payload request. Unprotects a patient by sending `0` or `false` in the payload requests. More info: https://orthanc.uclouvain.be/book/faq/features.html#recycling-protection\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/patients/{id_}/protected\",\n        )\n\n    def post_patients_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Reconstruct tags &amp; optionally files of patient\n\n        Reconstruct the main DICOM tags in DB of the patient whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/patients/{id_}/reconstruct\",\n            json=json,\n        )\n\n    def get_patients_id_series(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get child series\n\n        Get detailed information about the child series of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child series\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM series\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/series\",\n            params=params,\n        )\n\n    def get_patients_id_shared_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get shared tags\n\n        Extract the DICOM tags whose value is constant across all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the values of the DICOM tags\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/shared-tags\",\n            params=params,\n        )\n\n    def get_patients_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get patient statistics\n\n        Get statistics about the given patient\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/statistics\",\n        )\n\n    def get_patients_id_studies(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get child studies\n\n        Get detailed information about the child studies of the DICOM patient whose Orthanc identifier is provided in the URL\n        Tags: Patients\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the patient of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child studies\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM studies\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/patients/{id_}/studies\",\n            params=params,\n        )\n\n    def get_peers(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List Orthanc peers\n\n        List all the Orthanc peers that are known to Orthanc. This corresponds either to the content of the `OrthancPeers` configuration option, or to the information stored in the database if `OrthancPeersInDatabase` is `true`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual Orthanc peers\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the identifiers of the peers, or detailed information about the peers (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/peers\",\n            params=params,\n        )\n\n    def delete_peers_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete Orthanc peer\n\n        Delete one Orthanc peer. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the Orthanc peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/peers/{id_}\",\n        )\n\n    def get_peers_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on peer\n\n        List the operations that are available for an Orthanc peer.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/peers/{id_}\",\n        )\n\n    def put_peers_id(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Update Orthanc peer\n\n        Define a new Orthanc peer, or update an existing one. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the new/updated Orthanc peer\n        json\n            Dictionary with the following keys:\n              \"CertificateFile\": SSL certificate for the HTTPS connections\n              \"CertificateKeyFile\": Key file for the SSL certificate for the HTTPS connections\n              \"CertificateKeyPassword\": Key password for the SSL certificate for the HTTPS connections\n              \"HttpHeaders\": HTTP headers to be used for the connections to the remote peer\n              \"Password\": Password for the credentials\n              \"URL\": URL of the root of the REST API of the remote Orthanc peer, for instance `http://localhost:8042/`\n              \"Username\": Username for the credentials\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._put(\n            route=f\"{self.url}/peers/{id_}\",\n            json=json,\n        )\n\n    def get_peers_id_configuration(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get peer configuration\n\n        Get detailed information about the configuration of some Orthanc peer\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Configuration of the peer\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/peers/{id_}/configuration\",\n        )\n\n    def post_peers_id_store(\n        self,\n        id_: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Send to Orthanc peer\n\n        Send DICOM resources stored locally to some remote Orthanc peer whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#sending-one-resource\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Compress\": Whether to compress the DICOM instances using gzip before the actual sending\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode to the provided DICOM transfer syntax before the actual sending\n\n        data\n            The Orthanc identifier of one resource to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/peers/{id_}/store\",\n            data=data,\n            json=json,\n        )\n\n    def post_peers_id_store_straight(\n        self,\n        id_: str,\n        content: RequestContent = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Straight store to peer\n\n        Synchronously send the DICOM instance in the POST body to the Orthanc peer whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `curl`.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the modality of interest\n        content\n                - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/peers/{id_}/store-straight\",\n            content=content,\n        )\n\n    def get_peers_id_system(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get peer system information\n\n        Get system information about some Orthanc peer. This corresponds to doing a `GET` request against the `/system` URI of the remote peer. This route can be used to test connectivity.\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the peer of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            System information about the peer\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/peers/{id_}/system\",\n        )\n\n    def get_plugins(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List plugins\n\n        List all the installed plugins\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the identifiers of the installed plugins\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/plugins\",\n        )\n\n    def get_plugins_explorer_js(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"JavaScript extensions to Orthanc Explorer\n\n        Get the JavaScript extensions that are installed by all the plugins using the `OrthancPluginExtendOrthancExplorer()` function of the plugin SDK. This route is for internal use of Orthanc Explorer.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The JavaScript extensions\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/plugins/explorer.js\",\n        )\n\n    def get_plugins_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get plugin\n\n        Get system information about the plugin whose identifier is provided in the URL\n        Tags: System\n\n        Parameters\n        ----------\n        id_\n            Identifier of the job of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing information about the plugin\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/plugins/{id_}\",\n        )\n\n    def get_queries(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List query/retrieve operations\n\n        List the identifiers of all the query/retrieve operations on DICOM modalities, as initiated by calls to `/modalities/{id}/query`. The length of this list is bounded by the `QueryRetrieveSize` configuration option of Orthanc. https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n        Tags: Networking\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the identifiers\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries\",\n        )\n\n    def delete_queries_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete a query\n\n        Delete the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/queries/{id_}\",\n        )\n\n    def get_queries_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on a query\n\n        List the available operations for the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the list of operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries/{id_}\",\n        )\n\n    def get_queries_id_answers(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List answers to a query\n\n        List the indices of all the available answers resulting from a query/retrieve operation on some DICOM modality, whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual answers\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the indices of the answers, or detailed information about the reported answers (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries/{id_}/answers\",\n            params=params,\n        )\n\n    def get_queries_id_answers_index(\n        self,\n        id_: str,\n        index: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on an answer\n\n        List the available operations on an answer associated with the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the list of operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries/{id_}/answers/{index}\",\n        )\n\n    def get_queries_id_answers_index_content(\n        self,\n        id_: str,\n        index: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get one answer\n\n        Get the content (DICOM tags) of one answer associated with the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the DICOM tags of the answer\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/content\",\n            params=params,\n        )\n\n    def post_queries_id_answers_index_query_instances(\n        self,\n        id_: str,\n        index: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Query the child instances of an answer\n\n        Issue a second DICOM C-FIND operation, in order to query the child instances associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/query-instances\",\n            json=json,\n        )\n\n    def post_queries_id_answers_index_query_series(\n        self,\n        id_: str,\n        index: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Query the child series of an answer\n\n        Issue a second DICOM C-FIND operation, in order to query the child series associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/query-series\",\n            json=json,\n        )\n\n    def post_queries_id_answers_index_query_studies(\n        self,\n        id_: str,\n        index: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Query the child studies of an answer\n\n        Issue a second DICOM C-FIND operation, in order to query the child studies associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/query-studies\",\n            json=json,\n        )\n\n    def post_queries_id_answers_index_retrieve(\n        self,\n        id_: str,\n        index: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Retrieve one answer with a C-MOVE or a C-GET SCU\n\n        Start a C-MOVE or a C-GET SCU command as a job, in order to retrieve one answer associated with the query/retrieve operation whose identifiers are provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n        Tags: Networking\n\n        Parameters\n        ----------\n        index\n            Index of the answer\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n              \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n              \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n        data\n            AET of the target modality\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/queries/{id_}/answers/{index}/retrieve\",\n            data=data,\n            json=json,\n        )\n\n    def get_queries_id_level(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get level of original query\n\n        Get the query level (value of the `QueryRetrieveLevel` tag) of the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The level\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries/{id_}/level\",\n        )\n\n    def get_queries_id_modality(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get modality of original query\n\n        Get the identifier of the DICOM modality that was targeted by the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The identifier of the DICOM modality\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries/{id_}/modality\",\n        )\n\n    def get_queries_id_query(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get original query arguments\n\n        Get the original DICOM filter associated with the query/retrieve operation whose identifier is provided in the URL\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Content of the original query\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/queries/{id_}/query\",\n            params=params,\n        )\n\n    def post_queries_id_retrieve(\n        self,\n        id_: str,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Retrieve all answers with C-MOVE SCU\n\n        Start a C-MOVE SCU command as a job, in order to retrieve all the answers associated with the query/retrieve operation whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the query of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n              \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n              \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n        data\n            AET of the target modality\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/queries/{id_}/retrieve\",\n            data=data,\n            json=json,\n        )\n\n    def get_series(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List the available series\n\n        List the Orthanc identifiers of all the available DICOM series\n        Tags: Series\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported series (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series\",\n            params=params,\n        )\n\n    def delete_series_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete some series\n\n        Delete the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/series/{id_}\",\n        )\n\n    def get_series_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get information about some series\n\n        Get detailed information about the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM series\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}\",\n            params=params,\n        )\n\n    def post_series_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Anonymize series\n\n        Start a job that will anonymize all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/series/{id_}/anonymize\",\n            json=json,\n        )\n\n    def get_series_id_archive(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Synchronously create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/archive\",\n            params=params,\n        )\n\n    def post_series_id_archive(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/series/{id_}/archive\",\n            json=json,\n        )\n\n    def get_series_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List attachments\n\n        Get the list of attachments that are associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments\",\n            params=params,\n        )\n\n    def delete_series_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete attachment\n\n        Delete an attachment associated with the given DICOM series. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/series/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given series\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def put_series_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set attachment\n\n        Attach a file to the given DICOM series. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/series/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    def post_series_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compress\",\n        )\n\n    def get_series_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given series. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given series, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment on disk\n\n        Get the size of one attachment associated with the given series, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment\n\n        Get the (binary) content of one attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get info about the attachment\n\n        Get all the information about the attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    def get_series_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment\n\n        Get the size of one attachment associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    def post_series_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/uncompress\",\n        )\n\n    def post_series_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/series/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    def get_series_id_instances(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get child instances\n\n        Get detailed information about the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child instances\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM instances\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/instances\",\n            params=params,\n        )\n\n    def get_series_id_instances_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get tags of instances\n\n        Get the tags of all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/instances-tags\",\n            params=params,\n        )\n\n    def get_series_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List labels\n\n        Get the labels that are associated with the given series (new in Orthanc 1.12.0)\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/labels\",\n        )\n\n    def delete_series_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Remove label\n\n        Remove a label associated with a series\n        Tags: Series\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/series/{id_}/labels/{label}\",\n        )\n\n    def get_series_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Test label\n\n        Test whether the series is associated with the given label\n        Tags: Series\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/labels/{label}\",\n        )\n\n    def put_series_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Add label\n\n        Associate a label with a series\n        Tags: Series\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/series/{id_}/labels/{label}\",\n        )\n\n    def get_series_id_media(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Synchronously create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/media\",\n            params=params,\n        )\n\n    def post_series_id_media(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/series/{id_}/media\",\n            json=json,\n        )\n\n    def get_series_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List metadata\n\n        Get the list of metadata that are associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/metadata\",\n            params=params,\n        )\n\n    def delete_series_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete metadata\n\n        Delete some metadata associated with the given DICOM series. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/series/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def get_series_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get metadata\n\n        Get the value of a metadata that is associated with the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def put_series_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set metadata\n\n        Set the value of some metadata in the given DICOM series. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Series\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the series of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/series/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    def post_series_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Modify series\n\n        Start a job that will modify all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/series/{id_}/modify\",\n            json=json,\n        )\n\n    def get_series_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get series module\n\n        Get the series module of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM series\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/module\",\n            params=params,\n        )\n\n    def get_series_id_numpy(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Decode series for numpy\n\n        Decode the given DICOM series, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the DICOM resource of interest\n        params\n            Dictionary of optional parameters:\n                \"compress\" (bool): Compress the file as `.npz`\n                \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/numpy\",\n            params=params,\n        )\n\n    def get_series_id_ordered_slices(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Order the slices\n\n        Sort the instances and frames (slices) of the DICOM series whose Orthanc identifier is provided in the URL. This URI is essentially used by the Orthanc Web viewer and by the Osimis Web viewer.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n        return self._get(\n            route=f\"{self.url}/series/{id_}/ordered-slices\",\n        )\n\n    def get_series_id_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get parent patient\n\n        Get detailed information about the parent patient of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM patient\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/patient\",\n            params=params,\n        )\n\n    def post_series_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Reconstruct tags &amp; optionally files of series\n\n        Reconstruct the main DICOM tags in DB of the series whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/series/{id_}/reconstruct\",\n            json=json,\n        )\n\n    def get_series_id_shared_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get shared tags\n\n        Extract the DICOM tags whose value is constant across all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the values of the DICOM tags\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/shared-tags\",\n            params=params,\n        )\n\n    def get_series_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get series statistics\n\n        Get statistics about the given series\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/statistics\",\n        )\n\n    def get_series_id_study(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get parent study\n\n        Get detailed information about the parent study of the DICOM series whose Orthanc identifier is provided in the URL\n        Tags: Series\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the series of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM study\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/series/{id_}/study\",\n            params=params,\n        )\n\n    def get_statistics(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get database statistics\n\n        Get statistics related to the database of Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/statistics\",\n        )\n\n    def get_storage_commitment_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get storage commitment report\n\n        Get the storage commitment report whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the storage commitment report\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/storage-commitment/{id_}\",\n        )\n\n    def post_storage_commitment_id_remove(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Remove after storage commitment\n\n        Remove out of Orthanc, the DICOM instances that have been reported to have been properly received the storage commitment report whose identifier is provided in the URL. This is only possible if the `Status` of the storage commitment report is `Success`. https://orthanc.uclouvain.be/book/users/storage-commitment.html#removing-the-instances\n        Tags: Networking\n\n        Parameters\n        ----------\n        id_\n            Identifier of the storage commitment report\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/storage-commitment/{id_}/remove\",\n        )\n\n    def get_studies(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List the available studies\n\n        List the Orthanc identifiers of all the available DICOM studies\n        Tags: Studies\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"limit\" (float): Limit the number of results\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"since\" (float): Show only the resources since the provided index\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported studies (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies\",\n            params=params,\n        )\n\n    def delete_studies_id(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete some study\n\n        Delete the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/studies/{id_}\",\n        )\n\n    def get_studies_id(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get information about some study\n\n        Get detailed information about the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM study\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}\",\n            params=params,\n        )\n\n    def post_studies_id_anonymize(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Anonymize study\n\n        Start a job that will anonymize all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/anonymize\",\n            json=json,\n        )\n\n    def get_studies_id_archive(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Synchronously create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/archive\",\n            params=params,\n        )\n\n    def post_studies_id_archive(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/archive\",\n            json=json,\n        )\n\n    def get_studies_id_attachments(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List attachments\n\n        Get the list of attachments that are associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the attachments\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments\",\n            params=params,\n        )\n\n    def delete_studies_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete attachment\n\n        Delete an attachment associated with the given DICOM study. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations on attachments\n\n        Get the list of the operations that are available for attachments associated with the given study\n        Tags: Other\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n            headers=headers,\n        )\n\n    def put_studies_id_attachments_name(\n        self,\n        id_: str,\n        name: str,\n        content: RequestContent = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set attachment\n\n        Attach a file to the given DICOM study. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        content\n                - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty JSON object in the case of a success\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n            content=content,\n            headers=headers,\n        )\n\n    def post_studies_id_attachments_name_compress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Compress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compress\",\n        )\n\n    def get_studies_id_attachments_name_compressed_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment (no decompression)\n\n        Get the (binary) content of one attachment associated with the given study. The attachment will not be decompressed if `StorageCompression` is `true`.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-data\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name_compressed_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment on disk\n\n        Get the MD5 hash of one attachment associated with the given study, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-md5\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name_compressed_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment on disk\n\n        Get the size of one attachment associated with the given study, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment, as stored on the disk\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-size\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name_data(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get attachment\n\n        Get the (binary) content of one attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/data\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name_info(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get info about the attachment\n\n        Get all the information about the attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the information about the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/info\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name_is_compressed(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Is attachment compressed?\n\n        Test whether the attachment has been stored as a compressed file on the disk.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `0` if the attachment was stored uncompressed, `1` if it was compressed\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/is-compressed\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name_md5(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get MD5 of attachment\n\n        Get the MD5 hash of one attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The MD5 of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/md5\",\n            headers=headers,\n        )\n\n    def get_studies_id_attachments_name_size(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get size of attachment\n\n        Get the size of one attachment associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The size of the attachment\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/size\",\n            headers=headers,\n        )\n\n    def post_studies_id_attachments_name_uncompress(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Uncompress attachment\n\n        Change the compression scheme that is used to store an attachment.\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/uncompress\",\n        )\n\n    def post_studies_id_attachments_name_verify_md5(\n        self,\n        id_: str,\n        name: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Verify attachment\n\n        Verify that the attachment is not corrupted, by validating its MD5 hash\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the attachment, or its index (cf. `UserContentType` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            On success, a valid JSON object is returned\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/attachments/{name}/verify-md5\",\n        )\n\n    def get_studies_id_instances(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get child instances\n\n        Get detailed information about the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child instances\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM instances\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/instances\",\n            params=params,\n        )\n\n    def get_studies_id_instances_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get tags of instances\n\n        Get the tags of all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/instances-tags\",\n            params=params,\n        )\n\n    def get_studies_id_labels(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List labels\n\n        Get the labels that are associated with the given study (new in Orthanc 1.12.0)\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the labels\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/labels\",\n        )\n\n    def delete_studies_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Remove label\n\n        Remove a label associated with a study\n        Tags: Studies\n\n        Parameters\n        ----------\n        label\n            The label to be removed\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/studies/{id_}/labels/{label}\",\n        )\n\n    def get_studies_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Test label\n\n        Test whether the study is associated with the given label\n        Tags: Studies\n\n        Parameters\n        ----------\n        label\n            The label of interest\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Empty string is returned in the case of presence, error 404 in the case of absence\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/labels/{label}\",\n        )\n\n    def put_studies_id_labels_label(\n        self,\n        id_: str,\n        label: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Add label\n\n        Associate a label with a study\n        Tags: Studies\n\n        Parameters\n        ----------\n        label\n            The label to be added\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/studies/{id_}/labels/{label}\",\n        )\n\n    def get_studies_id_media(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Synchronously create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n                \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n                \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            ZIP file containing the archive\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/media\",\n            params=params,\n        )\n\n    def post_studies_id_media(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/media\",\n            json=json,\n        )\n\n    def post_studies_id_merge(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Merge study\n\n        Start a new job so as to move some DICOM resources into the DICOM study whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#merging\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original resources in their source study. By default, the original resources are deleted from Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of DICOM resources (studies, series, and/or instances) to be merged into the study of interest (mandatory option)\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/merge\",\n            json=json,\n        )\n\n    def get_studies_id_metadata(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List metadata\n\n        Get the list of metadata that are associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If present, also retrieve the value of the individual metadata\n                \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/metadata\",\n            params=params,\n        )\n\n    def delete_studies_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete metadata\n\n        Delete some metadata associated with the given DICOM study. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._delete(\n            route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def get_studies_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get metadata\n\n        Get the value of a metadata that is associated with the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        headers\n            Dictionary of optional headers:\n                \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Value of the metadata\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n            headers=headers,\n        )\n\n    def put_studies_id_metadata_name(\n        self,\n        id_: str,\n        name: str,\n        data: RequestData = None,\n        headers: HeaderTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set metadata\n\n        Set the value of some metadata in the given DICOM study. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n        Tags: Studies\n\n        Parameters\n        ----------\n        name\n            The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n        id_\n            Orthanc identifier of the study of interest\n        data\n            String value of the metadata\n        headers\n            Dictionary of optional headers:\n                \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n            data=data,\n            headers=headers,\n        )\n\n    def post_studies_id_modify(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Modify study\n\n        Start a job that will modify all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/modify\",\n            json=json,\n        )\n\n    def get_studies_id_module(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get study module\n\n        Get the study module of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM study\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/module\",\n            params=params,\n        )\n\n    def get_studies_id_module_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get patient module of study\n\n        Get the patient module of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the DICOM study\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/module-patient\",\n            params=params,\n        )\n\n    def get_studies_id_patient(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get parent patient\n\n        Get detailed information about the parent patient of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Information about the parent DICOM patient\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/patient\",\n            params=params,\n        )\n\n    def post_studies_id_reconstruct(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Reconstruct tags &amp; optionally files of study\n\n        Reconstruct the main DICOM tags in DB of the study whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/reconstruct\",\n            json=json,\n        )\n\n    def get_studies_id_series(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get child series\n\n        Get detailed information about the child series of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"expand\" (str): If false or missing, only retrieve the list of child series\n                \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n                \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing information about the child DICOM series\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/series\",\n            params=params,\n        )\n\n    def get_studies_id_shared_tags(\n        self,\n        id_: str,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get shared tags\n\n        Extract the DICOM tags whose value is constant across all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        params\n            Dictionary of optional parameters:\n                \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n                \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON object containing the values of the DICOM tags\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/shared-tags\",\n            params=params,\n        )\n\n    def post_studies_id_split(\n        self,\n        id_: str,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Split study\n\n        Start a new job so as to split the DICOM study whose Orthanc identifier is provided in the URL, by taking some of its children series or instances out of it and putting them into a brand new study (this new study is created by setting the `StudyInstanceUID` tag to a random identifier): https://orthanc.uclouvain.be/book/users/anonymization.html#splitting\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Instances\": The list of instances to be separated from the parent study. These instances must all be children of the same source study, that is specified in the URI.\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original series/instances in the source study. By default, the original series/instances are deleted from Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Remove\": List of tags that must be removed in the new study (from the same modules as in the `Replace` option)\n              \"Replace\": Associative array to change the value of some DICOM tags in the new study. These tags must be part of the \"Patient Module Attributes\" or the \"General Study Module Attributes\", as specified by the DICOM 2011 standard in Tables C.7-1 and C.7-3.\n              \"Series\": The list of series to be separated from the parent study. These series must all be children of the same source study, that is specified in the URI.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/studies/{id_}/split\",\n            json=json,\n        )\n\n    def get_studies_id_statistics(\n        self,\n        id_: str,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get study statistics\n\n        Get statistics about the given study\n        Tags: Studies\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the study of interest\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/studies/{id_}/statistics\",\n        )\n\n    def get_system(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get system information\n\n        Get system information about Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/system\",\n        )\n\n    def get_tools(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"List operations\n\n        List the available operations under URI `/tools/`\n        Tags: Other\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            List of the available operations\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools\",\n        )\n\n    def get_tools_accepted_sop_classes(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get accepted SOPClassUID\n\n        Get the list of SOP Class UIDs that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedSopClasses` and `RejectedSopClasses`.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the SOP Class UIDs\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/accepted-sop-classes\",\n        )\n\n    def get_tools_accepted_transfer_syntaxes(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get accepted transfer syntaxes\n\n        Get the list of UIDs of the DICOM transfer syntaxes that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedTransferSyntaxes` and `XXXTransferSyntaxAccepted`.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the transfer syntax UIDs\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n        )\n\n    def put_tools_accepted_transfer_syntaxes(\n        self,\n        data: RequestData = None,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set accepted transfer syntaxes\n\n        Set the DICOM transfer syntaxes that accepted by Orthanc C-STORE SCP\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n\n        data\n            UID of the transfer syntax to be accepted. Wildcards `?` and `*` are accepted.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the now-accepted transfer syntax UIDs\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._put(\n            route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n            data=data,\n            json=json,\n        )\n\n    def post_tools_bulk_anonymize(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Anonymize a set of resources\n\n        Start a job that will anonymize all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n              \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of all the resources that have been created by this anonymization\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/bulk-anonymize\",\n            json=json,\n        )\n\n    def post_tools_bulk_content(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Describe a set of resources\n\n        Get the content all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field, in one single call.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Level\": This optional argument specifies the level of interest (can be `Patient`, `Study`, `Series` or `Instance`). Orthanc will loop over the items inside `Resources`, and explore upward or downward in the DICOM hierarchy in order to find the level of interest.\n              \"Metadata\": If set to `true` (default value), the metadata associated with the resources will also be retrieved.\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/bulk-content\",\n            json=json,\n        )\n\n    def post_tools_bulk_delete(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Delete a set of resources\n\n        Delete all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/bulk-delete\",\n            json=json,\n        )\n\n    def post_tools_bulk_modify(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Modify a set of resources\n\n        Start a job that will modify all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n              \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n              \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n              \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n              \"Level\": Level of the modification (`Patient`, `Study`, `Series` or `Instance`). If absent, the level defaults to `Instance`, but is set to `Patient` if `PatientID` is modified, to `Study` if `StudyInstanceUID` is modified, or to `Series` if `SeriesInstancesUID` is modified. (new in Orthanc 1.9.7)\n              \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n              \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n              \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n              \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n              \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n              \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The list of all the resources that have been altered by this modification\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/bulk-modify\",\n            json=json,\n        )\n\n    def post_tools_count_resources(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Count local resources\n\n        This URI can be used to count the resources that are matching criteria on the content of the local Orthanc server, in a way that is similar to tools/find\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n              \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n              \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n              \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n              \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            A JSON object with the `Count` of matching resources\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/count-resources\",\n            json=json,\n        )\n\n    def get_tools_create_archive(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the ZIP archive.\n                \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/create-archive\",\n            params=params,\n        )\n\n    def post_tools_create_archive(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create ZIP archive\n\n        Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of Orthanc identifiers of interest.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/create-archive\",\n            json=json,\n        )\n\n    def post_tools_create_dicom(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create one DICOM instance\n\n        Create one DICOM instance, and store it into Orthanc\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Content\": This field can be used to embed an image (pixel data encoded as PNG or JPEG), a PDF, or a 3D manufactoring model (MTL/OBJ/STL) inside the created DICOM instance. The file to be encapsulated must be provided using its [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme). This field can possibly contain a JSON array, in which case a DICOM series is created containing one DICOM instance for each item in the `Content` field.\n              \"Force\": Avoid the consistency checks for the DICOM tags that enforce the DICOM model of the real-world. You can notably use this flag if you need to manually set the tags `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`. Be careful with this feature.\n              \"InterpretBinaryTags\": If some value in the `Tags` associative array is formatted according to some [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme), whether this value is decoded to a binary value or kept as such (`true` by default)\n              \"Parent\": If present, the newly created instance will be attached to the parent DICOM resource whose Orthanc identifier is contained in this field. The DICOM tags of the parent modules in the DICOM hierarchy will be automatically copied to the newly created instance.\n              \"PrivateCreator\": The private creator to be used for private tags in `Tags`\n              \"Tags\": Associative array containing the tags of the new instance to be created\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/create-dicom\",\n            json=json,\n        )\n\n    def get_tools_create_media(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n                \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/create-media\",\n            params=params,\n        )\n\n    def post_tools_create_media(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of Orthanc identifiers of interest.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/create-media\",\n            json=json,\n        )\n\n    def get_tools_create_media_extended(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n                \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/create-media-extended\",\n            params=params,\n        )\n\n    def post_tools_create_media_extended(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Create DICOMDIR media\n\n        Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n              \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `true`.\n              \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n              \"Resources\": The list of Orthanc identifiers of interest.\n              \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n              \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n            In synchronous mode, the ZIP file containing the archive\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/create-media-extended\",\n            json=json,\n        )\n\n    def get_tools_default_encoding(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get default encoding\n\n        Get the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The name of the encoding\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/default-encoding\",\n        )\n\n    def put_tools_default_encoding(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set default encoding\n\n        Change the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            The name of the encoding. Check out configuration option `DefaultEncoding` for the allowed values.\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/default-encoding\",\n            data=data,\n        )\n\n    def get_tools_dicom_conformance(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get DICOM conformance\n\n        Get the DICOM conformance statement of Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The DICOM conformance statement\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/dicom-conformance\",\n        )\n\n    def post_tools_dicom_echo(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Trigger C-ECHO SCU\n\n        Trigger C-ECHO SCU command against a DICOM modality described in the POST body, without having to register the modality in some `/modalities/{id}` (new in Orthanc 1.8.1)\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"AET\": AET of the remote DICOM modality\n              \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n              \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n              \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n              \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n              \"Port\": TCP port of the remote DICOM modality\n              \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n              \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/dicom-echo\",\n            json=json,\n        )\n\n    def post_tools_execute_script(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Execute Lua script\n\n        Execute the provided Lua script by the Orthanc server. This is very insecure for Orthanc servers that are remotely accessible.  Since Orthanc 1.5.8, this route is disabled by default and can be enabled thanks to the `ExecuteLuaEnabled` configuration.\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            The Lua script to be executed\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Output of the Lua script\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/tools/execute-script\",\n            data=data,\n        )\n\n    def post_tools_find(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Look for local resources\n\n        This URI can be used to perform a search on the content of the local Orthanc server, in a way that is similar to querying remote DICOM modalities using C-FIND SCU: https://orthanc.uclouvain.be/book/users/rest.html#performing-finds-within-orthanc\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"CaseSensitive\": Enable case-sensitive search for PN value representations (defaults to configuration option `CaseSensitivePN`)\n              \"Expand\": If set to \"true\", retrieve detailed information about the individual resources, not only their Orthanc identifiers\n              \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n              \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n              \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n              \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n              \"Limit\": Limit the number of reported resources\n              \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n              \"OrderBy\": Array of associative arrays containing the requested ordering (new in Orthanc 1.12.5)\n              \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n              \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n              \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n              \"Query\": Associative array containing the filter on the values of the DICOM tags\n              \"RequestedTags\": A list of DICOM tags to include in the response (applicable only if \"Expand\" is set to true).  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n              \"ResponseContent\": Defines the content of response for each returned resource. (this field, if present, overrides the \"Expand\" field).  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.(new in Orthanc 1.12.5)\n              \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n              \"Since\": Show only the resources since the provided index (in conjunction with `Limit`)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing either the Orthanc identifiers, or detailed information about the reported resources (if `Expand` argument is `true`)\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/find\",\n            json=json,\n        )\n\n    def get_tools_generate_uid(\n        self,\n        params: QueryParamTypes = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Generate an identifier\n\n        Generate a random DICOM identifier\n        Tags: System\n\n        Parameters\n        ----------\n        params\n            Dictionary of optional parameters:\n                \"level\" (str): Type of DICOM resource among: `patient`, `study`, `series` or `instance`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The generated identifier\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/generate-uid_\",\n            params=params,\n        )\n\n    def post_tools_invalid_ate_tags(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Invalidate DICOM-as-JSON summaries\n\n        Remove all the attachments of the type \"DICOM-as-JSON\" that are associated will all the DICOM instances stored in Orthanc. These summaries will be automatically re-created on the next access. This is notably useful after changes to the `Dictionary` configuration option. https://orthanc.uclouvain.be/book/faq/orthanc-storage.html#storage-area\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/tools/invalid_ate-tags\",\n        )\n\n    def get_tools_labels(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get all the used labels\n\n        List all the labels that are associated with any resource of the Orthanc database\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing the labels\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/labels\",\n        )\n\n    def get_tools_log_level(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get main log level\n\n        Get the main log level of Orthanc\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level\",\n        )\n\n    def put_tools_log_level(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set main log level\n\n        Set the main log level of Orthanc\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level\",\n            data=data,\n        )\n\n    def get_tools_log_level_dicom(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get log level for `dicom`\n\n        Get the log level of the log category `dicom`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level-dicom\",\n        )\n\n    def put_tools_log_level_dicom(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set log level for `dicom`\n\n        Set the log level of the log category `dicom`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level-dicom\",\n            data=data,\n        )\n\n    def get_tools_log_level_generic(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get log level for `generic`\n\n        Get the log level of the log category `generic`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level-generic\",\n        )\n\n    def put_tools_log_level_generic(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set log level for `generic`\n\n        Set the log level of the log category `generic`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level-generic\",\n            data=data,\n        )\n\n    def get_tools_log_level_http(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get log level for `http`\n\n        Get the log level of the log category `http`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level-http\",\n        )\n\n    def put_tools_log_level_http(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set log level for `http`\n\n        Set the log level of the log category `http`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level-http\",\n            data=data,\n        )\n\n    def get_tools_log_level_jobs(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get log level for `jobs`\n\n        Get the log level of the log category `jobs`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level-jobs\",\n        )\n\n    def put_tools_log_level_jobs(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set log level for `jobs`\n\n        Set the log level of the log category `jobs`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level-jobs\",\n            data=data,\n        )\n\n    def get_tools_log_level_lua(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get log level for `lua`\n\n        Get the log level of the log category `lua`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level-lua\",\n        )\n\n    def put_tools_log_level_lua(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set log level for `lua`\n\n        Set the log level of the log category `lua`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level-lua\",\n            data=data,\n        )\n\n    def get_tools_log_level_plugins(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get log level for `plugins`\n\n        Get the log level of the log category `plugins`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level-plugins\",\n        )\n\n    def put_tools_log_level_plugins(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set log level for `plugins`\n\n        Set the log level of the log category `plugins`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level-plugins\",\n            data=data,\n        )\n\n    def get_tools_log_level_sqlite(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get log level for `sqlite`\n\n        Get the log level of the log category `sqlite`\n        Tags: Logs\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            Possible values: `default`, `verbose` or `trace`\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/log-level-sqlite\",\n        )\n\n    def put_tools_log_level_sqlite(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set log level for `sqlite`\n\n        Set the log level of the log category `sqlite`\n        Tags: Logs\n\n        Parameters\n        ----------\n        data\n            Possible values: `default`, `verbose` or `trace`\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/log-level-sqlite\",\n            data=data,\n        )\n\n    def post_tools_lookup(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Look for DICOM identifiers\n\n        This URI can be used to convert one DICOM identifier to a list of matching Orthanc resources\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            The DICOM identifier of interest (i.e. the value of `PatientID`, `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`)\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            JSON array containing a list of matching Orthanc resources, each item in the list corresponding to a JSON object with the fields `Type`, `ID` and `Path` identifying one DICOM resource that is stored by Orthanc\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/tools/lookup\",\n            data=data,\n        )\n\n    def get_tools_metrics(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Are metrics collected?\n\n        Returns a Boolean specifying whether Prometheus metrics are collected and exposed at `/tools/metrics-prometheus`\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `1` if metrics are collected, `0` if metrics are disabled\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/metrics\",\n        )\n\n    def put_tools_metrics(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Enable collection of metrics\n\n        Enable or disable the collection and publication of metrics at `/tools/metrics-prometheus`\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            `1` if metrics are collected, `0` if metrics are disabled\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/metrics\",\n            data=data,\n        )\n\n    def get_tools_metrics_prometheus(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get usage metrics\n\n        Get usage metrics of Orthanc in the Prometheus file format (OpenMetrics): https://orthanc.uclouvain.be/book/users/advanced-rest.html#instrumentation-with-prometheus\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            No description\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/metrics-prometheus\",\n        )\n\n    def get_tools_now(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get UTC time\n\n        Get UTC time\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The UTC time\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/now\",\n        )\n\n    def get_tools_now_local(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Get local time\n\n        Get local time\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            The local time\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/now-local\",\n        )\n\n    def post_tools_reconstruct(\n        self,\n        json: Any = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Reconstruct all the index\n\n        Reconstruct the index of all the tags of all the DICOM instances that are stored in Orthanc. This is notably useful after the deletion of resources whose children resources have inconsistent values with their sibling resources. Beware that this is a highly time-consuming operation, as all the DICOM instances will be parsed again, and as all the Orthanc index will be regenerated. If you have a large database to process, it is advised to use the Housekeeper plugin to perform this action resource by resource\n        Tags: System\n\n        Parameters\n        ----------\n        json\n            Dictionary with the following keys:\n              \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        if json is None:\n            json = {}\n        return self._post(\n            route=f\"{self.url}/tools/reconstruct\",\n            json=json,\n        )\n\n    def post_tools_reset(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Restart Orthanc\n\n        Restart Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/tools/reset\",\n        )\n\n    def post_tools_shutdown(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Shutdown Orthanc\n\n        Shutdown Orthanc\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._post(\n            route=f\"{self.url}/tools/shutdown\",\n        )\n\n    def get_tools_unknown_sop_class_accepted(\n        self,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Is unknown SOP class accepted?\n\n        Shall Orthanc C-STORE SCP accept DICOM instances with an unknown SOP class UID?\n        Tags: System\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n            `1` if accepted, `0` if not accepted\n        \"\"\"\n        return self._get(\n            route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n        )\n\n    def put_tools_unknown_sop_class_accepted(\n        self,\n        data: RequestData = None,\n    ) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n        \"\"\"Set unknown SOP class accepted\n\n        Set whether Orthanc C-STORE SCP should accept DICOM instances with an unknown SOP class UID\n        Tags: System\n\n        Parameters\n        ----------\n        data\n            `1` if accepted, `0` if not accepted\n\n        Returns\n        -------\n        Union[Dict, List, str, bytes, int, httpx.Response]\n        \"\"\"\n        return self._put(\n            route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n            data=data,\n        )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.__init__","title":"<code>__init__(url, username=None, password=None, return_raw_response=False, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>server's URL</p> required <code>username</code> <code>Optional[str]</code> <p>Orthanc's username</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Orthanc's password</p> <code>None</code> <code>return_raw_response</code> <code>bool</code> <p>All Orthanc's methods will return a raw httpx.Response rather than the serialized result</p> <code>False</code> <code>*args</code> <p>Parameters passed to the httpx.Client (headers, timeout, etc.)</p> <code>()</code> <code>**kwargs</code> <p>Parameters passed to the httpx.Client (headers, timeout, etc.)</p> <code>()</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    return_raw_response: bool = False,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Parameters\n    ----------\n    url\n        server's URL\n    username\n        Orthanc's username\n    password\n        Orthanc's password\n    return_raw_response\n        All Orthanc's methods will return a raw httpx.Response rather than the serialized result\n    *args, **kwargs\n        Parameters passed to the httpx.Client (headers, timeout, etc.)\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.url = url\n    self.version = \"1.12.6\"\n    self.return_raw_response = return_raw_response\n\n    if username and password:\n        self.setup_credentials(username, password)\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_changes","title":"<code>delete_changes()</code>","text":"<p>Clear changes</p> <p>Clear the full history stored in the changes log Tags: Tracking changes</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_changes(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Clear changes\n\n    Clear the full history stored in the changes log\n    Tags: Tracking changes\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/changes\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_exports","title":"<code>delete_exports()</code>","text":"<p>Clear exports</p> <p>Clear the full history stored in the exports log Tags: Tracking changes</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_exports(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Clear exports\n\n    Clear the full history stored in the exports log\n    Tags: Tracking changes\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/exports\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_instances_id","title":"<code>delete_instances_id(id_)</code>","text":"<p>Delete some instance</p> <p>Delete the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_instances_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete some instance\n\n    Delete the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/instances/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_instances_id_attachments_name","title":"<code>delete_instances_id_attachments_name(id_, name, headers=None)</code>","text":"<p>Delete attachment</p> <p>Delete an attachment associated with the given DICOM instance. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_instances_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete attachment\n\n    Delete an attachment associated with the given DICOM instance. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_instances_id_labels_label","title":"<code>delete_instances_id_labels_label(id_, label)</code>","text":"<p>Remove label</p> <p>Remove a label associated with a instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_instances_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Remove label\n\n    Remove a label associated with a instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/instances/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_instances_id_metadata_name","title":"<code>delete_instances_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Delete metadata</p> <p>Delete some metadata associated with the given DICOM instance. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_instances_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete metadata\n\n    Delete some metadata associated with the given DICOM instance. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_jobs_id","title":"<code>delete_jobs_id(id_)</code>","text":"<p>Delete a job from history</p> <p>Delete the job from the jobs history.  Only a completed job can be deleted. If the job has not run or not completed yet, you must cancel it first. If the job has outputs, all outputs will be deleted as well. Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_jobs_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete a job from history\n\n    Delete the job from the jobs history.  Only a completed job can be deleted. If the job has not run or not completed yet, you must cancel it first. If the job has outputs, all outputs will be deleted as well.\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/jobs/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_jobs_id_key","title":"<code>delete_jobs_id_key(id_, key)</code>","text":"<p>Delete a job output</p> <p>Delete the output produced by a job. As of Orthanc 1.12.1, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with <code>key</code> equals to <code>archive</code>). Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of the output of interest</p> required <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_jobs_id_key(\n    self,\n    id_: str,\n    key: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete a job output\n\n    Delete the output produced by a job. As of Orthanc 1.12.1, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n    Tags: Jobs\n\n    Parameters\n    ----------\n    key\n        Name of the output of interest\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/jobs/{id_}/{key}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_modalities_id","title":"<code>delete_modalities_id(id_)</code>","text":"<p>Delete DICOM modality</p> <p>Delete one DICOM modality. This change is permanent iff. <code>DicomModalitiesInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the DICOM modality of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_modalities_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete DICOM modality\n\n    Delete one DICOM modality. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the DICOM modality of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/modalities/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_patients_id","title":"<code>delete_patients_id(id_)</code>","text":"<p>Delete some patient</p> <p>Delete the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_patients_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete some patient\n\n    Delete the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/patients/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_patients_id_attachments_name","title":"<code>delete_patients_id_attachments_name(id_, name, headers=None)</code>","text":"<p>Delete attachment</p> <p>Delete an attachment associated with the given DICOM patient. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_patients_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete attachment\n\n    Delete an attachment associated with the given DICOM patient. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_patients_id_labels_label","title":"<code>delete_patients_id_labels_label(id_, label)</code>","text":"<p>Remove label</p> <p>Remove a label associated with a patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_patients_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Remove label\n\n    Remove a label associated with a patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/patients/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_patients_id_metadata_name","title":"<code>delete_patients_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Delete metadata</p> <p>Delete some metadata associated with the given DICOM patient. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_patients_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete metadata\n\n    Delete some metadata associated with the given DICOM patient. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_peers_id","title":"<code>delete_peers_id(id_)</code>","text":"<p>Delete Orthanc peer</p> <p>Delete one Orthanc peer. This change is permanent iff. <code>OrthancPeersInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the Orthanc peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_peers_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete Orthanc peer\n\n    Delete one Orthanc peer. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the Orthanc peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/peers/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_queries_id","title":"<code>delete_queries_id(id_)</code>","text":"<p>Delete a query</p> <p>Delete the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_queries_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete a query\n\n    Delete the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/queries/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_series_id","title":"<code>delete_series_id(id_)</code>","text":"<p>Delete some series</p> <p>Delete the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_series_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete some series\n\n    Delete the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/series/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_series_id_attachments_name","title":"<code>delete_series_id_attachments_name(id_, name, headers=None)</code>","text":"<p>Delete attachment</p> <p>Delete an attachment associated with the given DICOM series. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_series_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete attachment\n\n    Delete an attachment associated with the given DICOM series. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/series/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_series_id_labels_label","title":"<code>delete_series_id_labels_label(id_, label)</code>","text":"<p>Remove label</p> <p>Remove a label associated with a series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_series_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Remove label\n\n    Remove a label associated with a series\n    Tags: Series\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/series/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_series_id_metadata_name","title":"<code>delete_series_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Delete metadata</p> <p>Delete some metadata associated with the given DICOM series. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_series_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete metadata\n\n    Delete some metadata associated with the given DICOM series. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/series/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_studies_id","title":"<code>delete_studies_id(id_)</code>","text":"<p>Delete some study</p> <p>Delete the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_studies_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete some study\n\n    Delete the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/studies/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_studies_id_attachments_name","title":"<code>delete_studies_id_attachments_name(id_, name, headers=None)</code>","text":"<p>Delete attachment</p> <p>Delete an attachment associated with the given DICOM study. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_studies_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete attachment\n\n    Delete an attachment associated with the given DICOM study. This call will fail if trying to delete a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_studies_id_labels_label","title":"<code>delete_studies_id_labels_label(id_, label)</code>","text":"<p>Remove label</p> <p>Remove a label associated with a study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be removed</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_studies_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Remove label\n\n    Remove a label associated with a study\n    Tags: Studies\n\n    Parameters\n    ----------\n    label\n        The label to be removed\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/studies/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.delete_studies_id_metadata_name","title":"<code>delete_studies_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Delete metadata</p> <p>Delete some metadata associated with the given DICOM study. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if <code>CheckRevisions</code> option is <code>true</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def delete_studies_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete metadata\n\n    Delete some metadata associated with the given DICOM study. This call will fail if trying to delete a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if `CheckRevisions` option is `true`.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._delete(\n        route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_changes","title":"<code>get_changes(params=None)</code>","text":"<p>List changes</p> <p>Whenever Orthanc receives a new DICOM instance, this event is recorded in the so-called Changes Log. This enables remote scripts to react to the arrival of new DICOM resources. A typical application is auto-routing, where an external script waits for a new DICOM instance to arrive into Orthanc, then forward this instance to another modality. Please note that, when resources are deleted, their corresponding change entries are also removed from the Changes Log, which helps ensuring that this log does not grow indefinitely. Tags: Tracking changes</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"last\" (float): Request only the last change id (this argument must be used alone)     \"limit\" (float): Limit the number of results     \"since\" (float): Show only the resources since the provided index excluded     \"to\" (float): Show only the resources till the provided index included (only available if your DB backend supports ExtendedChanges)     \"type\" (str): Show only the changes of the provided type (only available if your DB backend supports ExtendedChanges).  Multiple values can be provided and must be separated by a ';'.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of changes</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_changes(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List changes\n\n    Whenever Orthanc receives a new DICOM instance, this event is recorded in the so-called _Changes Log_. This enables remote scripts to react to the arrival of new DICOM resources. A typical application is auto-routing, where an external script waits for a new DICOM instance to arrive into Orthanc, then forward this instance to another modality. Please note that, when resources are deleted, their corresponding change entries are also removed from the Changes Log, which helps ensuring that this log does not grow indefinitely.\n    Tags: Tracking changes\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"last\" (float): Request only the last change id (this argument must be used alone)\n            \"limit\" (float): Limit the number of results\n            \"since\" (float): Show only the resources since the provided index excluded\n            \"to\" (float): Show only the resources till the provided index included (only available if your DB backend supports ExtendedChanges)\n            \"type\" (str): Show only the changes of the provided type (only available if your DB backend supports ExtendedChanges).  Multiple values can be provided and must be separated by a ';'.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of changes\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/changes\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_exports","title":"<code>get_exports(params=None)</code>","text":"<p>List exports</p> <p>For medical traceability, Orthanc can be configured to store a log of all the resources that have been exported to remote modalities. In auto-routing scenarios, it is important to prevent this log to grow indefinitely as incoming instances are routed. You can either disable this logging by setting the option <code>LogExportedResources</code> to <code>false</code> in the configuration file, or periodically clear this log by <code>DELETE</code>-ing this URI. This route might be removed in future versions of Orthanc. Tags: Tracking changes</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"limit\" (float): Limit the number of results     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of exports</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_exports(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List exports\n\n    For medical traceability, Orthanc can be configured to store a log of all the resources that have been exported to remote modalities. In auto-routing scenarios, it is important to prevent this log to grow indefinitely as incoming instances are routed. You can either disable this logging by setting the option `LogExportedResources` to `false` in the configuration file, or periodically clear this log by `DELETE`-ing this URI. This route might be removed in future versions of Orthanc.\n    Tags: Tracking changes\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"limit\" (float): Limit the number of results\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of exports\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/exports\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances","title":"<code>get_instances(params=None)</code>","text":"<p>List the available instances</p> <p>List the Orthanc identifiers of all the available DICOM instances Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported instances (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List the available instances\n\n    List the Orthanc identifiers of all the available DICOM instances\n    Tags: Instances\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported instances (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id","title":"<code>get_instances_id(id_, params=None)</code>","text":"<p>Get information about some instance</p> <p>Get detailed information about the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM instance</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get information about some instance\n\n    Get detailed information about the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM instance\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments","title":"<code>get_instances_id_attachments(id_, params=None)</code>","text":"<p>List attachments</p> <p>Get the list of attachments that are associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List attachments\n\n    Get the list of attachments that are associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name","title":"<code>get_instances_id_attachments_name(id_, name, headers=None)</code>","text":"<p>List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given instance Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given instance\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_compressed_data","title":"<code>get_instances_id_attachments_name_compressed_data(id_, name, headers=None)</code>","text":"<p>Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given instance. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given instance. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_compressed_md5","title":"<code>get_instances_id_attachments_name_compressed_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given instance, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given instance, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_compressed_size","title":"<code>get_instances_id_attachments_name_compressed_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given instance, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment on disk\n\n    Get the size of one attachment associated with the given instance, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_data","title":"<code>get_instances_id_attachments_name_data(id_, name, headers=None)</code>","text":"<p>Get attachment</p> <p>Get the (binary) content of one attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment\n\n    Get the (binary) content of one attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_info","title":"<code>get_instances_id_attachments_name_info(id_, name, headers=None)</code>","text":"<p>Get info about the attachment</p> <p>Get all the information about the attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get info about the attachment\n\n    Get all the information about the attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_is_compressed","title":"<code>get_instances_id_attachments_name_is_compressed(id_, name, headers=None)</code>","text":"<p>Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_md5","title":"<code>get_instances_id_attachments_name_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_attachments_name_size","title":"<code>get_instances_id_attachments_name_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment</p> <p>Get the size of one attachment associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment\n\n    Get the size of one attachment associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_content_path","title":"<code>get_instances_id_content_path(id_, path)</code>","text":"<p>Get raw tag</p> <p>Get the raw content of one DICOM tag in the hierarchy of DICOM dataset Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, <code>/0008-1140/1/0008-1150</code></p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The raw value of the tag of intereset (binary data, whose memory layout depends on the underlying transfer syntax), or JSON array containing the list of available tags if accessing a dataset</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_content_path(\n    self,\n    id_: str,\n    path: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get raw tag\n\n    Get the raw content of one DICOM tag in the hierarchy of DICOM dataset\n    Tags: Instances\n\n    Parameters\n    ----------\n    path\n        Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, `/0008-1140/1/0008-1150`\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The raw value of the tag of intereset (binary data, whose memory layout depends on the underlying transfer syntax), or JSON array containing the list of available tags if accessing a dataset\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/content/{path}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_file","title":"<code>get_instances_id_file(id_, params=None, headers=None)</code>","text":"<p>Download DICOM</p> <p>Download one DICOM instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"transcode\" (str): If present, the DICOM file will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): This HTTP header can be set to retrieve the DICOM instance in DICOMweb format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The DICOM instance The DICOM instance, in DICOMweb JSON format The DICOM instance, in DICOMweb XML format</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_file(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Download DICOM\n\n    Download one DICOM instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"transcode\" (str): If present, the DICOM file will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): This HTTP header can be set to retrieve the DICOM instance in DICOMweb format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The DICOM instance\n        The DICOM instance, in DICOMweb JSON format\n        The DICOM instance, in DICOMweb XML format\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/file\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames","title":"<code>get_instances_id_frames(id_)</code>","text":"<p>List available frames</p> <p>List the frames that are available in the DICOM instance of interest Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of the indices of the available frames</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List available frames\n\n    List the frames that are available in the DICOM instance of interest\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of the indices of the available frames\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame","title":"<code>get_instances_id_frames_frame(frame, id_)</code>","text":"<p>List operations</p> <p>List the available operations under URI <code>/instances/{id}/frames/{frame}/</code> Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>str</code> required <code>id_</code> <code>str</code> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame(\n    self,\n    frame: str,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations\n\n    List the available operations under URI `/instances/{id}/frames/{frame}/`\n    Tags: Other\n\n    Parameters\n    ----------\n    frame\n\n    id_\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_image_int16","title":"<code>get_instances_id_frames_frame_image_int16(frame, id_, params=None, headers=None)</code>","text":"<p>Decode a frame (int16)</p> <p>Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_image_int16(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode a frame (int16)\n\n    Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/image-int16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_image_uint16","title":"<code>get_instances_id_frames_frame_image_uint16(frame, id_, params=None, headers=None)</code>","text":"<p>Decode a frame (uint16)</p> <p>Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_image_uint16(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode a frame (uint16)\n\n    Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_image_uint8","title":"<code>get_instances_id_frames_frame_image_uint8(frame, id_, params=None, headers=None)</code>","text":"<p>Decode a frame (uint8)</p> <p>Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_image_uint8(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode a frame (uint8)\n\n    Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/image-uint8\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_matlab","title":"<code>get_instances_id_frames_frame_matlab(frame, id_)</code>","text":"<p>Decode frame for Matlab</p> <p>Decode one frame of interest from the given DICOM instance, and export this frame as a Octave/Matlab matrix to be imported with <code>eval()</code>: https://orthanc.uclouvain.be/book/faq/matlab.html Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Octave/Matlab matrix</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_matlab(\n    self,\n    frame: float,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode frame for Matlab\n\n    Decode one frame of interest from the given DICOM instance, and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Octave/Matlab matrix\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/matlab\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_numpy","title":"<code>get_instances_id_frames_frame_numpy(frame, id_, params=None)</code>","text":"<p>Decode frame for numpy</p> <p>Decode one frame of interest from the given DICOM instance, for use with numpy in Python. The numpy array has 3 dimensions: (height, width, color channel). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM resource of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"compress\" (bool): Compress the file as <code>.npz</code>     \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_numpy(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode frame for numpy\n\n    Decode one frame of interest from the given DICOM instance, for use with numpy in Python. The numpy array has 3 dimensions: (height, width, color channel).\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM resource of interest\n    params\n        Dictionary of optional parameters:\n            \"compress\" (bool): Compress the file as `.npz`\n            \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/numpy\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_preview","title":"<code>get_instances_id_frames_frame_preview(frame, id_, params=None, headers=None)</code>","text":"<p>Decode a frame (preview)</p> <p>Decode one frame of interest from the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_preview(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode a frame (preview)\n\n    Decode one frame of interest from the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/preview\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_raw","title":"<code>get_instances_id_frames_frame_raw(frame, id_)</code>","text":"<p>Access raw frame</p> <p>Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The raw frame</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_raw(\n    self,\n    frame: float,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Access raw frame\n\n    Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The raw frame\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/raw\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_raw_gz","title":"<code>get_instances_id_frames_frame_raw_gz(frame, id_)</code>","text":"<p>Access raw frame (compressed)</p> <p>Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. The image is compressed using gzip Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The raw frame, compressed using gzip</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_raw_gz(\n    self,\n    frame: float,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Access raw frame (compressed)\n\n    Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. The image is compressed using gzip\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The raw frame, compressed using gzip\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/raw.gz\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_frames_frame_rendered","title":"<code>get_instances_id_frames_frame_rendered(frame, id_, params=None, headers=None)</code>","text":"<p>Render a frame</p> <p>Render one frame of interest from the given DICOM instance. This function takes scaling into account (<code>RescaleSlope</code> and <code>RescaleIntercept</code> tags), as well as the default windowing stored in the DICOM file (<code>WindowCenter</code> and <code>WindowWidth</code>tags), and can be used to resize the resulting image. Color images are not affected by windowing. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>Index of the frame (starts at <code>0</code>)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"height\" (float): Height of the resized image     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)     \"smooth\" (bool): Whether to smooth image on resize     \"width\" (float): Width of the resized image     \"window-center\" (float): Windowing center     \"window-width\" (float): Windowing width</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_frames_frame_rendered(\n    self,\n    frame: float,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Render a frame\n\n    Render one frame of interest from the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n    Tags: Instances\n\n    Parameters\n    ----------\n    frame\n        Index of the frame (starts at `0`)\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"height\" (float): Height of the resized image\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n            \"smooth\" (bool): Whether to smooth image on resize\n            \"width\" (float): Width of the resized image\n            \"window-center\" (float): Windowing center\n            \"window-width\" (float): Windowing width\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/frames/{frame}/rendered\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_header","title":"<code>get_instances_id_header(id_, params=None)</code>","text":"<p>Get DICOM meta-header</p> <p>Get the DICOM tags in the meta-header of the DICOM instance. By default, the <code>full</code> format is used, which combines hexadecimal tags with human-readable description. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags and their associated value</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_header(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get DICOM meta-header\n\n    Get the DICOM tags in the meta-header of the DICOM instance. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags and their associated value\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/header\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_image_int16","title":"<code>get_instances_id_image_int16(id_, params=None, headers=None)</code>","text":"<p>Decode an image (int16)</p> <p>Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_image_int16(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode an image (int16)\n\n    Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/image-int16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_image_uint16","title":"<code>get_instances_id_image_uint16(id_, params=None, headers=None)</code>","text":"<p>Decode an image (uint16)</p> <p>Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_image_uint16(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode an image (uint16)\n\n    Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/image-uint16\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_image_uint8","title":"<code>get_instances_id_image_uint8(id_, params=None, headers=None)</code>","text":"<p>Decode an image (uint8)</p> <p>Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_image_uint8(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode an image (uint8)\n\n    Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/image-uint8\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_labels","title":"<code>get_instances_id_labels(id_)</code>","text":"<p>List labels</p> <p>Get the labels that are associated with the given instance (new in Orthanc 1.12.0) Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List labels\n\n    Get the labels that are associated with the given instance (new in Orthanc 1.12.0)\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_labels_label","title":"<code>get_instances_id_labels_label(id_, label)</code>","text":"<p>Test label</p> <p>Test whether the instance is associated with the given label Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Test label\n\n    Test whether the instance is associated with the given label\n    Tags: Instances\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_matlab","title":"<code>get_instances_id_matlab(id_)</code>","text":"<p>Decode frame for Matlab</p> <p>Decode the first frame of the given DICOM instance., and export this frame as a Octave/Matlab matrix to be imported with <code>eval()</code>: https://orthanc.uclouvain.be/book/faq/matlab.html Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Octave/Matlab matrix</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_matlab(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode frame for Matlab\n\n    Decode the first frame of the given DICOM instance., and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://orthanc.uclouvain.be/book/faq/matlab.html\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Octave/Matlab matrix\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/matlab\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_metadata","title":"<code>get_instances_id_metadata(id_, params=None)</code>","text":"<p>List metadata</p> <p>Get the list of metadata that are associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List metadata\n\n    Get the list of metadata that are associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_metadata_name","title":"<code>get_instances_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Get metadata</p> <p>Get the value of a metadata that is associated with the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get metadata\n\n    Get the value of a metadata that is associated with the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_module","title":"<code>get_instances_id_module(id_, params=None)</code>","text":"<p>Get instance module</p> <p>Get the instance module of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM instance</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get instance module\n\n    Get the instance module of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM instance\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_numpy","title":"<code>get_instances_id_numpy(id_, params=None)</code>","text":"<p>Decode instance for numpy</p> <p>Decode the given DICOM instance, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM resource of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"compress\" (bool): Compress the file as <code>.npz</code>     \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_numpy(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode instance for numpy\n\n    Decode the given DICOM instance, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM resource of interest\n    params\n        Dictionary of optional parameters:\n            \"compress\" (bool): Compress the file as `.npz`\n            \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/numpy\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_patient","title":"<code>get_instances_id_patient(id_, params=None)</code>","text":"<p>Get parent patient</p> <p>Get detailed information about the parent patient of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM patient</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get parent patient\n\n    Get detailed information about the parent patient of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM patient\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_pdf","title":"<code>get_instances_id_pdf(id_)</code>","text":"<p>Get embedded PDF</p> <p>Get the PDF file that is embedded in one DICOM instance. If the DICOM instance doesn't contain the <code>EncapsulatedDocument</code> tag or if the <code>MIMETypeOfEncapsulatedDocument</code> tag doesn't correspond to the PDF type, a <code>404</code> HTTP error is raised. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>PDF file</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_pdf(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get embedded PDF\n\n    Get the PDF file that is embedded in one DICOM instance. If the DICOM instance doesn't contain the `EncapsulatedDocument` tag or if the `MIMETypeOfEncapsulatedDocument` tag doesn't correspond to the PDF type, a `404` HTTP error is raised.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        PDF file\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/pdf\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_preview","title":"<code>get_instances_id_preview(id_, params=None, headers=None)</code>","text":"<p>Decode an image (preview)</p> <p>Decode the first frame of the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_preview(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode an image (preview)\n\n    Decode the first frame of the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/preview\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_rendered","title":"<code>get_instances_id_rendered(id_, params=None, headers=None)</code>","text":"<p>Render an image</p> <p>Render the first frame of the given DICOM instance. This function takes scaling into account (<code>RescaleSlope</code> and <code>RescaleIntercept</code> tags), as well as the default windowing stored in the DICOM file (<code>WindowCenter</code> and <code>WindowWidth</code>tags), and can be used to resize the resulting image. Color images are not affected by windowing. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"height\" (float): Height of the resized image     \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)     \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)     \"smooth\" (bool): Whether to smooth image on resize     \"width\" (float): Width of the resized image     \"window-center\" (float): Windowing center     \"window-width\" (float): Windowing width</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Accept\" (str): Format of the resulting image. Can be <code>image/png</code> (default), <code>image/jpeg</code> or <code>image/x-portable-arbitrarymap</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JPEG image PNG image PAM image (Portable Arbitrary Map)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_rendered(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Render an image\n\n    Render the first frame of the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"height\" (float): Height of the resized image\n            \"quality\" (float): Quality for JPEG images (between 1 and 100, defaults to 90)\n            \"returnUnsupportedImage\" (bool): Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)\n            \"smooth\" (bool): Whether to smooth image on resize\n            \"width\" (float): Width of the resized image\n            \"window-center\" (float): Windowing center\n            \"window-width\" (float): Windowing width\n    headers\n        Dictionary of optional headers:\n            \"Accept\" (str): Format of the resulting image. Can be `image/png` (default), `image/jpeg` or `image/x-portable-arbitrarymap`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JPEG image\n        PNG image\n        PAM image (Portable Arbitrary Map)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/rendered\",\n        params=params,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_series","title":"<code>get_instances_id_series(id_, params=None)</code>","text":"<p>Get parent series</p> <p>Get detailed information about the parent series of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM series</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_series(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get parent series\n\n    Get detailed information about the parent series of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM series\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_simplified_tags","title":"<code>get_instances_id_simplified_tags(id_, params=None)</code>","text":"<p>Get human-readable tags</p> <p>Get the DICOM tags in human-readable format (same as the <code>/instances/{id}/tags?simplify</code> route) Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags and their associated value</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_simplified_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get human-readable tags\n\n    Get the DICOM tags in human-readable format (same as the `/instances/{id}/tags?simplify` route)\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags and their associated value\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/simplified-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_statistics","title":"<code>get_instances_id_statistics(id_)</code>","text":"<p>Get instance statistics</p> <p>Get statistics about the given instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get instance statistics\n\n    Get statistics about the given instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_study","title":"<code>get_instances_id_study(id_, params=None)</code>","text":"<p>Get parent study</p> <p>Get detailed information about the parent study of the DICOM instance whose Orthanc identifier is provided in the URL Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM study</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_study(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get parent study\n\n    Get detailed information about the parent study of the DICOM instance whose Orthanc identifier is provided in the URL\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM study\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/study\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_instances_id_tags","title":"<code>get_instances_id_tags(id_, params=None)</code>","text":"<p>Get DICOM tags</p> <p>Get the DICOM tags in the specified format. By default, the <code>full</code> format is used, which combines hexadecimal tags with human-readable description. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)     \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags and their associated value</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_instances_id_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get DICOM tags\n\n    Get the DICOM tags in the specified format. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n            \"whole\" (bool): Whether to read the whole DICOM file from the storage area (new in Orthanc 1.12.4). If set to \"false\" (default value), the DICOM file is read until the pixel data tag (7fe0,0010) to optimize access to storage. Setting the option to \"true\" provides access to the DICOM tags stored after the pixel data tag.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags and their associated value\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/instances/{id_}/tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_jobs","title":"<code>get_jobs(params=None)</code>","text":"<p>List jobs</p> <p>List all the available jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual jobs</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the jobs identifiers, or detailed information about the reported jobs (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_jobs(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List jobs\n\n    List all the available jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual jobs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the jobs identifiers, or detailed information about the reported jobs (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/jobs\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_jobs_id","title":"<code>get_jobs_id(id_)</code>","text":"<p>Get job</p> <p>Retrieve detailed information about the job whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object detailing the job</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_jobs_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get job\n\n    Retrieve detailed information about the job whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object detailing the job\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/jobs/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_jobs_id_key","title":"<code>get_jobs_id_key(id_, key)</code>","text":"<p>Get job output</p> <p>Retrieve some output produced by a job. As of Orthanc 1.8.2, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with <code>key</code> equals to <code>archive</code>). Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of the output of interest</p> required <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Content of the output of the job</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_jobs_id_key(\n    self,\n    id_: str,\n    key: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get job output\n\n    Retrieve some output produced by a job. As of Orthanc 1.8.2, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).\n    Tags: Jobs\n\n    Parameters\n    ----------\n    key\n        Name of the output of interest\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Content of the output of the job\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/jobs/{id_}/{key}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_modalities","title":"<code>get_modalities(params=None)</code>","text":"<p>List DICOM modalities</p> <p>List all the DICOM modalities that are known to Orthanc. This corresponds either to the content of the <code>DicomModalities</code> configuration option, or to the information stored in the database if <code>DicomModalitiesInDatabase</code> is <code>true</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual DICOM modalities</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the identifiers of the modalities, or detailed information about the modalities (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_modalities(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List DICOM modalities\n\n    List all the DICOM modalities that are known to Orthanc. This corresponds either to the content of the `DicomModalities` configuration option, or to the information stored in the database if `DicomModalitiesInDatabase` is `true`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual DICOM modalities\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the identifiers of the modalities, or detailed information about the modalities (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/modalities\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_modalities_id","title":"<code>get_modalities_id(id_)</code>","text":"<p>List operations on modality</p> <p>List the operations that are available for a DICOM modality. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the DICOM modality of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_modalities_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on modality\n\n    List the operations that are available for a DICOM modality.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the DICOM modality of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/modalities/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_modalities_id_configuration","title":"<code>get_modalities_id_configuration(id_)</code>","text":"<p>Get modality configuration</p> <p>Get detailed information about the configuration of some DICOM modality Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Configuration of the modality</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_modalities_id_configuration(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get modality configuration\n\n    Get detailed information about the configuration of some DICOM modality\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Configuration of the modality\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/modalities/{id_}/configuration\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients","title":"<code>get_patients(params=None)</code>","text":"<p>List the available patients</p> <p>List the Orthanc identifiers of all the available DICOM patients Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported patients (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List the available patients\n\n    List the Orthanc identifiers of all the available DICOM patients\n    Tags: Patients\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported patients (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id","title":"<code>get_patients_id(id_, params=None)</code>","text":"<p>Get information about some patient</p> <p>Get detailed information about the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM patient</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get information about some patient\n\n    Get detailed information about the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM patient\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_archive","title":"<code>get_patients_id_archive(id_, params=None)</code>","text":"<p>Create ZIP archive</p> <p>Synchronously create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_archive(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Synchronously create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments","title":"<code>get_patients_id_attachments(id_, params=None)</code>","text":"<p>List attachments</p> <p>Get the list of attachments that are associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List attachments\n\n    Get the list of attachments that are associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name","title":"<code>get_patients_id_attachments_name(id_, name, headers=None)</code>","text":"<p>List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given patient Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given patient\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_compressed_data","title":"<code>get_patients_id_attachments_name_compressed_data(id_, name, headers=None)</code>","text":"<p>Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given patient. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given patient. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_compressed_md5","title":"<code>get_patients_id_attachments_name_compressed_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given patient, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given patient, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_compressed_size","title":"<code>get_patients_id_attachments_name_compressed_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given patient, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment on disk\n\n    Get the size of one attachment associated with the given patient, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_data","title":"<code>get_patients_id_attachments_name_data(id_, name, headers=None)</code>","text":"<p>Get attachment</p> <p>Get the (binary) content of one attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment\n\n    Get the (binary) content of one attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_info","title":"<code>get_patients_id_attachments_name_info(id_, name, headers=None)</code>","text":"<p>Get info about the attachment</p> <p>Get all the information about the attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get info about the attachment\n\n    Get all the information about the attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_is_compressed","title":"<code>get_patients_id_attachments_name_is_compressed(id_, name, headers=None)</code>","text":"<p>Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_md5","title":"<code>get_patients_id_attachments_name_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_attachments_name_size","title":"<code>get_patients_id_attachments_name_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment</p> <p>Get the size of one attachment associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment\n\n    Get the size of one attachment associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_instances","title":"<code>get_patients_id_instances(id_, params=None)</code>","text":"<p>Get child instances</p> <p>Get detailed information about the child instances of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child instances     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM instances</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_instances(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get child instances\n\n    Get detailed information about the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child instances\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM instances\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_instances_tags","title":"<code>get_patients_id_instances_tags(id_, params=None)</code>","text":"<p>Get tags of instances</p> <p>Get the tags of all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_instances_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get tags of instances\n\n    Get the tags of all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/instances-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_labels","title":"<code>get_patients_id_labels(id_)</code>","text":"<p>List labels</p> <p>Get the labels that are associated with the given patient (new in Orthanc 1.12.0) Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List labels\n\n    Get the labels that are associated with the given patient (new in Orthanc 1.12.0)\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_labels_label","title":"<code>get_patients_id_labels_label(id_, label)</code>","text":"<p>Test label</p> <p>Test whether the patient is associated with the given label Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Test label\n\n    Test whether the patient is associated with the given label\n    Tags: Patients\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_media","title":"<code>get_patients_id_media(id_, params=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Synchronously create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"extended\" (str): If present, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_media(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Synchronously create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_metadata","title":"<code>get_patients_id_metadata(id_, params=None)</code>","text":"<p>List metadata</p> <p>Get the list of metadata that are associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List metadata\n\n    Get the list of metadata that are associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_metadata_name","title":"<code>get_patients_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Get metadata</p> <p>Get the value of a metadata that is associated with the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get metadata\n\n    Get the value of a metadata that is associated with the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_module","title":"<code>get_patients_id_module(id_, params=None)</code>","text":"<p>Get patient module</p> <p>Get the patient module of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM patient</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get patient module\n\n    Get the patient module of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM patient\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_protected","title":"<code>get_patients_id_protected(id_)</code>","text":"<p>Is the patient protected against recycling?</p> <p>Is the patient protected against recycling? Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>1</code> if protected, <code>0</code> if not protected</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_protected(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Is the patient protected against recycling?\n\n    Is the patient protected against recycling?\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `1` if protected, `0` if not protected\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/protected\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_series","title":"<code>get_patients_id_series(id_, params=None)</code>","text":"<p>Get child series</p> <p>Get detailed information about the child series of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child series     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM series</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_series(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get child series\n\n    Get detailed information about the child series of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child series\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM series\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_shared_tags","title":"<code>get_patients_id_shared_tags(id_, params=None)</code>","text":"<p>Get shared tags</p> <p>Extract the DICOM tags whose value is constant across all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the values of the DICOM tags</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_shared_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get shared tags\n\n    Extract the DICOM tags whose value is constant across all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the values of the DICOM tags\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/shared-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_statistics","title":"<code>get_patients_id_statistics(id_)</code>","text":"<p>Get patient statistics</p> <p>Get statistics about the given patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get patient statistics\n\n    Get statistics about the given patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_patients_id_studies","title":"<code>get_patients_id_studies(id_, params=None)</code>","text":"<p>Get child studies</p> <p>Get detailed information about the child studies of the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child studies     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM studies</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_patients_id_studies(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get child studies\n\n    Get detailed information about the child studies of the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child studies\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM studies\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/patients/{id_}/studies\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_peers","title":"<code>get_peers(params=None)</code>","text":"<p>List Orthanc peers</p> <p>List all the Orthanc peers that are known to Orthanc. This corresponds either to the content of the <code>OrthancPeers</code> configuration option, or to the information stored in the database if <code>OrthancPeersInDatabase</code> is <code>true</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual Orthanc peers</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the identifiers of the peers, or detailed information about the peers (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_peers(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List Orthanc peers\n\n    List all the Orthanc peers that are known to Orthanc. This corresponds either to the content of the `OrthancPeers` configuration option, or to the information stored in the database if `OrthancPeersInDatabase` is `true`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual Orthanc peers\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the identifiers of the peers, or detailed information about the peers (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/peers\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_peers_id","title":"<code>get_peers_id(id_)</code>","text":"<p>List operations on peer</p> <p>List the operations that are available for an Orthanc peer. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_peers_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on peer\n\n    List the operations that are available for an Orthanc peer.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/peers/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_peers_id_configuration","title":"<code>get_peers_id_configuration(id_)</code>","text":"<p>Get peer configuration</p> <p>Get detailed information about the configuration of some Orthanc peer Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Configuration of the peer</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_peers_id_configuration(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get peer configuration\n\n    Get detailed information about the configuration of some Orthanc peer\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Configuration of the peer\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/peers/{id_}/configuration\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_peers_id_system","title":"<code>get_peers_id_system(id_)</code>","text":"<p>Get peer system information</p> <p>Get system information about some Orthanc peer. This corresponds to doing a <code>GET</code> request against the <code>/system</code> URI of the remote peer. This route can be used to test connectivity. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the peer of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>System information about the peer</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_peers_id_system(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get peer system information\n\n    Get system information about some Orthanc peer. This corresponds to doing a `GET` request against the `/system` URI of the remote peer. This route can be used to test connectivity.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the peer of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        System information about the peer\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/peers/{id_}/system\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_plugins","title":"<code>get_plugins()</code>","text":"<p>List plugins</p> <p>List all the installed plugins Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the identifiers of the installed plugins</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_plugins(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List plugins\n\n    List all the installed plugins\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the identifiers of the installed plugins\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/plugins\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_plugins_explorer_js","title":"<code>get_plugins_explorer_js()</code>","text":"<p>JavaScript extensions to Orthanc Explorer</p> <p>Get the JavaScript extensions that are installed by all the plugins using the <code>OrthancPluginExtendOrthancExplorer()</code> function of the plugin SDK. This route is for internal use of Orthanc Explorer. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The JavaScript extensions</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_plugins_explorer_js(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"JavaScript extensions to Orthanc Explorer\n\n    Get the JavaScript extensions that are installed by all the plugins using the `OrthancPluginExtendOrthancExplorer()` function of the plugin SDK. This route is for internal use of Orthanc Explorer.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The JavaScript extensions\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/plugins/explorer.js\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_plugins_id","title":"<code>get_plugins_id(id_)</code>","text":"<p>Get plugin</p> <p>Get system information about the plugin whose identifier is provided in the URL Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing information about the plugin</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_plugins_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get plugin\n\n    Get system information about the plugin whose identifier is provided in the URL\n    Tags: System\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing information about the plugin\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/plugins/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries","title":"<code>get_queries()</code>","text":"<p>List query/retrieve operations</p> <p>List the identifiers of all the query/retrieve operations on DICOM modalities, as initiated by calls to <code>/modalities/{id}/query</code>. The length of this list is bounded by the <code>QueryRetrieveSize</code> configuration option of Orthanc. https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest Tags: Networking</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the identifiers</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List query/retrieve operations\n\n    List the identifiers of all the query/retrieve operations on DICOM modalities, as initiated by calls to `/modalities/{id}/query`. The length of this list is bounded by the `QueryRetrieveSize` configuration option of Orthanc. https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n    Tags: Networking\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the identifiers\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries_id","title":"<code>get_queries_id(id_)</code>","text":"<p>List operations on a query</p> <p>List the available operations for the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the list of operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on a query\n\n    List the available operations for the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the list of operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries_id_answers","title":"<code>get_queries_id_answers(id_, params=None)</code>","text":"<p>List answers to a query</p> <p>List the indices of all the available answers resulting from a query/retrieve operation on some DICOM modality, whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual answers     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the indices of the answers, or detailed information about the reported answers (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries_id_answers(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List answers to a query\n\n    List the indices of all the available answers resulting from a query/retrieve operation on some DICOM modality, whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual answers\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the indices of the answers, or detailed information about the reported answers (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries/{id_}/answers\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries_id_answers_index","title":"<code>get_queries_id_answers_index(id_, index)</code>","text":"<p>List operations on an answer</p> <p>List the available operations on an answer associated with the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the list of operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries_id_answers_index(\n    self,\n    id_: str,\n    index: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on an answer\n\n    List the available operations on an answer associated with the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the list of operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries/{id_}/answers/{index}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries_id_answers_index_content","title":"<code>get_queries_id_answers_index_content(id_, index, params=None)</code>","text":"<p>Get one answer</p> <p>Get the content (DICOM tags) of one answer associated with the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the DICOM tags of the answer</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries_id_answers_index_content(\n    self,\n    id_: str,\n    index: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get one answer\n\n    Get the content (DICOM tags) of one answer associated with the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the DICOM tags of the answer\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/content\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries_id_level","title":"<code>get_queries_id_level(id_)</code>","text":"<p>Get level of original query</p> <p>Get the query level (value of the <code>QueryRetrieveLevel</code> tag) of the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The level</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries_id_level(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get level of original query\n\n    Get the query level (value of the `QueryRetrieveLevel` tag) of the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The level\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries/{id_}/level\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries_id_modality","title":"<code>get_queries_id_modality(id_)</code>","text":"<p>Get modality of original query</p> <p>Get the identifier of the DICOM modality that was targeted by the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The identifier of the DICOM modality</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries_id_modality(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get modality of original query\n\n    Get the identifier of the DICOM modality that was targeted by the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The identifier of the DICOM modality\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries/{id_}/modality\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_queries_id_query","title":"<code>get_queries_id_query(id_, params=None)</code>","text":"<p>Get original query arguments</p> <p>Get the original DICOM filter associated with the query/retrieve operation whose identifier is provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Content of the original query</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_queries_id_query(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get original query arguments\n\n    Get the original DICOM filter associated with the query/retrieve operation whose identifier is provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Content of the original query\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/queries/{id_}/query\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series","title":"<code>get_series(params=None)</code>","text":"<p>List the available series</p> <p>List the Orthanc identifiers of all the available DICOM series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported series (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List the available series\n\n    List the Orthanc identifiers of all the available DICOM series\n    Tags: Series\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported series (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id","title":"<code>get_series_id(id_, params=None)</code>","text":"<p>Get information about some series</p> <p>Get detailed information about the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM series</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get information about some series\n\n    Get detailed information about the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM series\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_archive","title":"<code>get_series_id_archive(id_, params=None)</code>","text":"<p>Create ZIP archive</p> <p>Synchronously create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_archive(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Synchronously create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments","title":"<code>get_series_id_attachments(id_, params=None)</code>","text":"<p>List attachments</p> <p>Get the list of attachments that are associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List attachments\n\n    Get the list of attachments that are associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name","title":"<code>get_series_id_attachments_name(id_, name, headers=None)</code>","text":"<p>List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given series Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given series\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_compressed_data","title":"<code>get_series_id_attachments_name_compressed_data(id_, name, headers=None)</code>","text":"<p>Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given series. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given series. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_compressed_md5","title":"<code>get_series_id_attachments_name_compressed_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given series, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given series, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_compressed_size","title":"<code>get_series_id_attachments_name_compressed_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given series, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment on disk\n\n    Get the size of one attachment associated with the given series, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_data","title":"<code>get_series_id_attachments_name_data(id_, name, headers=None)</code>","text":"<p>Get attachment</p> <p>Get the (binary) content of one attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment\n\n    Get the (binary) content of one attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_info","title":"<code>get_series_id_attachments_name_info(id_, name, headers=None)</code>","text":"<p>Get info about the attachment</p> <p>Get all the information about the attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get info about the attachment\n\n    Get all the information about the attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_is_compressed","title":"<code>get_series_id_attachments_name_is_compressed(id_, name, headers=None)</code>","text":"<p>Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_md5","title":"<code>get_series_id_attachments_name_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_attachments_name_size","title":"<code>get_series_id_attachments_name_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment</p> <p>Get the size of one attachment associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment\n\n    Get the size of one attachment associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_instances","title":"<code>get_series_id_instances(id_, params=None)</code>","text":"<p>Get child instances</p> <p>Get detailed information about the child instances of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child instances     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM instances</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_instances(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get child instances\n\n    Get detailed information about the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child instances\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM instances\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_instances_tags","title":"<code>get_series_id_instances_tags(id_, params=None)</code>","text":"<p>Get tags of instances</p> <p>Get the tags of all the child instances of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_instances_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get tags of instances\n\n    Get the tags of all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/instances-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_labels","title":"<code>get_series_id_labels(id_)</code>","text":"<p>List labels</p> <p>Get the labels that are associated with the given series (new in Orthanc 1.12.0) Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List labels\n\n    Get the labels that are associated with the given series (new in Orthanc 1.12.0)\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_labels_label","title":"<code>get_series_id_labels_label(id_, label)</code>","text":"<p>Test label</p> <p>Test whether the series is associated with the given label Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Test label\n\n    Test whether the series is associated with the given label\n    Tags: Series\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_media","title":"<code>get_series_id_media(id_, params=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Synchronously create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"extended\" (str): If present, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_media(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Synchronously create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_metadata","title":"<code>get_series_id_metadata(id_, params=None)</code>","text":"<p>List metadata</p> <p>Get the list of metadata that are associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List metadata\n\n    Get the list of metadata that are associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_metadata_name","title":"<code>get_series_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Get metadata</p> <p>Get the value of a metadata that is associated with the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get metadata\n\n    Get the value of a metadata that is associated with the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_module","title":"<code>get_series_id_module(id_, params=None)</code>","text":"<p>Get series module</p> <p>Get the series module of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM series</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get series module\n\n    Get the series module of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM series\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_numpy","title":"<code>get_series_id_numpy(id_, params=None)</code>","text":"<p>Decode series for numpy</p> <p>Decode the given DICOM series, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM resource of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"compress\" (bool): Compress the file as <code>.npz</code>     \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_numpy(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Decode series for numpy\n\n    Decode the given DICOM series, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM resource of interest\n    params\n        Dictionary of optional parameters:\n            \"compress\" (bool): Compress the file as `.npz`\n            \"rescale\" (bool): On grayscale images, apply the rescaling and return floating-point values\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Numpy file: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/numpy\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_ordered_slices","title":"<code>get_series_id_ordered_slices(id_)</code>","text":"<p>Order the slices</p> <p>Sort the instances and frames (slices) of the DICOM series whose Orthanc identifier is provided in the URL. This URI is essentially used by the Orthanc Web viewer and by the Osimis Web viewer. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_ordered_slices(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Order the slices\n\n    Sort the instances and frames (slices) of the DICOM series whose Orthanc identifier is provided in the URL. This URI is essentially used by the Orthanc Web viewer and by the Osimis Web viewer.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    return self._get(\n        route=f\"{self.url}/series/{id_}/ordered-slices\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_patient","title":"<code>get_series_id_patient(id_, params=None)</code>","text":"<p>Get parent patient</p> <p>Get detailed information about the parent patient of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM patient</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get parent patient\n\n    Get detailed information about the parent patient of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM patient\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_shared_tags","title":"<code>get_series_id_shared_tags(id_, params=None)</code>","text":"<p>Get shared tags</p> <p>Extract the DICOM tags whose value is constant across all the child instances of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the values of the DICOM tags</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_shared_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get shared tags\n\n    Extract the DICOM tags whose value is constant across all the child instances of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the values of the DICOM tags\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/shared-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_statistics","title":"<code>get_series_id_statistics(id_)</code>","text":"<p>Get series statistics</p> <p>Get statistics about the given series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get series statistics\n\n    Get statistics about the given series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_series_id_study","title":"<code>get_series_id_study(id_, params=None)</code>","text":"<p>Get parent study</p> <p>Get detailed information about the parent study of the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM study</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_series_id_study(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get parent study\n\n    Get detailed information about the parent study of the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM study\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/series/{id_}/study\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get database statistics</p> <p>Get statistics related to the database of Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_statistics(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get database statistics\n\n    Get statistics related to the database of Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/statistics\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_storage_commitment_id","title":"<code>get_storage_commitment_id(id_)</code>","text":"<p>Get storage commitment report</p> <p>Get the storage commitment report whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the storage commitment report</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_storage_commitment_id(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get storage commitment report\n\n    Get the storage commitment report whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the storage commitment report\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/storage-commitment/{id_}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies","title":"<code>get_studies(params=None)</code>","text":"<p>List the available studies</p> <p>List the Orthanc identifiers of all the available DICOM studies Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"limit\" (float): Limit the number of results     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides <code>expand</code>)     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"since\" (float): Show only the resources since the provided index</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported studies (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List the available studies\n\n    List the Orthanc identifiers of all the available DICOM studies\n    Tags: Studies\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, retrieve detailed information about the individual resources, not only their Orthanc identifiers\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"limit\" (float): Limit the number of results\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"response-content\" (str): Defines the content of response for each returned resource.  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.e.g: 'response-content=MainDicomTags;Children (new in Orthanc 1.12.5 - overrides `expand`)\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"since\" (float): Show only the resources since the provided index\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported studies (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id","title":"<code>get_studies_id(id_, params=None)</code>","text":"<p>Get information about some study</p> <p>Get detailed information about the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM study</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get information about some study\n\n    Get detailed information about the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM study\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_archive","title":"<code>get_studies_id_archive(id_, params=None)</code>","text":"<p>Create ZIP archive</p> <p>Synchronously create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_archive(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Synchronously create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments","title":"<code>get_studies_id_attachments(id_, params=None)</code>","text":"<p>List attachments</p> <p>Get the list of attachments that are associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (str): If present, retrieve the attachments list and their numerical ids</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the attachments</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List attachments\n\n    Get the list of attachments that are associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (str): If present, retrieve the attachments list and their numerical ids\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the attachments\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name","title":"<code>get_studies_id_attachments_name(id_, name, headers=None)</code>","text":"<p>List operations on attachments</p> <p>Get the list of the operations that are available for attachments associated with the given study Tags: Other</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations on attachments\n\n    Get the list of the operations that are available for attachments associated with the given study\n    Tags: Other\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_compressed_data","title":"<code>get_studies_id_attachments_name_compressed_data(id_, name, headers=None)</code>","text":"<p>Get attachment (no decompression)</p> <p>Get the (binary) content of one attachment associated with the given study. The attachment will not be decompressed if <code>StorageCompression</code> is <code>true</code>. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_compressed_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment (no decompression)\n\n    Get the (binary) content of one attachment associated with the given study. The attachment will not be decompressed if `StorageCompression` is `true`.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_compressed_md5","title":"<code>get_studies_id_attachments_name_compressed_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment on disk</p> <p>Get the MD5 hash of one attachment associated with the given study, as stored on the disk. This is different from <code>.../md5</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_compressed_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment on disk\n\n    Get the MD5 hash of one attachment associated with the given study, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_compressed_size","title":"<code>get_studies_id_attachments_name_compressed_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment on disk</p> <p>Get the size of one attachment associated with the given study, as stored on the disk. This is different from <code>.../size</code> iff <code>EnableStorage</code> is <code>true</code>. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment, as stored on the disk</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_compressed_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment on disk\n\n    Get the size of one attachment associated with the given study, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment, as stored on the disk\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compressed-size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_data","title":"<code>get_studies_id_attachments_name_data(id_, name, headers=None)</code>","text":"<p>Get attachment</p> <p>Get the (binary) content of one attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_data(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get attachment\n\n    Get the (binary) content of one attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"Content-Range\" (str): Optional content range to access part of the attachment (new in Orthanc 1.12.5)\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/data\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_info","title":"<code>get_studies_id_attachments_name_info(id_, name, headers=None)</code>","text":"<p>Get info about the attachment</p> <p>Get all the information about the attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the information about the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_info(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get info about the attachment\n\n    Get all the information about the attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the information about the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/info\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_is_compressed","title":"<code>get_studies_id_attachments_name_is_compressed(id_, name, headers=None)</code>","text":"<p>Is attachment compressed?</p> <p>Test whether the attachment has been stored as a compressed file on the disk. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>0</code> if the attachment was stored uncompressed, <code>1</code> if it was compressed</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_is_compressed(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Is attachment compressed?\n\n    Test whether the attachment has been stored as a compressed file on the disk.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `0` if the attachment was stored uncompressed, `1` if it was compressed\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/is-compressed\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_md5","title":"<code>get_studies_id_attachments_name_md5(id_, name, headers=None)</code>","text":"<p>Get MD5 of attachment</p> <p>Get the MD5 hash of one attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The MD5 of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_md5(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get MD5 of attachment\n\n    Get the MD5 hash of one attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The MD5 of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/md5\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_attachments_name_size","title":"<code>get_studies_id_attachments_name_size(id_, name, headers=None)</code>","text":"<p>Get size of attachment</p> <p>Get the size of one attachment associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The size of the attachment</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_attachments_name_size(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get size of attachment\n\n    Get the size of one attachment associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the attachment, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The size of the attachment\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/size\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_instances","title":"<code>get_studies_id_instances(id_, params=None)</code>","text":"<p>Get child instances</p> <p>Get detailed information about the child instances of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child instances     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM instances</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_instances(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get child instances\n\n    Get detailed information about the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child instances\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM instances\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/instances\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_instances_tags","title":"<code>get_studies_id_instances_tags(id_, params=None)</code>","text":"<p>Get tags of instances</p> <p>Get the tags of all the child instances of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_instances_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get tags of instances\n\n    Get the tags of all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object associating the Orthanc identifiers of the instances, with the values of their DICOM tags\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/instances-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_labels","title":"<code>get_studies_id_labels(id_)</code>","text":"<p>List labels</p> <p>Get the labels that are associated with the given study (new in Orthanc 1.12.0) Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the labels</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_labels(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List labels\n\n    Get the labels that are associated with the given study (new in Orthanc 1.12.0)\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the labels\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/labels\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_labels_label","title":"<code>get_studies_id_labels_label(id_, label)</code>","text":"<p>Test label</p> <p>Test whether the study is associated with the given label Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of interest</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty string is returned in the case of presence, error 404 in the case of absence</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Test label\n\n    Test whether the study is associated with the given label\n    Tags: Studies\n\n    Parameters\n    ----------\n    label\n        The label of interest\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty string is returned in the case of presence, error 404 in the case of absence\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_media","title":"<code>get_studies_id_media(id_, params=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Synchronously create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might not be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using <code>POST</code> method. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"extended\" (str): If present, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR     \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)     \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_media(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Synchronously create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"extended\" (str): If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*\n            \"filename\" (str): Filename to set in the \"Content-Disposition\" HTTP header (including file extension)\n            \"transcode\" (str): If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        ZIP file containing the archive\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_metadata","title":"<code>get_studies_id_metadata(id_, params=None)</code>","text":"<p>List metadata</p> <p>Get the list of metadata that are associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If present, also retrieve the value of the individual metadata     \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if <code>expand</code> argument is provided)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_metadata(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List metadata\n\n    Get the list of metadata that are associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If present, also retrieve the value of the individual metadata\n            \"numeric\" (str): If present, use the numeric identifier of the metadata instead of its symbolic name\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the names of the available metadata, or JSON associative array mapping metadata to their values (if `expand` argument is provided)\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/metadata\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_metadata_name","title":"<code>get_studies_id_metadata_name(id_, name, headers=None)</code>","text":"<p>Get metadata</p> <p>Get the value of a metadata that is associated with the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Value of the metadata</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get metadata\n\n    Get the value of a metadata that is associated with the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    headers\n        Dictionary of optional headers:\n            \"If-None-Match\" (str): Optional revision of the metadata, to check if its content has changed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Value of the metadata\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_module","title":"<code>get_studies_id_module(id_, params=None)</code>","text":"<p>Get study module</p> <p>Get the study module of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM study</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_module(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get study module\n\n    Get the study module of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM study\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/module\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_module_patient","title":"<code>get_studies_id_module_patient(id_, params=None)</code>","text":"<p>Get patient module of study</p> <p>Get the patient module of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the DICOM study</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_module_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get patient module of study\n\n    Get the patient module of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"ignore-length\" (List): Also include the DICOM tags that are provided in this list, even if their associated value is long\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the DICOM study\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/module-patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_patient","title":"<code>get_studies_id_patient(id_, params=None)</code>","text":"<p>Get parent patient</p> <p>Get detailed information about the parent patient of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the parent DICOM patient</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_patient(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get parent patient\n\n    Get detailed information about the parent patient of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the parent DICOM patient\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/patient\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_series","title":"<code>get_studies_id_series(id_, params=None)</code>","text":"<p>Get child series</p> <p>Get detailed information about the child series of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"expand\" (str): If false or missing, only retrieve the list of child series     \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)     \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.     \"short\" (bool): If present, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing information about the child DICOM series</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_series(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get child series\n\n    Get detailed information about the child series of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"expand\" (str): If false or missing, only retrieve the list of child series\n            \"full\" (bool): If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n            \"requested-tags\" (str): If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requested-tags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing information about the child DICOM series\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/series\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_shared_tags","title":"<code>get_studies_id_shared_tags(id_, params=None)</code>","text":"<p>Get shared tags</p> <p>Extract the DICOM tags whose value is constant across all the child instances of the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"short\" (bool): If present, report the DICOM tags in hexadecimal format     \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON object containing the values of the DICOM tags</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_shared_tags(\n    self,\n    id_: str,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get shared tags\n\n    Extract the DICOM tags whose value is constant across all the child instances of the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    params\n        Dictionary of optional parameters:\n            \"short\" (bool): If present, report the DICOM tags in hexadecimal format\n            \"simplify\" (bool): If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON object containing the values of the DICOM tags\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/shared-tags\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_studies_id_statistics","title":"<code>get_studies_id_statistics(id_)</code>","text":"<p>Get study statistics</p> <p>Get statistics about the given study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_studies_id_statistics(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get study statistics\n\n    Get statistics about the given study\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/studies/{id_}/statistics\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_system","title":"<code>get_system()</code>","text":"<p>Get system information</p> <p>Get system information about Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_system(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get system information\n\n    Get system information about Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/system\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools","title":"<code>get_tools()</code>","text":"<p>List operations</p> <p>List the available operations under URI <code>/tools/</code> Tags: Other</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>List of the available operations</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"List operations\n\n    List the available operations under URI `/tools/`\n    Tags: Other\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        List of the available operations\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_accepted_sop_classes","title":"<code>get_tools_accepted_sop_classes()</code>","text":"<p>Get accepted SOPClassUID</p> <p>Get the list of SOP Class UIDs that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options <code>AcceptedSopClasses</code> and <code>RejectedSopClasses</code>. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the SOP Class UIDs</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_accepted_sop_classes(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get accepted SOPClassUID\n\n    Get the list of SOP Class UIDs that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedSopClasses` and `RejectedSopClasses`.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the SOP Class UIDs\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/accepted-sop-classes\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_accepted_transfer_syntaxes","title":"<code>get_tools_accepted_transfer_syntaxes()</code>","text":"<p>Get accepted transfer syntaxes</p> <p>Get the list of UIDs of the DICOM transfer syntaxes that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options <code>AcceptedTransferSyntaxes</code> and <code>XXXTransferSyntaxAccepted</code>. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the transfer syntax UIDs</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_accepted_transfer_syntaxes(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get accepted transfer syntaxes\n\n    Get the list of UIDs of the DICOM transfer syntaxes that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedTransferSyntaxes` and `XXXTransferSyntaxAccepted`.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the transfer syntax UIDs\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_create_archive","title":"<code>get_tools_create_archive(params=None)</code>","text":"<p>Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the ZIP archive.     \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_create_archive(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the ZIP archive.\n            \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/create-archive\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_create_media","title":"<code>get_tools_create_media(params=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.     \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_create_media(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n            \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/create-media\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_create_media_extended","title":"<code>get_tools_create_media_extended(params=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.     \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_create_media_extended(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the 'resources' argument\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"resources\" (str): A comma separated list of Orthanc resource identifiers to include in the DICOMDIR media.\n            \"transcode\" (str): If present, the DICOM files will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/create-media-extended\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_default_encoding","title":"<code>get_tools_default_encoding()</code>","text":"<p>Get default encoding</p> <p>Get the default encoding that is used by Orthanc if parsing a DICOM instance without the <code>SpecificCharacterEncoding</code> tag, or during C-FIND. This corresponds to the configuration option <code>DefaultEncoding</code>. Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The name of the encoding</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_default_encoding(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get default encoding\n\n    Get the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The name of the encoding\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/default-encoding\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_dicom_conformance","title":"<code>get_tools_dicom_conformance()</code>","text":"<p>Get DICOM conformance</p> <p>Get the DICOM conformance statement of Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The DICOM conformance statement</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_dicom_conformance(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get DICOM conformance\n\n    Get the DICOM conformance statement of Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The DICOM conformance statement\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/dicom-conformance\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_generate_uid","title":"<code>get_tools_generate_uid(params=None)</code>","text":"<p>Generate an identifier</p> <p>Generate a random DICOM identifier Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>QueryParamTypes</code> <p>Dictionary of optional parameters:     \"level\" (str): Type of DICOM resource among: <code>patient</code>, <code>study</code>, <code>series</code> or <code>instance</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The generated identifier</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_generate_uid(\n    self,\n    params: QueryParamTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Generate an identifier\n\n    Generate a random DICOM identifier\n    Tags: System\n\n    Parameters\n    ----------\n    params\n        Dictionary of optional parameters:\n            \"level\" (str): Type of DICOM resource among: `patient`, `study`, `series` or `instance`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The generated identifier\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/generate-uid_\",\n        params=params,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_labels","title":"<code>get_tools_labels()</code>","text":"<p>Get all the used labels</p> <p>List all the labels that are associated with any resource of the Orthanc database Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the labels</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_labels(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get all the used labels\n\n    List all the labels that are associated with any resource of the Orthanc database\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the labels\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/labels\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level","title":"<code>get_tools_log_level()</code>","text":"<p>Get main log level</p> <p>Get the main log level of Orthanc Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get main log level\n\n    Get the main log level of Orthanc\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level_dicom","title":"<code>get_tools_log_level_dicom()</code>","text":"<p>Get log level for <code>dicom</code></p> <p>Get the log level of the log category <code>dicom</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level_dicom(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get log level for `dicom`\n\n    Get the log level of the log category `dicom`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level-dicom\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level_generic","title":"<code>get_tools_log_level_generic()</code>","text":"<p>Get log level for <code>generic</code></p> <p>Get the log level of the log category <code>generic</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level_generic(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get log level for `generic`\n\n    Get the log level of the log category `generic`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level-generic\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level_http","title":"<code>get_tools_log_level_http()</code>","text":"<p>Get log level for <code>http</code></p> <p>Get the log level of the log category <code>http</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level_http(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get log level for `http`\n\n    Get the log level of the log category `http`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level-http\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level_jobs","title":"<code>get_tools_log_level_jobs()</code>","text":"<p>Get log level for <code>jobs</code></p> <p>Get the log level of the log category <code>jobs</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level_jobs(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get log level for `jobs`\n\n    Get the log level of the log category `jobs`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level-jobs\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level_lua","title":"<code>get_tools_log_level_lua()</code>","text":"<p>Get log level for <code>lua</code></p> <p>Get the log level of the log category <code>lua</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level_lua(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get log level for `lua`\n\n    Get the log level of the log category `lua`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level-lua\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level_plugins","title":"<code>get_tools_log_level_plugins()</code>","text":"<p>Get log level for <code>plugins</code></p> <p>Get the log level of the log category <code>plugins</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level_plugins(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get log level for `plugins`\n\n    Get the log level of the log category `plugins`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level-plugins\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_log_level_sqlite","title":"<code>get_tools_log_level_sqlite()</code>","text":"<p>Get log level for <code>sqlite</code></p> <p>Get the log level of the log category <code>sqlite</code> Tags: Logs</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_log_level_sqlite(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get log level for `sqlite`\n\n    Get the log level of the log category `sqlite`\n    Tags: Logs\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Possible values: `default`, `verbose` or `trace`\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/log-level-sqlite\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_metrics","title":"<code>get_tools_metrics()</code>","text":"<p>Are metrics collected?</p> <p>Returns a Boolean specifying whether Prometheus metrics are collected and exposed at <code>/tools/metrics-prometheus</code> Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>1</code> if metrics are collected, <code>0</code> if metrics are disabled</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_metrics(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Are metrics collected?\n\n    Returns a Boolean specifying whether Prometheus metrics are collected and exposed at `/tools/metrics-prometheus`\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `1` if metrics are collected, `0` if metrics are disabled\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/metrics\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_metrics_prometheus","title":"<code>get_tools_metrics_prometheus()</code>","text":"<p>Get usage metrics</p> <p>Get usage metrics of Orthanc in the Prometheus file format (OpenMetrics): https://orthanc.uclouvain.be/book/users/advanced-rest.html#instrumentation-with-prometheus Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>No description</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_metrics_prometheus(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get usage metrics\n\n    Get usage metrics of Orthanc in the Prometheus file format (OpenMetrics): https://orthanc.uclouvain.be/book/users/advanced-rest.html#instrumentation-with-prometheus\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        No description\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/metrics-prometheus\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_now","title":"<code>get_tools_now()</code>","text":"<p>Get UTC time</p> <p>Get UTC time Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The UTC time</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_now(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get UTC time\n\n    Get UTC time\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The UTC time\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/now\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_now_local","title":"<code>get_tools_now_local()</code>","text":"<p>Get local time</p> <p>Get local time Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The local time</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_now_local(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Get local time\n\n    Get local time\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The local time\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/now-local\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.get_tools_unknown_sop_class_accepted","title":"<code>get_tools_unknown_sop_class_accepted()</code>","text":"<p>Is unknown SOP class accepted?</p> <p>Shall Orthanc C-STORE SCP accept DICOM instances with an unknown SOP class UID? Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p><code>1</code> if accepted, <code>0</code> if not accepted</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def get_tools_unknown_sop_class_accepted(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Is unknown SOP class accepted?\n\n    Shall Orthanc C-STORE SCP accept DICOM instances with an unknown SOP class UID?\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        `1` if accepted, `0` if not accepted\n    \"\"\"\n    return self._get(\n        route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances","title":"<code>post_instances(content=None)</code>","text":"<p>Upload DICOM instances</p> <p>Upload DICOM instances Tags: Instances</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Information about the uploaded instance, or list of information for each uploaded instance in the case of ZIP archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances(\n    self,\n    content: RequestContent = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Upload DICOM instances\n\n    Upload DICOM instances\n    Tags: Instances\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Information about the uploaded instance, or list of information for each uploaded instance in the case of ZIP archive\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/instances\",\n        content=content,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances_id_anonymize","title":"<code>post_instances_id_anonymize(id_, json=None)</code>","text":"<p>Anonymize instance</p> <p>Download an anonymized version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-a-single-instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The anonymized DICOM instance</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Anonymize instance\n\n    Download an anonymized version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-a-single-instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    json\n        Dictionary with the following keys:\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The anonymized DICOM instance\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/instances/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances_id_attachments_name_compress","title":"<code>post_instances_id_attachments_name_compress(id_, name)</code>","text":"<p>Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances_id_attachments_name_uncompress","title":"<code>post_instances_id_attachments_name_uncompress(id_, name)</code>","text":"<p>Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances_id_attachments_name_verify_md5","title":"<code>post_instances_id_attachments_name_verify_md5(id_, name)</code>","text":"<p>Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances_id_export","title":"<code>post_instances_id_export(id_, data=None)</code>","text":"<p>Write DICOM onto filesystem</p> <p>Write the DICOM file onto the filesystem where Orthanc is running.  This is insecure for Orthanc servers that are remotely accessible since one could overwrite any system file.  Since Orthanc 1.12.0, this route is disabled by default, but can be enabled using the <code>RestApiWriteToFileSystemEnabled</code> configuration option. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the DICOM instance of interest</p> required <code>data</code> <code>RequestData</code> <p>Target path on the filesystem</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances_id_export(\n    self,\n    id_: str,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Write DICOM onto filesystem\n\n    Write the DICOM file onto the filesystem where Orthanc is running.  This is insecure for Orthanc servers that are remotely accessible since one could overwrite any system file.  Since Orthanc 1.12.0, this route is disabled by default, but can be enabled using the `RestApiWriteToFileSystemEnabled` configuration option.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the DICOM instance of interest\n    data\n        Target path on the filesystem\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/instances/{id_}/export\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances_id_modify","title":"<code>post_instances_id_modify(id_, json=None)</code>","text":"<p>Modify instance</p> <p>Download a modified version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-a-single-instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The modified DICOM instance</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Modify instance\n\n    Download a modified version of the DICOM instance whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-a-single-instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    json\n        Dictionary with the following keys:\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The modified DICOM instance\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/instances/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_instances_id_reconstruct","title":"<code>post_instances_id_reconstruct(id_, json=None)</code>","text":"<p>Reconstruct tags &amp; optionally files of instance</p> <p>Reconstruct the main DICOM tags in DB of the instance whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_instances_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Reconstruct tags &amp; optionally files of instance\n\n    Reconstruct the main DICOM tags in DB of the instance whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Instances\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the instance of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/instances/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_jobs_id_cancel","title":"<code>post_jobs_id_cancel(id_)</code>","text":"<p>Cancel job</p> <p>Cancel the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_jobs_id_cancel(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Cancel job\n\n    Cancel the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/jobs/{id_}/cancel\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_jobs_id_pause","title":"<code>post_jobs_id_pause(id_)</code>","text":"<p>Pause job</p> <p>Pause the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_jobs_id_pause(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Pause job\n\n    Pause the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/jobs/{id_}/pause\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_jobs_id_resubmit","title":"<code>post_jobs_id_resubmit(id_)</code>","text":"<p>Resubmit job</p> <p>Resubmit the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_jobs_id_resubmit(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Resubmit job\n\n    Resubmit the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/jobs/{id_}/resubmit\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_jobs_id_resume","title":"<code>post_jobs_id_resume(id_)</code>","text":"<p>Resume job</p> <p>Resume the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs Tags: Jobs</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the job of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_jobs_id_resume(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Resume job\n\n    Resume the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n    Tags: Jobs\n\n    Parameters\n    ----------\n    id_\n        Identifier of the job of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/jobs/{id_}/resume\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_echo","title":"<code>post_modalities_id_echo(id_, json=None)</code>","text":"<p>Trigger C-ECHO SCU</p> <p>Trigger C-ECHO SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-echo Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the <code>DicomEchoChecksFind</code> configuration option. New in Orthanc 1.8.1.   \"Timeout\": Timeout for the C-ECHO command, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_echo(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Trigger C-ECHO SCU\n\n    Trigger C-ECHO SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-echo\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n          \"Timeout\": Timeout for the C-ECHO command, in seconds\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/echo\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_find","title":"<code>post_modalities_id_find(id_, json=None)</code>","text":"<p>Hierarchical C-FIND SCU</p> <p>Trigger a sequence of C-FIND SCU commands against the DICOM modality whose identifier is provided in URL, in order to discover a hierarchy of matching patients/studies/series. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching patients, embedding the matching studies, then the matching series.</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_find(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Hierarchical C-FIND SCU\n\n    Trigger a sequence of C-FIND SCU commands against the DICOM modality whose identifier is provided in URL, in order to discover a hierarchy of matching patients/studies/series. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching patients, embedding the matching studies, then the matching series.\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/find\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_find_instance","title":"<code>post_modalities_id_find_instance(id_, json=None)</code>","text":"<p>C-FIND SCU for instances</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find an instance. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching instances</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_find_instance(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"C-FIND SCU for instances\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find an instance. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching instances\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/find-instance\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_find_patient","title":"<code>post_modalities_id_find_patient(id_, json=None)</code>","text":"<p>C-FIND SCU for patients</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a patient. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching patients</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_find_patient(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"C-FIND SCU for patients\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a patient. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching patients\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/find-patient\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_find_series","title":"<code>post_modalities_id_find_series(id_, json=None)</code>","text":"<p>C-FIND SCU for series</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a series. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching series</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_find_series(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"C-FIND SCU for series\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a series. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching series\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/find-series\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_find_study","title":"<code>post_modalities_id_find_study(id_, json=None)</code>","text":"<p>C-FIND SCU for studies</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a study. Deprecated in favor of <code>/modalities/{id}/query</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching studies</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_find_study(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"C-FIND SCU for studies\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a study. Deprecated in favor of `/modalities/{id}/query`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching studies\n    \"\"\"\n    warnings.warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/find-study\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_find_worklist","title":"<code>post_modalities_id_find_worklist(id_, json=None)</code>","text":"<p>C-FIND SCU for worklist</p> <p>Trigger C-FIND SCU command against the remote worklists of the DICOM modality whose identifier is provided in URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array describing the DICOM tags of the matching worklists</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_find_worklist(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"C-FIND SCU for worklist\n\n    Trigger C-FIND SCU command against the remote worklists of the DICOM modality whose identifier is provided in URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array describing the DICOM tags of the matching worklists\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/find-worklist\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_get","title":"<code>post_modalities_id_get(id_, json=None)</code>","text":"<p>Trigger C-GET SCU</p> <p>Start a C-GET SCU command as a job, in order to retrieve DICOM resources from a remote DICOM modality whose identifier is provided in the URL: Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of queries identifying all the DICOM resources to be sent.  Usage of wildcards is prohibited and the query shall only contain DICOM ID tags.  Additionally, you may provide SOPClassesInStudy to limit the scope of the DICOM negotiation to certain SOPClassUID or to present uncommon SOPClassUID during the DICOM negotation.  By default, Orhanc will propose the most 120 common SOPClassUIDs.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Timeout\": Timeout for the C-GET command, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_get(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Trigger C-GET SCU\n\n    Start a C-GET SCU command as a job, in order to retrieve DICOM resources from a remote DICOM modality whose identifier is provided in the URL:\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of queries identifying all the DICOM resources to be sent.  Usage of wildcards is prohibited and the query shall only contain DICOM ID tags.  Additionally, you may provide SOPClassesInStudy to limit the scope of the DICOM negotiation to certain SOPClassUID or to present uncommon SOPClassUID during the DICOM negotation.  By default, Orhanc will propose the most 120 common SOPClassUIDs.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Timeout\": Timeout for the C-GET command, in seconds\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/get\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_move","title":"<code>post_modalities_id_move(id_, json=None)</code>","text":"<p>Trigger C-MOVE SCU</p> <p>Start a C-MOVE SCU command as a job, in order to drive the execution of a sequence of C-STORE commands by some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-move Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of queries identifying all the DICOM resources to be sent   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"TargetAet\": Target AET that will be used by the remote DICOM modality as a target for its C-STORE SCU commands, defaults to <code>DicomAet</code> configuration option in order to do a simple query/retrieve   \"Timeout\": Timeout for the C-MOVE command, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_move(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Trigger C-MOVE SCU\n\n    Start a C-MOVE SCU command as a job, in order to drive the execution of a sequence of C-STORE commands by some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-c-move\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of queries identifying all the DICOM resources to be sent\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"TargetAet\": Target AET that will be used by the remote DICOM modality as a target for its C-STORE SCU commands, defaults to `DicomAet` configuration option in order to do a simple query/retrieve\n          \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/move\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_query","title":"<code>post_modalities_id_query(id_, json=None)</code>","text":"<p>Trigger C-FIND SCU</p> <p>Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"Normalize\": Whether to normalize the query, i.e. whether to wipe out from the query, the DICOM tags that are not applicable for the query-retrieve level of interest   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command and subsequent C-MOVE retrievals, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_query(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Trigger C-FIND SCU\n\n    Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"Normalize\": Whether to normalize the query, i.e. whether to wipe out from the query, the DICOM tags that are not applicable for the query-retrieve level of interest\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command and subsequent C-MOVE retrievals, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/query\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_storage_commitment","title":"<code>post_modalities_id_storage_commitment(id_, json=None)</code>","text":"<p>Trigger storage commitment request</p> <p>Trigger a storage commitment request to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"DicomInstances\": List of DICOM resources that are not necessarily stored within Orthanc, but that must be checked by storage commitment. This is a list of JSON objects that must contain the <code>SOPClassUID</code> and <code>SOPInstanceUID</code> fields.   \"Resources\": List of the Orthanc identifiers of the DICOM resources to be checked by storage commitment   \"Timeout\": Timeout for the storage commitment command (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_storage_commitment(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Trigger storage commitment request\n\n    Trigger a storage commitment request to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/storage-commitment.html#storage-commitment-scu\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"DicomInstances\": List of DICOM resources that are not necessarily stored within Orthanc, but that must be checked by storage commitment. This is a list of JSON objects that must contain the `SOPClassUID` and `SOPInstanceUID` fields.\n          \"Resources\": List of the Orthanc identifiers of the DICOM resources to be checked by storage commitment\n          \"Timeout\": Timeout for the storage commitment command (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/storage-commitment\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_store","title":"<code>post_modalities_id_store(id_, data=None, json=None)</code>","text":"<p>Trigger C-STORE SCU</p> <p>Start a C-STORE SCU command as a job, in order to send DICOM resources stored locally to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#rest-store-scu Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"CalledAet\": Called AET that is used for this commands, defaults to <code>AET</code> configuration option. Allows you to overwrite the destination AET for a specific operation.   \"Host\": Host that is used for this commands, defaults to <code>Host</code> configuration option. Allows you to overwrite the destination host for a specific operation.   \"LocalAet\": Local AET that is used for this commands, defaults to <code>DicomAet</code> configuration option. Ignored if <code>DicomModalities</code> already sets <code>LocalAet</code> for this modality.   \"MoveOriginatorAet\": Move originator AET that is used for this commands, in order to fake a C-MOVE SCU   \"MoveOriginatorID\": Move originator ID that is used for this commands, in order to fake a C-MOVE SCU   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Port\": Port that is used for this command, defaults to <code>Port</code> configuration option. Allows you to overwrite the destination port for a specific operation.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent   \"StorageCommitment\": Whether to chain C-STORE with DICOM storage commitment to validate the success of the transmission: https://orthanc.uclouvain.be/book/users/storage-commitment.html#chaining-c-store-with-storage-commitment   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Timeout\": Timeout for the C-STORE command, in seconds</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>The Orthanc identifier of one resource to be sent</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_store(\n    self,\n    id_: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Trigger C-STORE SCU\n\n    Start a C-STORE SCU command as a job, in order to send DICOM resources stored locally to some remote DICOM modality whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#rest-store-scu\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"CalledAet\": Called AET that is used for this commands, defaults to `AET` configuration option. Allows you to overwrite the destination AET for a specific operation.\n          \"Host\": Host that is used for this commands, defaults to `Host` configuration option. Allows you to overwrite the destination host for a specific operation.\n          \"LocalAet\": Local AET that is used for this commands, defaults to `DicomAet` configuration option. Ignored if `DicomModalities` already sets `LocalAet` for this modality.\n          \"MoveOriginatorAet\": Move originator AET that is used for this commands, in order to fake a C-MOVE SCU\n          \"MoveOriginatorID\": Move originator ID that is used for this commands, in order to fake a C-MOVE SCU\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Port\": Port that is used for this command, defaults to `Port` configuration option. Allows you to overwrite the destination port for a specific operation.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n          \"StorageCommitment\": Whether to chain C-STORE with DICOM storage commitment to validate the success of the transmission: https://orthanc.uclouvain.be/book/users/storage-commitment.html#chaining-c-store-with-storage-commitment\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Timeout\": Timeout for the C-STORE command, in seconds\n\n    data\n        The Orthanc identifier of one resource to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/store\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_modalities_id_store_straight","title":"<code>post_modalities_id_store_straight(id_, content=None)</code>","text":"<p>Straight C-STORE SCU</p> <p>Synchronously send the DICOM instance in the POST body to the remote DICOM modality whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as <code>storescu</code> from DCMTK or dcm4che. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/dicom\") DICOM instance to be sent\n</code></pre> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_modalities_id_store_straight(\n    self,\n    id_: str,\n    content: RequestContent = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Straight C-STORE SCU\n\n    Synchronously send the DICOM instance in the POST body to the remote DICOM modality whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `storescu` from DCMTK or dcm4che.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    content\n            - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/modalities/{id_}/store-straight\",\n        content=content,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_anonymize","title":"<code>post_patients_id_anonymize(id_, json=None)</code>","text":"<p>Anonymize patient</p> <p>Start a job that will anonymize all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Anonymize patient\n\n    Start a job that will anonymize all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_archive","title":"<code>post_patients_id_archive(id_, json=None)</code>","text":"<p>Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_archive(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_attachments_name_compress","title":"<code>post_patients_id_attachments_name_compress(id_, name)</code>","text":"<p>Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_attachments_name_uncompress","title":"<code>post_patients_id_attachments_name_uncompress(id_, name)</code>","text":"<p>Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_attachments_name_verify_md5","title":"<code>post_patients_id_attachments_name_verify_md5(id_, name)</code>","text":"<p>Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_media","title":"<code>post_patients_id_media(id_, json=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_media(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_modify","title":"<code>post_patients_id_modify(id_, json=None)</code>","text":"<p>Modify patient</p> <p>Start a job that will modify all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Modify patient\n\n    Start a job that will modify all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_patients_id_reconstruct","title":"<code>post_patients_id_reconstruct(id_, json=None)</code>","text":"<p>Reconstruct tags &amp; optionally files of patient</p> <p>Reconstruct the main DICOM tags in DB of the patient whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_patients_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Reconstruct tags &amp; optionally files of patient\n\n    Reconstruct the main DICOM tags in DB of the patient whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/patients/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_peers_id_store","title":"<code>post_peers_id_store(id_, data=None, json=None)</code>","text":"<p>Send to Orthanc peer</p> <p>Send DICOM resources stored locally to some remote Orthanc peer whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#sending-one-resource Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Compress\": Whether to compress the DICOM instances using gzip before the actual sending   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode to the provided DICOM transfer syntax before the actual sending</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>The Orthanc identifier of one resource to be sent</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_peers_id_store(\n    self,\n    id_: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Send to Orthanc peer\n\n    Send DICOM resources stored locally to some remote Orthanc peer whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#sending-one-resource\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Compress\": Whether to compress the DICOM instances using gzip before the actual sending\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": List of the Orthanc identifiers of all the DICOM resources to be sent\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode to the provided DICOM transfer syntax before the actual sending\n\n    data\n        The Orthanc identifier of one resource to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/peers/{id_}/store\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_peers_id_store_straight","title":"<code>post_peers_id_store_straight(id_, content=None)</code>","text":"<p>Straight store to peer</p> <p>Synchronously send the DICOM instance in the POST body to the Orthanc peer whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as <code>curl</code>. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the modality of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/dicom\") DICOM instance to be sent\n</code></pre> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_peers_id_store_straight(\n    self,\n    id_: str,\n    content: RequestContent = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Straight store to peer\n\n    Synchronously send the DICOM instance in the POST body to the Orthanc peer whose identifier is provided in URL, without having to first store it locally within Orthanc. This is an alternative to command-line tools such as `curl`.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the modality of interest\n    content\n            - (Content-Type: \"application/dicom\") DICOM instance to be sent\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/peers/{id_}/store-straight\",\n        content=content,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_queries_id_answers_index_query_instances","title":"<code>post_queries_id_answers_index_query_instances(id_, index, json=None)</code>","text":"<p>Query the child instances of an answer</p> <p>Issue a second DICOM C-FIND operation, in order to query the child instances associated with one answer to some query/retrieve operation whose identifiers are provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_queries_id_answers_index_query_instances(\n    self,\n    id_: str,\n    index: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Query the child instances of an answer\n\n    Issue a second DICOM C-FIND operation, in order to query the child instances associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/query-instances\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_queries_id_answers_index_query_series","title":"<code>post_queries_id_answers_index_query_series(id_, index, json=None)</code>","text":"<p>Query the child series of an answer</p> <p>Issue a second DICOM C-FIND operation, in order to query the child series associated with one answer to some query/retrieve operation whose identifiers are provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_queries_id_answers_index_query_series(\n    self,\n    id_: str,\n    index: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Query the child series of an answer\n\n    Issue a second DICOM C-FIND operation, in order to query the child series associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/query-series\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_queries_id_answers_index_query_studies","title":"<code>post_queries_id_answers_index_query_studies(id_, index, json=None)</code>","text":"<p>Query the child studies of an answer</p> <p>Issue a second DICOM C-FIND operation, in order to query the child studies associated with one answer to some query/retrieve operation whose identifiers are provided in the URL Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_queries_id_answers_index_query_studies(\n    self,\n    id_: str,\n    index: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Query the child studies of an answer\n\n    Issue a second DICOM C-FIND operation, in order to query the child studies associated with one answer to some query/retrieve operation whose identifiers are provided in the URL\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Timeout\": Timeout for the C-FIND command, in seconds (new in Orthanc 1.9.1)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/query-studies\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_queries_id_answers_index_retrieve","title":"<code>post_queries_id_answers_index_retrieve(id_, index, data=None, json=None)</code>","text":"<p>Retrieve one answer with a C-MOVE or a C-GET SCU</p> <p>Start a C-MOVE or a C-GET SCU command as a job, in order to retrieve one answer associated with the query/retrieve operation whose identifiers are provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index of the answer</p> required <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod   \"Simplify\": If set to <code>true</code>, report the DICOM tags in human-readable format (using the symbolic name of the tags)   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the <code>DicomAet</code> configuration option.   \"Timeout\": Timeout for the C-MOVE command, in seconds</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>AET of the target modality</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_queries_id_answers_index_retrieve(\n    self,\n    id_: str,\n    index: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Retrieve one answer with a C-MOVE or a C-GET SCU\n\n    Start a C-MOVE or a C-GET SCU command as a job, in order to retrieve one answer associated with the query/retrieve operation whose identifiers are provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n    Tags: Networking\n\n    Parameters\n    ----------\n    index\n        Index of the answer\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n          \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n          \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n    data\n        AET of the target modality\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/queries/{id_}/answers/{index}/retrieve\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_queries_id_retrieve","title":"<code>post_queries_id_retrieve(id_, data=None, json=None)</code>","text":"<p>Retrieve all answers with C-MOVE SCU</p> <p>Start a C-MOVE SCU command as a job, in order to retrieve all the answers associated with the query/retrieve operation whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the query of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod   \"Simplify\": If set to <code>true</code>, report the DICOM tags in human-readable format (using the symbolic name of the tags)   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the <code>DicomAet</code> configuration option.   \"Timeout\": Timeout for the C-MOVE command, in seconds</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>AET of the target modality</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_queries_id_retrieve(\n    self,\n    id_: str,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Retrieve all answers with C-MOVE SCU\n\n    Start a C-MOVE SCU command as a job, in order to retrieve all the answers associated with the query/retrieve operation whose identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/rest.html#performing-retrieve-c-move\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the query of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"RetrieveMethod\": Force usage of C-MOVE or C-GET to retrieve the resource.  If note defined in the payload, the retrieve method is defined in the DicomDefaultRetrieveMethod configuration or in DicomModalities-&gt;..-&gt;RetrieveMethod\n          \"Simplify\": If set to `true`, report the DICOM tags in human-readable format (using the symbolic name of the tags)\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"TargetAet\": AET of the target modality. By default, the AET of Orthanc is used, as defined in the `DicomAet` configuration option.\n          \"Timeout\": Timeout for the C-MOVE command, in seconds\n\n    data\n        AET of the target modality\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/queries/{id_}/retrieve\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_anonymize","title":"<code>post_series_id_anonymize(id_, json=None)</code>","text":"<p>Anonymize series</p> <p>Start a job that will anonymize all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Anonymize series\n\n    Start a job that will anonymize all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/series/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_archive","title":"<code>post_series_id_archive(id_, json=None)</code>","text":"<p>Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_archive(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/series/{id_}/archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_attachments_name_compress","title":"<code>post_series_id_attachments_name_compress(id_, name)</code>","text":"<p>Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_attachments_name_uncompress","title":"<code>post_series_id_attachments_name_uncompress(id_, name)</code>","text":"<p>Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_attachments_name_verify_md5","title":"<code>post_series_id_attachments_name_verify_md5(id_, name)</code>","text":"<p>Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/series/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_media","title":"<code>post_series_id_media(id_, json=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_media(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/series/{id_}/media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_modify","title":"<code>post_series_id_modify(id_, json=None)</code>","text":"<p>Modify series</p> <p>Start a job that will modify all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Modify series\n\n    Start a job that will modify all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/series/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_series_id_reconstruct","title":"<code>post_series_id_reconstruct(id_, json=None)</code>","text":"<p>Reconstruct tags &amp; optionally files of series</p> <p>Reconstruct the main DICOM tags in DB of the series whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_series_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Reconstruct tags &amp; optionally files of series\n\n    Reconstruct the main DICOM tags in DB of the series whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Series\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the series of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/series/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_storage_commitment_id_remove","title":"<code>post_storage_commitment_id_remove(id_)</code>","text":"<p>Remove after storage commitment</p> <p>Remove out of Orthanc, the DICOM instances that have been reported to have been properly received the storage commitment report whose identifier is provided in the URL. This is only possible if the <code>Status</code> of the storage commitment report is <code>Success</code>. https://orthanc.uclouvain.be/book/users/storage-commitment.html#removing-the-instances Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the storage commitment report</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_storage_commitment_id_remove(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Remove after storage commitment\n\n    Remove out of Orthanc, the DICOM instances that have been reported to have been properly received the storage commitment report whose identifier is provided in the URL. This is only possible if the `Status` of the storage commitment report is `Success`. https://orthanc.uclouvain.be/book/users/storage-commitment.html#removing-the-instances\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the storage commitment report\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/storage-commitment/{id_}/remove\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_anonymize","title":"<code>post_studies_id_anonymize(id_, json=None)</code>","text":"<p>Anonymize study</p> <p>Start a job that will anonymize all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_anonymize(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Anonymize study\n\n    Start a job that will anonymize all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#anonymization-of-patients-studies-or-series\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_archive","title":"<code>post_studies_id_archive(id_, json=None)</code>","text":"<p>Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_archive(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_attachments_name_compress","title":"<code>post_studies_id_attachments_name_compress(id_, name)</code>","text":"<p>Compress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_attachments_name_compress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Compress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/compress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_attachments_name_uncompress","title":"<code>post_studies_id_attachments_name_uncompress(id_, name)</code>","text":"<p>Uncompress attachment</p> <p>Change the compression scheme that is used to store an attachment. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_attachments_name_uncompress(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Uncompress attachment\n\n    Change the compression scheme that is used to store an attachment.\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/uncompress\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_attachments_name_verify_md5","title":"<code>post_studies_id_attachments_name_verify_md5(id_, name)</code>","text":"<p>Verify attachment</p> <p>Verify that the attachment is not corrupted, by validating its MD5 hash Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>On success, a valid JSON object is returned</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_attachments_name_verify_md5(\n    self,\n    id_: str,\n    name: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Verify attachment\n\n    Verify that the attachment is not corrupted, by validating its MD5 hash\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        On success, a valid JSON object is returned\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}/verify-md5\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_media","title":"<code>post_studies_id_media(id_, json=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_media(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_merge","title":"<code>post_studies_id_merge(id_, json=None)</code>","text":"<p>Merge study</p> <p>Start a new job so as to move some DICOM resources into the DICOM study whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#merging Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"KeepSource\": If set to <code>true</code>, instructs Orthanc to keep a copy of the original resources in their source study. By default, the original resources are deleted from Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of DICOM resources (studies, series, and/or instances) to be merged into the study of interest (mandatory option)   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_merge(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Merge study\n\n    Start a new job so as to move some DICOM resources into the DICOM study whose Orthanc identifier is provided in the URL: https://orthanc.uclouvain.be/book/users/anonymization.html#merging\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original resources in their source study. By default, the original resources are deleted from Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of DICOM resources (studies, series, and/or instances) to be merged into the study of interest (mandatory option)\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/merge\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_modify","title":"<code>post_studies_id_modify(id_, json=None)</code>","text":"<p>Modify study</p> <p>Start a job that will modify all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_modify(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Modify study\n\n    Start a job that will modify all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://orthanc.uclouvain.be/book/users/anonymization.html#modification-of-studies-or-series\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_reconstruct","title":"<code>post_studies_id_reconstruct(id_, json=None)</code>","text":"<p>Reconstruct tags &amp; optionally files of study</p> <p>Reconstruct the main DICOM tags in DB of the study whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly. Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_reconstruct(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Reconstruct tags &amp; optionally files of study\n\n    Reconstruct the main DICOM tags in DB of the study whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"LimitToThisLevelMainDicomTags\": Only reconstruct this level MainDicomTags by re-reading them from a random child instance of the resource. This option is much faster than a full reconstruct and is useful e.g. if you have modified the 'ExtraMainDicomTags' at the Study level to optimize the speed of some C-Find. 'false' by default. (New in Orthanc 1.12.4)\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_studies_id_split","title":"<code>post_studies_id_split(id_, json=None)</code>","text":"<p>Split study</p> <p>Start a new job so as to split the DICOM study whose Orthanc identifier is provided in the URL, by taking some of its children series or instances out of it and putting them into a brand new study (this new study is created by setting the <code>StudyInstanceUID</code> tag to a random identifier): https://orthanc.uclouvain.be/book/users/anonymization.html#splitting Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Instances\": The list of instances to be separated from the parent study. These instances must all be children of the same source study, that is specified in the URI.   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepSource\": If set to <code>true</code>, instructs Orthanc to keep a copy of the original series/instances in the source study. By default, the original series/instances are deleted from Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Remove\": List of tags that must be removed in the new study (from the same modules as in the <code>Replace</code> option)   \"Replace\": Associative array to change the value of some DICOM tags in the new study. These tags must be part of the \"Patient Module Attributes\" or the \"General Study Module Attributes\", as specified by the DICOM 2011 standard in Tables C.7-1 and C.7-3.   \"Series\": The list of series to be separated from the parent study. These series must all be children of the same source study, that is specified in the URI.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_studies_id_split(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Split study\n\n    Start a new job so as to split the DICOM study whose Orthanc identifier is provided in the URL, by taking some of its children series or instances out of it and putting them into a brand new study (this new study is created by setting the `StudyInstanceUID` tag to a random identifier): https://orthanc.uclouvain.be/book/users/anonymization.html#splitting\n    Tags: Studies\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the study of interest\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Instances\": The list of instances to be separated from the parent study. These instances must all be children of the same source study, that is specified in the URI.\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepSource\": If set to `true`, instructs Orthanc to keep a copy of the original series/instances in the source study. By default, the original series/instances are deleted from Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Remove\": List of tags that must be removed in the new study (from the same modules as in the `Replace` option)\n          \"Replace\": Associative array to change the value of some DICOM tags in the new study. These tags must be part of the \"Patient Module Attributes\" or the \"General Study Module Attributes\", as specified by the DICOM 2011 standard in Tables C.7-1 and C.7-3.\n          \"Series\": The list of series to be separated from the parent study. These series must all be children of the same source study, that is specified in the URI.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/studies/{id_}/split\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_bulk_anonymize","title":"<code>post_tools_bulk_anonymize(json=None)</code>","text":"<p>Anonymize a set of resources</p> <p>Start a job that will anonymize all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option <code>DeidentifyLogsDicomVersion</code> for possible values.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"KeepLabels\": Keep the labels of all resources level (defaults to <code>false</code>)   \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to <code>false</code>)   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of all the resources that have been created by this anonymization</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_bulk_anonymize(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Anonymize a set of resources\n\n    Start a job that will anonymize all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"DicomVersion\": Version of the DICOM standard to be used for anonymization. Check out configuration option `DeidentifyLogsDicomVersion` for possible values.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": List of DICOM tags whose value must not be destroyed by the anonymization. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"KeepLabels\": Keep the labels of all resources level (defaults to `false`)\n          \"KeepPrivateTags\": Keep the private tags from the DICOM instances (defaults to `false`)\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of additional tags to be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of all the resources that have been created by this anonymization\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/bulk-anonymize\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_bulk_content","title":"<code>post_tools_bulk_content(json=None)</code>","text":"<p>Describe a set of resources</p> <p>Get the content all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field, in one single call. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Level\": This optional argument specifies the level of interest (can be <code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>). Orthanc will loop over the items inside <code>Resources</code>, and explore upward or downward in the DICOM hierarchy in order to find the level of interest.   \"Metadata\": If set to <code>true</code> (default value), the metadata associated with the resources will also be retrieved.   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_bulk_content(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Describe a set of resources\n\n    Get the content all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field, in one single call.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Level\": This optional argument specifies the level of interest (can be `Patient`, `Study`, `Series` or `Instance`). Orthanc will loop over the items inside `Resources`, and explore upward or downward in the DICOM hierarchy in order to find the level of interest.\n          \"Metadata\": If set to `true` (default value), the metadata associated with the resources will also be retrieved.\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/bulk-content\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_bulk_delete","title":"<code>post_tools_bulk_delete(json=None)</code>","text":"<p>Delete a set of resources</p> <p>Delete all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_bulk_delete(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Delete a set of resources\n\n    Delete all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/bulk-delete\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_bulk_modify","title":"<code>post_tools_bulk_modify(json=None)</code>","text":"<p>Modify a set of resources</p> <p>Start a job that will modify all the DICOM patients, studies, series or instances whose identifiers are provided in the <code>Resources</code> field. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.   \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world   \"Keep\": Keep the original value of the specified tags, to be chosen among the <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code> and <code>SOPInstanceUID</code> tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.   \"KeepSource\": If set to <code>false</code>, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.   \"Level\": Level of the modification (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>). If absent, the level defaults to <code>Instance</code>, but is set to <code>Patient</code> if <code>PatientID</code> is modified, to <code>Study</code> if <code>StudyInstanceUID</code> is modified, or to <code>Series</code> if <code>SeriesInstancesUID</code> is modified. (new in Orthanc 1.9.7)   \"Permissive\": If <code>true</code>, ignore errors during the individual steps of the job.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"PrivateCreator\": The private creator to be used for private tags in <code>Replace</code>   \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to <code>false</code>)   \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the <code>dcmodify</code> command-line tool (wildcards are supported as well).   \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.   \"Synchronous\": If <code>true</code>, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is not desirable for long jobs, as it might lead to network timeouts.   \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>The list of all the resources that have been altered by this modification</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_bulk_modify(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Modify a set of resources\n\n    Start a job that will modify all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, run the job in asynchronous mode, which means that the REST API call will immediately return, reporting the identifier of a job. Prefer this flavor wherever possible.\n          \"Force\": Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world\n          \"Keep\": Keep the original value of the specified tags, to be chosen among the `StudyInstanceUID`, `SeriesInstanceUID` and `SOPInstanceUID` tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.\n          \"KeepSource\": If set to `false`, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.\n          \"Level\": Level of the modification (`Patient`, `Study`, `Series` or `Instance`). If absent, the level defaults to `Instance`, but is set to `Patient` if `PatientID` is modified, to `Study` if `StudyInstanceUID` is modified, or to `Series` if `SeriesInstancesUID` is modified. (new in Orthanc 1.9.7)\n          \"Permissive\": If `true`, ignore errors during the individual steps of the job.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"PrivateCreator\": The private creator to be used for private tags in `Replace`\n          \"Remove\": List of tags that must be removed from the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"RemovePrivateTags\": Remove the private tags from the DICOM instances (defaults to `false`)\n          \"Replace\": Associative array to change the value of some DICOM tags in the DICOM instances. Starting with Orthanc 1.9.4, paths to subsequences can be provided using the same syntax as the `dcmodify` command-line tool (wildcards are supported as well).\n          \"Resources\": List of the Orthanc identifiers of the patients/studies/series/instances of interest.\n          \"Synchronous\": If `true`, run the job in synchronous mode, which means that the HTTP answer will directly contain the result of the job. This is the default, easy behavior, but it is *not* desirable for long jobs, as it might lead to network timeouts.\n          \"Transcode\": Transcode the DICOM instances to the provided DICOM transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        The list of all the resources that have been altered by this modification\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/bulk-modify\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_count_resources","title":"<code>post_tools_count_resources(json=None)</code>","text":"<p>Count local resources</p> <p>This URI can be used to count the resources that are matching criteria on the content of the local Orthanc server, in a way that is similar to tools/find Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)   \"LabelsConstraint\": Constraint on the labels, can be <code>All</code>, <code>Any</code>, or <code>None</code> (defaults to <code>All</code>, new in Orthanc 1.12.0)   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)   \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)   \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)   \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>A JSON object with the <code>Count</code> of matching resources</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_count_resources(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Count local resources\n\n    This URI can be used to count the resources that are matching criteria on the content of the local Orthanc server, in a way that is similar to tools/find\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n          \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n          \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n          \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n          \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        A JSON object with the `Count` of matching resources\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/count-resources\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_create_archive","title":"<code>post_tools_create_archive(json=None)</code>","text":"<p>Create ZIP archive</p> <p>Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of Orthanc identifiers of interest.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_create_archive(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create ZIP archive\n\n    Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of Orthanc identifiers of interest.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/create-archive\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_create_dicom","title":"<code>post_tools_create_dicom(json=None)</code>","text":"<p>Create one DICOM instance</p> <p>Create one DICOM instance, and store it into Orthanc Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Content\": This field can be used to embed an image (pixel data encoded as PNG or JPEG), a PDF, or a 3D manufactoring model (MTL/OBJ/STL) inside the created DICOM instance. The file to be encapsulated must be provided using its data URI scheme encoding. This field can possibly contain a JSON array, in which case a DICOM series is created containing one DICOM instance for each item in the <code>Content</code> field.   \"Force\": Avoid the consistency checks for the DICOM tags that enforce the DICOM model of the real-world. You can notably use this flag if you need to manually set the tags <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code>, or <code>SOPInstanceUID</code>. Be careful with this feature.   \"InterpretBinaryTags\": If some value in the <code>Tags</code> associative array is formatted according to some data URI scheme encoding, whether this value is decoded to a binary value or kept as such (<code>true</code> by default)   \"Parent\": If present, the newly created instance will be attached to the parent DICOM resource whose Orthanc identifier is contained in this field. The DICOM tags of the parent modules in the DICOM hierarchy will be automatically copied to the newly created instance.   \"PrivateCreator\": The private creator to be used for private tags in <code>Tags</code>   \"Tags\": Associative array containing the tags of the new instance to be created</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_create_dicom(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create one DICOM instance\n\n    Create one DICOM instance, and store it into Orthanc\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Content\": This field can be used to embed an image (pixel data encoded as PNG or JPEG), a PDF, or a 3D manufactoring model (MTL/OBJ/STL) inside the created DICOM instance. The file to be encapsulated must be provided using its [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme). This field can possibly contain a JSON array, in which case a DICOM series is created containing one DICOM instance for each item in the `Content` field.\n          \"Force\": Avoid the consistency checks for the DICOM tags that enforce the DICOM model of the real-world. You can notably use this flag if you need to manually set the tags `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`. Be careful with this feature.\n          \"InterpretBinaryTags\": If some value in the `Tags` associative array is formatted according to some [data URI scheme encoding](https://en.wikipedia.org/wiki/Data_URI_scheme), whether this value is decoded to a binary value or kept as such (`true` by default)\n          \"Parent\": If present, the newly created instance will be attached to the parent DICOM resource whose Orthanc identifier is contained in this field. The DICOM tags of the parent modules in the DICOM hierarchy will be automatically copied to the newly created instance.\n          \"PrivateCreator\": The private creator to be used for private tags in `Tags`\n          \"Tags\": Associative array containing the tags of the new instance to be created\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/create-dicom\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_create_media","title":"<code>post_tools_create_media(json=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>false</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of Orthanc identifiers of interest.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_create_media(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `false`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of Orthanc identifiers of interest.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/create-media\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_create_media_extended","title":"<code>post_tools_create_media_extended(json=None)</code>","text":"<p>Create DICOMDIR media</p> <p>Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"Asynchronous\": If <code>true</code>, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.   \"Extended\": If <code>true</code>, will include additional tags such as <code>SeriesDescription</code>, leading to a so-called extended DICOMDIR. Default value is <code>true</code>.   \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.   \"Resources\": The list of Orthanc identifiers of interest.   \"Synchronous\": If <code>true</code>, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.   \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs In synchronous mode, the ZIP file containing the archive</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_create_media_extended(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Create DICOMDIR media\n\n    Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"Asynchronous\": If `true`, create the archive in asynchronous mode, which means that a job is submitted to create the archive in background.\n          \"Extended\": If `true`, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*. Default value is `true`.\n          \"Priority\": In asynchronous mode, the priority of the job. The higher the value, the higher the priority.\n          \"Resources\": The list of Orthanc identifiers of interest.\n          \"Synchronous\": If `true`, create the archive in synchronous mode, which means that the HTTP answer will directly contain the ZIP file. This is the default, easy behavior. However, if global configuration option \"SynchronousZipStream\" is set to \"false\", asynchronous transfers should be preferred for large amount of data, as the creation of the temporary file might lead to network timeouts.\n          \"Transcode\": If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://orthanc.uclouvain.be/book/faq/transcoding.html\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        In asynchronous mode, information about the job that has been submitted to generate the archive: https://orthanc.uclouvain.be/book/users/advanced-rest.html#jobs\n        In synchronous mode, the ZIP file containing the archive\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/create-media-extended\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_dicom_echo","title":"<code>post_tools_dicom_echo(json=None)</code>","text":"<p>Trigger C-ECHO SCU</p> <p>Trigger C-ECHO SCU command against a DICOM modality described in the POST body, without having to register the modality in some <code>/modalities/{id}</code> (new in Orthanc 1.8.1) Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"AET\": AET of the remote DICOM modality   \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the <code>DicomEchoChecksFind</code> configuration option. New in Orthanc 1.8.1.   \"Host\": Host address of the remote DICOM modality (typically, an IP address)   \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality   \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option <code>DicomModalities</code> for possible values   \"Port\": TCP port of the remote DICOM modality   \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality   \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_dicom_echo(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Trigger C-ECHO SCU\n\n    Trigger C-ECHO SCU command against a DICOM modality described in the POST body, without having to register the modality in some `/modalities/{id}` (new in Orthanc 1.8.1)\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"AET\": AET of the remote DICOM modality\n          \"CheckFind\": Issue a dummy C-FIND command after the C-GET SCU, in order to check whether the remote modality knows about Orthanc. This field defaults to the value of the `DicomEchoChecksFind` configuration option. New in Orthanc 1.8.1.\n          \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n          \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n          \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n          \"Port\": TCP port of the remote DICOM modality\n          \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n          \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/dicom-echo\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_execute_script","title":"<code>post_tools_execute_script(data=None)</code>","text":"<p>Execute Lua script</p> <p>Execute the provided Lua script by the Orthanc server. This is very insecure for Orthanc servers that are remotely accessible.  Since Orthanc 1.5.8, this route is disabled by default and can be enabled thanks to the <code>ExecuteLuaEnabled</code> configuration. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>The Lua script to be executed</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Output of the Lua script</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_execute_script(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Execute Lua script\n\n    Execute the provided Lua script by the Orthanc server. This is very insecure for Orthanc servers that are remotely accessible.  Since Orthanc 1.5.8, this route is disabled by default and can be enabled thanks to the `ExecuteLuaEnabled` configuration.\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        The Lua script to be executed\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Output of the Lua script\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/tools/execute-script\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_find","title":"<code>post_tools_find(json=None)</code>","text":"<p>Look for local resources</p> <p>This URI can be used to perform a search on the content of the local Orthanc server, in a way that is similar to querying remote DICOM modalities using C-FIND SCU: https://orthanc.uclouvain.be/book/users/rest.html#performing-finds-within-orthanc Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"CaseSensitive\": Enable case-sensitive search for PN value representations (defaults to configuration option <code>CaseSensitivePN</code>)   \"Expand\": If set to \"true\", retrieve detailed information about the individual resources, not only their Orthanc identifiers   \"Full\": If set to <code>true</code>, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)   \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)   \"LabelsConstraint\": Constraint on the labels, can be <code>All</code>, <code>Any</code>, or <code>None</code> (defaults to <code>All</code>, new in Orthanc 1.12.0)   \"Level\": Level of the query (<code>Patient</code>, <code>Study</code>, <code>Series</code> or <code>Instance</code>)   \"Limit\": Limit the number of reported resources   \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)   \"OrderBy\": Array of associative arrays containing the requested ordering (new in Orthanc 1.12.5)   \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)   \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)   \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)   \"Query\": Associative array containing the filter on the values of the DICOM tags   \"RequestedTags\": A list of DICOM tags to include in the response (applicable only if \"Expand\" is set to true).  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.   \"ResponseContent\": Defines the content of response for each returned resource. (this field, if present, overrides the \"Expand\" field).  Allowed values are <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>, <code>Attachments</code>.  If not specified, Orthanc will return <code>MainDicomTags</code>, <code>Metadata</code>, <code>Children</code>, <code>Parent</code>, <code>Labels</code>, <code>Status</code>, <code>IsStable</code>.(new in Orthanc 1.12.5)   \"Short\": If set to <code>true</code>, report the DICOM tags in hexadecimal format   \"Since\": Show only the resources since the provided index (in conjunction with <code>Limit</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing either the Orthanc identifiers, or detailed information about the reported resources (if <code>Expand</code> argument is <code>true</code>)</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_find(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Look for local resources\n\n    This URI can be used to perform a search on the content of the local Orthanc server, in a way that is similar to querying remote DICOM modalities using C-FIND SCU: https://orthanc.uclouvain.be/book/users/rest.html#performing-finds-within-orthanc\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"CaseSensitive\": Enable case-sensitive search for PN value representations (defaults to configuration option `CaseSensitivePN`)\n          \"Expand\": If set to \"true\", retrieve detailed information about the individual resources, not only their Orthanc identifiers\n          \"Full\": If set to `true`, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)\n          \"Labels\": List of strings specifying which labels to look for in the resources (new in Orthanc 1.12.0)\n          \"LabelsConstraint\": Constraint on the labels, can be `All`, `Any`, or `None` (defaults to `All`, new in Orthanc 1.12.0)\n          \"Level\": Level of the query (`Patient`, `Study`, `Series` or `Instance`)\n          \"Limit\": Limit the number of reported resources\n          \"MetadataQuery\": Associative array containing the filter on the values of the metadata (new in Orthanc 1.12.5)\n          \"OrderBy\": Array of associative arrays containing the requested ordering (new in Orthanc 1.12.5)\n          \"ParentPatient\": Limit the reported resources to descendants of this patient (new in Orthanc 1.12.5)\n          \"ParentSeries\": Limit the reported resources to descendants of this series (new in Orthanc 1.12.5)\n          \"ParentStudy\": Limit the reported resources to descendants of this study (new in Orthanc 1.12.5)\n          \"Query\": Associative array containing the filter on the values of the DICOM tags\n          \"RequestedTags\": A list of DICOM tags to include in the response (applicable only if \"Expand\" is set to true).  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return all Main Dicom Tags to keep backward compatibility with Orthanc prior to 1.11.0.\n          \"ResponseContent\": Defines the content of response for each returned resource. (this field, if present, overrides the \"Expand\" field).  Allowed values are `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`, `Attachments`.  If not specified, Orthanc will return `MainDicomTags`, `Metadata`, `Children`, `Parent`, `Labels`, `Status`, `IsStable`.(new in Orthanc 1.12.5)\n          \"Short\": If set to `true`, report the DICOM tags in hexadecimal format\n          \"Since\": Show only the resources since the provided index (in conjunction with `Limit`)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing either the Orthanc identifiers, or detailed information about the reported resources (if `Expand` argument is `true`)\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/find\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_invalid_ate_tags","title":"<code>post_tools_invalid_ate_tags()</code>","text":"<p>Invalidate DICOM-as-JSON summaries</p> <p>Remove all the attachments of the type \"DICOM-as-JSON\" that are associated will all the DICOM instances stored in Orthanc. These summaries will be automatically re-created on the next access. This is notably useful after changes to the <code>Dictionary</code> configuration option. https://orthanc.uclouvain.be/book/faq/orthanc-storage.html#storage-area Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_invalid_ate_tags(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Invalidate DICOM-as-JSON summaries\n\n    Remove all the attachments of the type \"DICOM-as-JSON\" that are associated will all the DICOM instances stored in Orthanc. These summaries will be automatically re-created on the next access. This is notably useful after changes to the `Dictionary` configuration option. https://orthanc.uclouvain.be/book/faq/orthanc-storage.html#storage-area\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/tools/invalid_ate-tags\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_lookup","title":"<code>post_tools_lookup(data=None)</code>","text":"<p>Look for DICOM identifiers</p> <p>This URI can be used to convert one DICOM identifier to a list of matching Orthanc resources Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>The DICOM identifier of interest (i.e. the value of <code>PatientID</code>, <code>StudyInstanceUID</code>, <code>SeriesInstanceUID</code>, or <code>SOPInstanceUID</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing a list of matching Orthanc resources, each item in the list corresponding to a JSON object with the fields <code>Type</code>, <code>ID</code> and <code>Path</code> identifying one DICOM resource that is stored by Orthanc</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_lookup(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Look for DICOM identifiers\n\n    This URI can be used to convert one DICOM identifier to a list of matching Orthanc resources\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        The DICOM identifier of interest (i.e. the value of `PatientID`, `StudyInstanceUID`, `SeriesInstanceUID`, or `SOPInstanceUID`)\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing a list of matching Orthanc resources, each item in the list corresponding to a JSON object with the fields `Type`, `ID` and `Path` identifying one DICOM resource that is stored by Orthanc\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/tools/lookup\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_reconstruct","title":"<code>post_tools_reconstruct(json=None)</code>","text":"<p>Reconstruct all the index</p> <p>Reconstruct the index of all the tags of all the DICOM instances that are stored in Orthanc. This is notably useful after the deletion of resources whose children resources have inconsistent values with their sibling resources. Beware that this is a highly time-consuming operation, as all the DICOM instances will be parsed again, and as all the Orthanc index will be regenerated. If you have a large database to process, it is advised to use the Housekeeper plugin to perform this action resource by resource Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_reconstruct(\n    self,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Reconstruct all the index\n\n    Reconstruct the index of all the tags of all the DICOM instances that are stored in Orthanc. This is notably useful after the deletion of resources whose children resources have inconsistent values with their sibling resources. Beware that this is a highly time-consuming operation, as all the DICOM instances will be parsed again, and as all the Orthanc index will be regenerated. If you have a large database to process, it is advised to use the Housekeeper plugin to perform this action resource by resource\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n          \"ReconstructFiles\": Also reconstruct the files of the resources (e.g: apply IngestTranscoding, StorageCompression). 'false' by default. (New in Orthanc 1.11.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._post(\n        route=f\"{self.url}/tools/reconstruct\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_reset","title":"<code>post_tools_reset()</code>","text":"<p>Restart Orthanc</p> <p>Restart Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_reset(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Restart Orthanc\n\n    Restart Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/tools/reset\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.post_tools_shutdown","title":"<code>post_tools_shutdown()</code>","text":"<p>Shutdown Orthanc</p> <p>Shutdown Orthanc Tags: System</p> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def post_tools_shutdown(\n    self,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Shutdown Orthanc\n\n    Shutdown Orthanc\n    Tags: System\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._post(\n        route=f\"{self.url}/tools/shutdown\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_instances_id_attachments_name","title":"<code>put_instances_id_attachments_name(id_, name, content=None, headers=None)</code>","text":"<p>Set attachment</p> <p>Attach a file to the given DICOM instance. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_instances_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set attachment\n\n    Attach a file to the given DICOM instance. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/instances/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_instances_id_labels_label","title":"<code>put_instances_id_labels_label(id_, label)</code>","text":"<p>Add label</p> <p>Associate a label with a instance Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_instances_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Add label\n\n    Associate a label with a instance\n    Tags: Instances\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the instance of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/instances/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_instances_id_metadata_name","title":"<code>put_instances_id_metadata_name(id_, name, data=None, headers=None)</code>","text":"<p>Set metadata</p> <p>Set the value of some metadata in the given DICOM instance. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Instances</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the instance of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_instances_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set metadata\n\n    Set the value of some metadata in the given DICOM instance. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Instances\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the instance of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/instances/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_modalities_id","title":"<code>put_modalities_id(id_, json=None)</code>","text":"<p>Update DICOM modality</p> <p>Define a new DICOM modality, or update an existing one. This change is permanent iff. <code>DicomModalitiesInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the new/updated DICOM modality</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"AET\": AET of the remote DICOM modality   \"AllowEcho\": Whether to accept C-ECHO SCU commands issued by the remote modality   \"AllowFind\": Whether to accept C-FIND SCU commands issued by the remote modality   \"AllowFindWorklist\": Whether to accept C-FIND SCU commands for worklists issued by the remote modality   \"AllowGet\": Whether to accept C-GET SCU commands issued by the remote modality   \"AllowMove\": Whether to accept C-MOVE SCU commands issued by the remote modality   \"AllowStorageCommitment\": Whether to accept storage commitment requests issued by the remote modality   \"AllowStore\": Whether to accept C-STORE SCU commands issued by the remote modality   \"AllowTranscoding\": Whether to allow transcoding for operations initiated by this modality. This option applies to Orthanc C-GET SCP and to Orthanc C-STORE SCU. It only has an effect if the global option <code>EnableTranscoding</code> is set to <code>true</code>.   \"Host\": Host address of the remote DICOM modality (typically, an IP address)   \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality   \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option <code>DicomModalities</code> for possible values   \"Port\": TCP port of the remote DICOM modality   \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality   \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_modalities_id(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Update DICOM modality\n\n    Define a new DICOM modality, or update an existing one. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the new/updated DICOM modality\n    json\n        Dictionary with the following keys:\n          \"AET\": AET of the remote DICOM modality\n          \"AllowEcho\": Whether to accept C-ECHO SCU commands issued by the remote modality\n          \"AllowFind\": Whether to accept C-FIND SCU commands issued by the remote modality\n          \"AllowFindWorklist\": Whether to accept C-FIND SCU commands for worklists issued by the remote modality\n          \"AllowGet\": Whether to accept C-GET SCU commands issued by the remote modality\n          \"AllowMove\": Whether to accept C-MOVE SCU commands issued by the remote modality\n          \"AllowStorageCommitment\": Whether to accept storage commitment requests issued by the remote modality\n          \"AllowStore\": Whether to accept C-STORE SCU commands issued by the remote modality\n          \"AllowTranscoding\": Whether to allow transcoding for operations initiated by this modality. This option applies to Orthanc C-GET SCP and to Orthanc C-STORE SCU. It only has an effect if the global option `EnableTranscoding` is set to `true`.\n          \"Host\": Host address of the remote DICOM modality (typically, an IP address)\n          \"LocalAet\": Whether to override the default DicomAet in the SCU connection initiated by Orthanc to this modality\n          \"Manufacturer\": Manufacturer of the remote DICOM modality (check configuration option `DicomModalities` for possible values\n          \"Port\": TCP port of the remote DICOM modality\n          \"Timeout\": Whether to override the default DicomScuTimeout in the SCU connection initiated by Orthanc to this modality\n          \"UseDicomTls\": Whether to use DICOM TLS in the SCU connection initiated by Orthanc (new in Orthanc 1.9.0)\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._put(\n        route=f\"{self.url}/modalities/{id_}\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_patients_id_attachments_name","title":"<code>put_patients_id_attachments_name(id_, name, content=None, headers=None)</code>","text":"<p>Set attachment</p> <p>Attach a file to the given DICOM patient. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_patients_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set attachment\n\n    Attach a file to the given DICOM patient. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/patients/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_patients_id_labels_label","title":"<code>put_patients_id_labels_label(id_, label)</code>","text":"<p>Add label</p> <p>Associate a label with a patient Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_patients_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Add label\n\n    Associate a label with a patient\n    Tags: Patients\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/patients/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_patients_id_metadata_name","title":"<code>put_patients_id_metadata_name(id_, name, data=None, headers=None)</code>","text":"<p>Set metadata</p> <p>Set the value of some metadata in the given DICOM patient. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_patients_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set metadata\n\n    Set the value of some metadata in the given DICOM patient. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Patients\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the patient of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/patients/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_patients_id_protected","title":"<code>put_patients_id_protected(id_)</code>","text":"<p>Protect/Unprotect a patient against recycling</p> <p>Protects a patient by sending <code>1</code> or <code>true</code> in the payload request. Unprotects a patient by sending <code>0</code> or <code>false</code> in the payload requests. More info: https://orthanc.uclouvain.be/book/faq/features.html#recycling-protection Tags: Patients</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the patient of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_patients_id_protected(\n    self,\n    id_: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Protect/Unprotect a patient against recycling\n\n    Protects a patient by sending `1` or `true` in the payload request. Unprotects a patient by sending `0` or `false` in the payload requests. More info: https://orthanc.uclouvain.be/book/faq/features.html#recycling-protection\n    Tags: Patients\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the patient of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/patients/{id_}/protected\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_peers_id","title":"<code>put_peers_id(id_, json=None)</code>","text":"<p>Update Orthanc peer</p> <p>Define a new Orthanc peer, or update an existing one. This change is permanent iff. <code>OrthancPeersInDatabase</code> is <code>true</code>, otherwise it is lost at the next restart of Orthanc. Tags: Networking</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Identifier of the new/updated Orthanc peer</p> required <code>json</code> <code>Any</code> <p>Dictionary with the following keys:   \"CertificateFile\": SSL certificate for the HTTPS connections   \"CertificateKeyFile\": Key file for the SSL certificate for the HTTPS connections   \"CertificateKeyPassword\": Key password for the SSL certificate for the HTTPS connections   \"HttpHeaders\": HTTP headers to be used for the connections to the remote peer   \"Password\": Password for the credentials   \"URL\": URL of the root of the REST API of the remote Orthanc peer, for instance <code>http://localhost:8042/</code>   \"Username\": Username for the credentials</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_peers_id(\n    self,\n    id_: str,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Update Orthanc peer\n\n    Define a new Orthanc peer, or update an existing one. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.\n    Tags: Networking\n\n    Parameters\n    ----------\n    id_\n        Identifier of the new/updated Orthanc peer\n    json\n        Dictionary with the following keys:\n          \"CertificateFile\": SSL certificate for the HTTPS connections\n          \"CertificateKeyFile\": Key file for the SSL certificate for the HTTPS connections\n          \"CertificateKeyPassword\": Key password for the SSL certificate for the HTTPS connections\n          \"HttpHeaders\": HTTP headers to be used for the connections to the remote peer\n          \"Password\": Password for the credentials\n          \"URL\": URL of the root of the REST API of the remote Orthanc peer, for instance `http://localhost:8042/`\n          \"Username\": Username for the credentials\n\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._put(\n        route=f\"{self.url}/peers/{id_}\",\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_series_id_attachments_name","title":"<code>put_series_id_attachments_name(id_, name, content=None, headers=None)</code>","text":"<p>Set attachment</p> <p>Attach a file to the given DICOM series. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_series_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set attachment\n\n    Attach a file to the given DICOM series. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/series/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_series_id_labels_label","title":"<code>put_series_id_labels_label(id_, label)</code>","text":"<p>Add label</p> <p>Associate a label with a series Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_series_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Add label\n\n    Associate a label with a series\n    Tags: Series\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the series of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/series/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_series_id_metadata_name","title":"<code>put_series_id_metadata_name(id_, name, data=None, headers=None)</code>","text":"<p>Set metadata</p> <p>Set the value of some metadata in the given DICOM series. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Series</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the series of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_series_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set metadata\n\n    Set the value of some metadata in the given DICOM series. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Series\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the series of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/series/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_studies_id_attachments_name","title":"<code>put_studies_id_attachments_name(id_, name, content=None, headers=None)</code>","text":"<p>Set attachment</p> <p>Attach a file to the given DICOM study. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attachment, or its index (cf. <code>UserContentType</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>content</code> <code>RequestContent</code> <pre><code>- (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n</code></pre> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>Empty JSON object in the case of a success</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_studies_id_attachments_name(\n    self,\n    id_: str,\n    name: str,\n    content: RequestContent = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set attachment\n\n    Attach a file to the given DICOM study. This call will fail if trying to modify a system attachment (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the attachment, or its index (cf. `UserContentType` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    content\n            - (Content-Type: \"application/octet-stream\") Binary data containing the attachment\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the attachment, if this is not the first time this attachment is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        Empty JSON object in the case of a success\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/studies/{id_}/attachments/{name}\",\n        content=content,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_studies_id_labels_label","title":"<code>put_studies_id_labels_label(id_, label)</code>","text":"<p>Add label</p> <p>Associate a label with a study Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label to be added</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_studies_id_labels_label(\n    self,\n    id_: str,\n    label: str,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Add label\n\n    Associate a label with a study\n    Tags: Studies\n\n    Parameters\n    ----------\n    label\n        The label to be added\n    id_\n        Orthanc identifier of the study of interest\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/studies/{id_}/labels/{label}\",\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_studies_id_metadata_name","title":"<code>put_studies_id_metadata_name(id_, name, data=None, headers=None)</code>","text":"<p>Set metadata</p> <p>Set the value of some metadata in the given DICOM study. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024). Tags: Studies</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metadata, or its index (cf. <code>UserMetadata</code> configuration option)</p> required <code>id_</code> <code>str</code> <p>Orthanc identifier of the study of interest</p> required <code>data</code> <code>RequestData</code> <p>String value of the metadata</p> <code>None</code> <code>headers</code> <code>HeaderTypes</code> <p>Dictionary of optional headers:     \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_studies_id_metadata_name(\n    self,\n    id_: str,\n    name: str,\n    data: RequestData = None,\n    headers: HeaderTypes = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set metadata\n\n    Set the value of some metadata in the given DICOM study. This call will fail if trying to modify a system metadata (i.e. whose index is &lt; 1024).\n    Tags: Studies\n\n    Parameters\n    ----------\n    name\n        The name of the metadata, or its index (cf. `UserMetadata` configuration option)\n    id_\n        Orthanc identifier of the study of interest\n    data\n        String value of the metadata\n    headers\n        Dictionary of optional headers:\n            \"If-Match\" (str): Revision of the metadata, if this is not the first time this metadata is set.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/studies/{id_}/metadata/{name}\",\n        data=data,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_accepted_transfer_syntaxes","title":"<code>put_tools_accepted_transfer_syntaxes(data=None, json=None)</code>","text":"<p>Set accepted transfer syntaxes</p> <p>Set the DICOM transfer syntaxes that accepted by Orthanc C-STORE SCP Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>Any</code> <p>Dictionary with the following keys:</p> <code>None</code> <code>data</code> <code>RequestData</code> <p>UID of the transfer syntax to be accepted. Wildcards <code>?</code> and <code>*</code> are accepted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> <p>JSON array containing the now-accepted transfer syntax UIDs</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_accepted_transfer_syntaxes(\n    self,\n    data: RequestData = None,\n    json: Any = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set accepted transfer syntaxes\n\n    Set the DICOM transfer syntaxes that accepted by Orthanc C-STORE SCP\n    Tags: System\n\n    Parameters\n    ----------\n    json\n        Dictionary with the following keys:\n\n    data\n        UID of the transfer syntax to be accepted. Wildcards `?` and `*` are accepted.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n        JSON array containing the now-accepted transfer syntax UIDs\n    \"\"\"\n    if json is None:\n        json = {}\n    return self._put(\n        route=f\"{self.url}/tools/accepted-transfer-syntaxes\",\n        data=data,\n        json=json,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_default_encoding","title":"<code>put_tools_default_encoding(data=None)</code>","text":"<p>Set default encoding</p> <p>Change the default encoding that is used by Orthanc if parsing a DICOM instance without the <code>SpecificCharacterEncoding</code> tag, or during C-FIND. This corresponds to the configuration option <code>DefaultEncoding</code>. Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>The name of the encoding. Check out configuration option <code>DefaultEncoding</code> for the allowed values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_default_encoding(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set default encoding\n\n    Change the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        The name of the encoding. Check out configuration option `DefaultEncoding` for the allowed values.\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/default-encoding\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level","title":"<code>put_tools_log_level(data=None)</code>","text":"<p>Set main log level</p> <p>Set the main log level of Orthanc Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set main log level\n\n    Set the main log level of Orthanc\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level_dicom","title":"<code>put_tools_log_level_dicom(data=None)</code>","text":"<p>Set log level for <code>dicom</code></p> <p>Set the log level of the log category <code>dicom</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level_dicom(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set log level for `dicom`\n\n    Set the log level of the log category `dicom`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level-dicom\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level_generic","title":"<code>put_tools_log_level_generic(data=None)</code>","text":"<p>Set log level for <code>generic</code></p> <p>Set the log level of the log category <code>generic</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level_generic(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set log level for `generic`\n\n    Set the log level of the log category `generic`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level-generic\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level_http","title":"<code>put_tools_log_level_http(data=None)</code>","text":"<p>Set log level for <code>http</code></p> <p>Set the log level of the log category <code>http</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level_http(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set log level for `http`\n\n    Set the log level of the log category `http`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level-http\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level_jobs","title":"<code>put_tools_log_level_jobs(data=None)</code>","text":"<p>Set log level for <code>jobs</code></p> <p>Set the log level of the log category <code>jobs</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level_jobs(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set log level for `jobs`\n\n    Set the log level of the log category `jobs`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level-jobs\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level_lua","title":"<code>put_tools_log_level_lua(data=None)</code>","text":"<p>Set log level for <code>lua</code></p> <p>Set the log level of the log category <code>lua</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level_lua(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set log level for `lua`\n\n    Set the log level of the log category `lua`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level-lua\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level_plugins","title":"<code>put_tools_log_level_plugins(data=None)</code>","text":"<p>Set log level for <code>plugins</code></p> <p>Set the log level of the log category <code>plugins</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level_plugins(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set log level for `plugins`\n\n    Set the log level of the log category `plugins`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level-plugins\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_log_level_sqlite","title":"<code>put_tools_log_level_sqlite(data=None)</code>","text":"<p>Set log level for <code>sqlite</code></p> <p>Set the log level of the log category <code>sqlite</code> Tags: Logs</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p>Possible values: <code>default</code>, <code>verbose</code> or <code>trace</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_log_level_sqlite(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set log level for `sqlite`\n\n    Set the log level of the log category `sqlite`\n    Tags: Logs\n\n    Parameters\n    ----------\n    data\n        Possible values: `default`, `verbose` or `trace`\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/log-level-sqlite\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_metrics","title":"<code>put_tools_metrics(data=None)</code>","text":"<p>Enable collection of metrics</p> <p>Enable or disable the collection and publication of metrics at <code>/tools/metrics-prometheus</code> Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p><code>1</code> if metrics are collected, <code>0</code> if metrics are disabled</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_metrics(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Enable collection of metrics\n\n    Enable or disable the collection and publication of metrics at `/tools/metrics-prometheus`\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        `1` if metrics are collected, `0` if metrics are disabled\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/metrics\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.put_tools_unknown_sop_class_accepted","title":"<code>put_tools_unknown_sop_class_accepted(data=None)</code>","text":"<p>Set unknown SOP class accepted</p> <p>Set whether Orthanc C-STORE SCP should accept DICOM instances with an unknown SOP class UID Tags: System</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>RequestData</code> <p><code>1</code> if accepted, <code>0</code> if not accepted</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict, List, str, bytes, int, Response]</code> Source code in <code>pyorthanc/client.py</code> <pre><code>def put_tools_unknown_sop_class_accepted(\n    self,\n    data: RequestData = None,\n) -&gt; Union[Dict, List, str, bytes, int, httpx.Response]:\n    \"\"\"Set unknown SOP class accepted\n\n    Set whether Orthanc C-STORE SCP should accept DICOM instances with an unknown SOP class UID\n    Tags: System\n\n    Parameters\n    ----------\n    data\n        `1` if accepted, `0` if not accepted\n\n    Returns\n    -------\n    Union[Dict, List, str, bytes, int, httpx.Response]\n    \"\"\"\n    return self._put(\n        route=f\"{self.url}/tools/unknown-sop-class-accepted\",\n        data=data,\n    )\n</code></pre>"},{"location":"api/client/#pyorthanc.Orthanc.setup_credentials","title":"<code>setup_credentials(username, password)</code>","text":"<p>Set credentials needed for HTTP requests</p> Source code in <code>pyorthanc/client.py</code> <pre><code>def setup_credentials(self, username: str, password: str) -&gt; None:\n    \"\"\"Set credentials needed for HTTP requests\"\"\"\n    self._auth = httpx.BasicAuth(username, password)\n</code></pre>"},{"location":"api/filtering/","title":"Filtering","text":""},{"location":"api/filtering/#pyorthanc.find","title":"<code>pyorthanc.find(orthanc, patient_filter=None, study_filter=None, series_filter=None, instance_filter=None)</code>","text":"<p>Find desired patients/Study/Series/Instance in an Orthanc server</p> <p>This function builds a series of tree structure. Each tree correspond to a patient. The layers in the tree correspond to:</p> <p><code>Patient -&gt; Studies -&gt; Series -&gt; Instances</code></p> <p>Parameters:</p> Name Type Description Default <code>orthanc</code> <code>Union[Orthanc, AsyncOrthanc]</code> <p>Orthanc object.</p> required <code>patient_filter</code> <code>Optional[Callable]</code> <p>Patient filter (e.g. lambda patient: patient.id_ == '03HDQ99*')</p> <code>None</code> <code>study_filter</code> <code>Optional[Callable]</code> <p>Study filter (e.g. lambda study: study.study_id == 'pros')</p> <code>None</code> <code>series_filter</code> <code>Optional[Callable]</code> <p>Series filter (e.g. lambda series: series.modality == 'SR')</p> <code>None</code> <code>instance_filter</code> <code>Optional[Callable]</code> <p>Instance filter (e.g. lambda instance: instance.SOPInstance == '...')</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Patient]</code> <p>List of patients that respect .</p> Source code in <code>pyorthanc/_filtering.py</code> <pre><code>def find(orthanc: Union[Orthanc, AsyncOrthanc],\n         patient_filter: Optional[Callable] = None,\n         study_filter: Optional[Callable] = None,\n         series_filter: Optional[Callable] = None,\n         instance_filter: Optional[Callable] = None) -&gt; List[Patient]:\n    \"\"\"Find desired patients/Study/Series/Instance in an Orthanc server\n\n    This function builds a series of tree structure.\n    Each tree correspond to a patient. The layers in the\n    tree correspond to:\n\n    `Patient -&gt; Studies -&gt; Series -&gt; Instances`\n\n    Parameters\n    ----------\n    orthanc\n        Orthanc object.\n    patient_filter\n        Patient filter (e.g. lambda patient: patient.id_ == '03HDQ99*')\n    study_filter\n        Study filter (e.g. lambda study: study.study_id == '*pros*')\n    series_filter\n        Series filter (e.g. lambda series: series.modality == 'SR')\n    instance_filter\n        Instance filter (e.g. lambda instance: instance.SOPInstance == '...')\n\n    Returns\n    -------\n    List[Patient]\n        List of patients that respect .\n    \"\"\"\n    # In this function, client that return raw responses are not supported.\n    orthanc = util.ensure_non_raw_response(orthanc)\n\n    if isinstance(orthanc, AsyncOrthanc):\n        return asyncio.run(_async_find(\n            async_orthanc=orthanc,\n            patient_filter=patient_filter,\n            study_filter=study_filter,\n            series_filter=series_filter,\n            instance_filter=instance_filter\n        ))\n\n    patients = [Patient(i, orthanc, _lock_children=True) for i in orthanc.get_patients()]\n    if patient_filter is not None:\n        patients = [i for i in patients if patient_filter(i)]\n\n    for patient in patients:\n        if study_filter is not None:\n            patient._child_resources = [i for i in patient.studies if study_filter(i)]\n\n        for study in patient.studies:\n            if series_filter is not None:\n                study._child_resources = [i for i in study.series if series_filter(i)]\n\n            for series in study.series:\n                if instance_filter is not None:\n                    series._child_resources = [i for i in series.instances if instance_filter(i)]\n\n    return trim_patients(patients)\n</code></pre>"},{"location":"api/filtering/#pyorthanc.trim_patients","title":"<code>pyorthanc.trim_patients(patients)</code>","text":"<p>Trim Patient forest (list of patients)</p> <p>Parameters:</p> Name Type Description Default <code>patients</code> <code>List[Patient]</code> <p>Patient forest.</p> required <p>Returns:</p> Type Description <code>List[Patient]</code> <p>Pruned patient forest.</p> Source code in <code>pyorthanc/_filtering.py</code> <pre><code>def trim_patients(patients: List[Patient]) -&gt; List[Patient]:\n    \"\"\"Trim Patient forest (list of patients)\n\n    Parameters\n    ----------\n    patients\n        Patient forest.\n\n    Returns\n    -------\n    List[Patient]\n        Pruned patient forest.\n    \"\"\"\n    for patient in patients:\n        patient.remove_empty_studies()\n\n    patients = [p for p in patients if p.studies != []]\n\n    return patients\n</code></pre>"},{"location":"api/find/","title":"Find","text":""},{"location":"api/find/#pyorthanc.find_patients","title":"<code>pyorthanc.find_patients(client, query=None, labels=None, labels_constraint='All', **kwargs)</code>","text":"<p>Finds patients in Orthanc according to queries and labels</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Orthanc</code> <p>Orthanc client.</p> required <code>query</code> <code>Dict[str, str]</code> <p>Dictionary that specifies the filters on the Patient related DICOM tags.</p> <code>None</code> <code>labels</code> <code>Union[List[str], str]</code> <p>List of strings specifying which labels to look for in the resources.</p> <code>None</code> <code>labels_constraint</code> <code>str</code> <p>Constraint on the labels, can be 'All', 'Any', or 'None'.</p> <code>'All'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>query_orthanc</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Patient]</code> <p>List of patients that fit the provided criteria.</p> <p>Examples:</p> <pre><code>import pyorthanc\n\nclient = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\npatients = find_patients(\n    client=client,\n    query={'PatientID': 'Something*'},\n    labels=['my_label']\n)\n</code></pre> Source code in <code>pyorthanc/_find.py</code> <pre><code>def find_patients(client: Orthanc,\n                  query: Dict[str, str] = None,\n                  labels: Union[List[str], str] = None,\n                  labels_constraint: str = 'All',\n                  **kwargs) -&gt; List[Patient]:\n    \"\"\"Finds patients in Orthanc according to queries and labels\n\n    Parameters\n    ----------\n    client\n        Orthanc client.\n    query\n        Dictionary that specifies the filters on the Patient related DICOM tags.\n    labels\n        List of strings specifying which labels to look for in the resources.\n    labels_constraint\n        Constraint on the labels, can be 'All', 'Any', or 'None'.\n    **kwargs\n        Additional keyword arguments passed to `query_orthanc`\n\n    Returns\n    -------\n    List[Patient]\n        List of patients that fit the provided criteria.\n\n    Examples\n    --------\n    ```python\n    import pyorthanc\n\n    client = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\n    patients = find_patients(\n        client=client,\n        query={'PatientID': 'Something*'},\n        labels=['my_label']\n    )\n    ```\n    \"\"\"\n    return query_orthanc(\n        client=client,\n        level='Patient',\n        query=query,\n        labels=labels,\n        labels_constraint=labels_constraint,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/find/#pyorthanc.find_studies","title":"<code>pyorthanc.find_studies(client, query=None, labels=None, labels_constraint='All', **kwargs)</code>","text":"<p>Finds studies in Orthanc according to queries and labels</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Orthanc</code> <p>Orthanc client.</p> required <code>query</code> <code>Dict[str, str]</code> <p>Dictionary that specifies the filters on the Study related DICOM tags.</p> <code>None</code> <code>labels</code> <code>Union[List[str], str]</code> <p>List of strings specifying which labels to look for in the resources.</p> <code>None</code> <code>labels_constraint</code> <code>str</code> <p>Constraint on the labels, can be 'All', 'Any', or 'None'.</p> <code>'All'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>query_orthanc</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Study]</code> <p>List of studies that fit the provided criteria.</p> <p>Examples:</p> <pre><code>import pyorthanc\n\nclient = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\nstudies = find_studies(\n    client=client,\n    query={'ReferringPhysicianName': 'Something*'},\n    labels=['my_label']\n)\n</code></pre> Source code in <code>pyorthanc/_find.py</code> <pre><code>def find_studies(client: Orthanc,\n                 query: Dict[str, str] = None,\n                 labels: Union[List[str], str] = None,\n                 labels_constraint: str = 'All',\n                 **kwargs) -&gt; List[Study]:\n    \"\"\"Finds studies in Orthanc according to queries and labels\n\n    Parameters\n    ----------\n    client\n        Orthanc client.\n    query\n        Dictionary that specifies the filters on the Study related DICOM tags.\n    labels\n        List of strings specifying which labels to look for in the resources.\n    labels_constraint\n        Constraint on the labels, can be 'All', 'Any', or 'None'.\n    **kwargs\n        Additional keyword arguments passed to `query_orthanc`\n\n    Returns\n    -------\n    List[Study]\n        List of studies that fit the provided criteria.\n\n    Examples\n    --------\n    ```python\n    import pyorthanc\n\n    client = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\n    studies = find_studies(\n        client=client,\n        query={'ReferringPhysicianName': 'Something*'},\n        labels=['my_label']\n    )\n    ```\n    \"\"\"\n\n    return query_orthanc(\n        client=client,\n        level='Study',\n        query=query,\n        labels=labels,\n        labels_constraint=labels_constraint,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/find/#pyorthanc.find_series","title":"<code>pyorthanc.find_series(client, query=None, labels=None, labels_constraint='All', **kwargs)</code>","text":"<p>Finds series in Orthanc according to queries and labels</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Orthanc</code> <p>Orthanc client.</p> required <code>query</code> <code>Dict[str, str]</code> <p>Dictionary that specifies the filters on the Series related DICOM tags.</p> <code>None</code> <code>labels</code> <code>Union[List[str], str]</code> <p>List of strings specifying which labels to look for in the resources.</p> <code>None</code> <code>labels_constraint</code> <code>str</code> <p>Constraint on the labels, can be 'All', 'Any', or 'None'.</p> <code>'All'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>query_orthanc</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Series]</code> <p>List of Series that fit the provided criteria.</p> <p>Examples:</p> <pre><code>import pyorthanc\n\nclient = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\nseries = find_series(\n    client=client,\n    query={'Modality': 'RTDose'},\n    labels=['my_label']\n)\n</code></pre> Source code in <code>pyorthanc/_find.py</code> <pre><code>def find_series(client: Orthanc,\n                query: Dict[str, str] = None,\n                labels: Union[List[str], str] = None,\n                labels_constraint: str = 'All',\n                **kwargs) -&gt; List[Series]:\n    \"\"\"Finds series in Orthanc according to queries and labels\n\n    Parameters\n    ----------\n    client\n        Orthanc client.\n    query\n        Dictionary that specifies the filters on the Series related DICOM tags.\n    labels\n        List of strings specifying which labels to look for in the resources.\n    labels_constraint\n        Constraint on the labels, can be 'All', 'Any', or 'None'.\n    **kwargs\n        Additional keyword arguments passed to `query_orthanc`\n\n    Returns\n    -------\n    List[Series]\n        List of Series that fit the provided criteria.\n\n    Examples\n    --------\n    ```python\n    import pyorthanc\n\n    client = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\n    series = find_series(\n        client=client,\n        query={'Modality': 'RTDose'},\n        labels=['my_label']\n    )\n    ```\n    \"\"\"\n    return query_orthanc(\n        client=client,\n        level='Series',\n        query=query,\n        labels=labels,\n        labels_constraint=labels_constraint,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/find/#pyorthanc.find_instances","title":"<code>pyorthanc.find_instances(client, query=None, labels=None, labels_constraint='All', **kwargs)</code>","text":"<p>Finds instances in Orthanc according to queries and labels</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Orthanc</code> <p>Orthanc client.</p> required <code>query</code> <code>Dict[str, str]</code> <p>Dictionary that specifies the filters on the instances related DICOM tags.</p> <code>None</code> <code>labels</code> <code>Union[List[str], str]</code> <p>List of strings specifying which labels to look for in the resources.</p> <code>None</code> <code>labels_constraint</code> <code>str</code> <p>Constraint on the labels, can be 'All', 'Any', or 'None'.</p> <code>'All'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>query_orthanc</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Instance]</code> <p>List of Instances that fit the provided criteria.</p> <p>Examples:</p> <pre><code>import pyorthanc\n\nclient = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\ninstances = find_instances(\n    client=client,\n    query={'InstanceCreationDate': '20100301'},\n    labels=['my_label']\n)\n</code></pre> Source code in <code>pyorthanc/_find.py</code> <pre><code>def find_instances(client: Orthanc,\n                   query: Dict[str, str] = None,\n                   labels: Union[List[str], str] = None,\n                   labels_constraint: str = 'All',\n                   **kwargs) -&gt; List[Instance]:\n    \"\"\"Finds instances in Orthanc according to queries and labels\n\n    Parameters\n    ----------\n    client\n        Orthanc client.\n    query\n        Dictionary that specifies the filters on the instances related DICOM tags.\n    labels\n        List of strings specifying which labels to look for in the resources.\n    labels_constraint\n        Constraint on the labels, can be 'All', 'Any', or 'None'.\n    **kwargs\n        Additional keyword arguments passed to `query_orthanc`\n\n    Returns\n    -------\n    List[Instance]\n        List of Instances that fit the provided criteria.\n\n    Examples\n    --------\n    ```python\n    import pyorthanc\n\n    client = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\n    instances = find_instances(\n        client=client,\n        query={'InstanceCreationDate': '20100301'},\n        labels=['my_label']\n    )\n    ```\n    \"\"\"\n    return query_orthanc(\n        client=client,\n        level='Instance',\n        query=query,\n        labels=labels,\n        labels_constraint=labels_constraint,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/find/#pyorthanc.query_orthanc","title":"<code>pyorthanc.query_orthanc(client, level, query=None, labels=None, labels_constraint='All', limit=DEFAULT_RESOURCES_LIMIT, since=0, retrieve_all_resources=True, lock_children=False)</code>","text":"<p>Query data in the Orthanc server</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Orthanc</code> <p>Orthanc client.</p> required <code>level</code> <code>str</code> <p>Level of the query ['Patient', 'Study', 'Series', 'Instance'].</p> required <code>query</code> <code>Dict[str, str]</code> <p>Dictionary that specifies the filters on the level related DICOM tags.</p> <code>None</code> <code>labels</code> <code>Union[List[str], str]</code> <p>List of strings specifying which labels to look for in the resources.</p> <code>None</code> <code>labels_constraint</code> <code>str</code> <p>Constraint on the labels, can be 'All', 'Any', or 'None'.</p> <code>'All'</code> <code>limit</code> <code>int</code> <p>Limit the number of reported resources.</p> <code>DEFAULT_RESOURCES_LIMIT</code> <code>since</code> <code>int</code> <p>Show only the resources since the provided index (in conjunction with \"limit\").</p> <code>0</code> <code>retrieve_all_resources</code> <code>bool</code> <p>Retrieve all resources since the index specified in the \"since\" parameter.</p> <code>True</code> <code>lock_children</code> <code>bool</code> <p>If <code>lock_children</code> is True, the resource children (ex. instances of a series via <code>Series.instances</code>) will be cached at the first query rather than queried every time. This is useful when you want to filter the children of a resource and want to maintain the filter result.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Resource]</code> <p>List of resources that fit the provided criteria.</p> <p>Examples:</p> <pre><code>import pyorthanc\n\nclient = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\ninstances = query_orthanc(\n    client=client,\n    level='Instance',\n    query={'InstanceCreationDate': '20100301'},\n    labels=['my_label'],\n    since=100,\n    retrieve_all_resource=False\n)\n</code></pre> Source code in <code>pyorthanc/_find.py</code> <pre><code>def query_orthanc(client: Orthanc,\n                  level: str,\n                  query: Dict[str, str] = None,\n                  labels: Union[List[str], str] = None,\n                  labels_constraint: str = 'All',\n                  limit: int = DEFAULT_RESOURCES_LIMIT,\n                  since: int = 0,\n                  retrieve_all_resources: bool = True,\n                  lock_children: bool = False) -&gt; List[Resource]:\n    \"\"\"Query data in the Orthanc server\n\n    Parameters\n    ----------\n    client\n        Orthanc client.\n    level\n        Level of the query ['Patient', 'Study', 'Series', 'Instance'].\n    query\n        Dictionary that specifies the filters on the level related DICOM tags.\n    labels\n        List of strings specifying which labels to look for in the resources.\n    labels_constraint\n        Constraint on the labels, can be 'All', 'Any', or 'None'.\n    limit\n        Limit the number of reported resources.\n    since\n        Show only the resources since the provided index (in conjunction with \"limit\").\n    retrieve_all_resources\n        Retrieve all resources since the index specified in the \"since\" parameter.\n    lock_children\n        If `lock_children` is True, the resource children (ex. instances of a series via `Series.instances`)\n        will be cached at the first query rather than queried every time. This is useful when you want\n        to filter the children of a resource and want to maintain the filter result.\n    Returns\n    -------\n    List[Resource]\n        List of resources that fit the provided criteria.\n\n    Examples\n    --------\n    ```python\n    import pyorthanc\n\n    client = pyorthanc.Orthanc('http://localhost:8042', 'orthanc', 'orthanc')\n    instances = query_orthanc(\n        client=client,\n        level='Instance',\n        query={'InstanceCreationDate': '20100301'},\n        labels=['my_label'],\n        since=100,\n        retrieve_all_resource=False\n    )\n    ```\n    \"\"\"\n    _validate_level(level)\n    _validate_labels_constraint(labels_constraint)\n\n    # In this function, client that return raw responses are not supported.\n    client = util.ensure_non_raw_response(client)\n\n    data = {\n        'Expand': True,\n        'Level': level,\n        'Limit': limit,\n        'Since': since,\n        'Query': {}\n    }\n\n    if query is not None:\n        data['Query'] = query\n\n    if labels is not None:\n        data['Labels'] = [labels] if isinstance(labels, str) else labels\n        data['LabelsConstraint'] = labels_constraint\n\n    if retrieve_all_resources:\n        results = []\n        while True:\n            result_for_interval = client.post_tools_find(data)\n            if len(result_for_interval) == 0:\n                break\n\n            results += result_for_interval\n            data['Since'] += limit  # Updating the lookup window\n    else:\n        results = client.post_tools_find(data)\n\n    if level == 'Patient':\n        resources = [Patient(i['ID'], client, _lock_children=lock_children) for i in results]\n    elif level == 'Study':\n        resources = [Study(i['ID'], client, _lock_children=lock_children) for i in results]\n    elif level == 'Series':\n        resources = [Series(i['ID'], client, _lock_children=lock_children) for i in results]\n    elif level == 'Instance':\n        resources = [Instance(i['ID'], client, _lock_children=lock_children) for i in results]\n    else:\n        raise ValueError(f\"Unknown level ['Patient', 'Study', 'Series', 'Instance'], got {level}\")\n\n    return resources\n</code></pre>"},{"location":"api/find/#pyorthanc._find.DEFAULT_RESOURCES_LIMIT","title":"<code>pyorthanc._find.DEFAULT_RESOURCES_LIMIT = 1000</code>  <code>module-attribute</code>","text":""},{"location":"api/internal_client/","title":"Internal Client","text":"<p>The <code>orthanc_sdk</code> is useful when developing with the Orthanc's Python Plugin. However, it is sometimes useful to have an instance of <code>pyorthanc.Orthanc</code> inside a Python script in Orthanc to use the Orthanc REST API functionalities. This is where <code>pyorthanc.get_internal_client()</code> is helpful.</p> <p>In a Python script, you can use <code>pyorthanc.get_internal_client()</code> to get an instance of <code>pyorthanc.Orthanc</code> that can be used to call Orthanc's REST API.</p> <pre><code>import json\nfrom pyorthanc import orthanc_sdk, get_internal_client, find_studies\n\n\ndef get_study_descriptions(output: orthanc_sdk.RestOutput, *_, **__):\n    # client is a pyorthanc.Orthanc instance\n    client = get_internal_client()\n\n    # You can use all functionalities of the pyorthanc.Orthanc now.\n    # For example, we can retrieve all the study descriptions\n    studies = find_studies(client)\n    descriptions = [study.description for study in studies]\n\n    output.AnswerBuffer(\n        json.dumps({'descriptions': descriptions}),\n        'application/json'\n    )\n\n\northanc_sdk.RegisterRestCallback('/all-study-descriptions', get_study_descriptions)\n</code></pre>"},{"location":"api/internal_client/#how-it-works","title":"How it works","text":"<p><code>get_internal_client()</code> retrieve the correct URL, port and Token to allow Orthanc to call itself through the REST API.</p>"},{"location":"api/internal_client/#reference","title":"Reference","text":"<p>options: members: true :docstring: :members:</p>"},{"location":"api/internal_client/#pyorthanc._internal_client","title":"<code>pyorthanc._internal_client</code>","text":""},{"location":"api/internal_client/#pyorthanc._internal_client.get_internal_client","title":"<code>get_internal_client()</code>","text":"<p>Returns an Orthanc client that can be used inside the Orthanc server in python scripts.</p> <p>Examples:</p> <p>This example shows how to use the Orthanc REST API inside an Orthanc Python Script.</p> <pre><code>&gt;&gt;&gt; from pyorthanc import get_internal_client, find_series, orthanc_sdk\n&gt;&gt;&gt; def get_modalities_in_orthanc(output: orthanc_sdk.RestOutput, *_, **__):\n...     '''This function returns all modalities in Orthanc.'''\n...     client = get_internal_client()\n...\n...     series = find_series(client)\n...     modalities_in_orthanc = set([s.modality for s in series])\n...\n...     output.AnswerBuffer(\n...         json.dumps({'modalities': list(modalities_in_orthanc)}),\n...         'application/json'\n...     )\n...\n... orthanc_sdk.RegisterRestCallback('/get-modalities-in-orthanc', get_modalities_in_orthanc)\n</code></pre> Source code in <code>pyorthanc/_internal_client.py</code> <pre><code>def get_internal_client() -&gt; Orthanc:\n    \"\"\"\n    Returns an Orthanc client that can be used inside the Orthanc server in python scripts.\n\n    Examples\n    -------\n    This example shows how to use the Orthanc REST API inside an Orthanc Python Script.\n    &gt;&gt;&gt; from pyorthanc import get_internal_client, find_series, orthanc_sdk\n    &gt;&gt;&gt; def get_modalities_in_orthanc(output: orthanc_sdk.RestOutput, *_, **__):\n    ...     '''This function returns all modalities in Orthanc.'''\n    ...     client = get_internal_client()\n    ...\n    ...     series = find_series(client)\n    ...     modalities_in_orthanc = set([s.modality for s in series])\n    ...\n    ...     output.AnswerBuffer(\n    ...         json.dumps({'modalities': list(modalities_in_orthanc)}),\n    ...         'application/json'\n    ...     )\n    ...\n    ... orthanc_sdk.RegisterRestCallback('/get-modalities-in-orthanc', get_modalities_in_orthanc)\n    \"\"\"\n    from pyorthanc import orthanc_sdk\n\n    config = orthanc_sdk.GetConfiguration()\n\n    if not config:\n        raise NotInInternalEnvironmentError(\n            'This function is only available inside Orthanc server. '\n            'Use `pyorthanc.get_internal_client()` inside a Orthanc Python Script. '\n            'An `pyorthanc.Orthanc()` instance should be defined when using the '\n            'Orthanc REST API outside of an Orthanc Oython Python Script.'\n        )\n\n    port = json.loads(config).get('HttpPort', 8042)\n    url = f'http://localhost:{port}'\n\n    client = Orthanc(url=url)\n\n    token = orthanc_sdk.GenerateRestApiAuthorizationToken()\n    client.headers['Authorization'] = token\n\n    return client\n</code></pre>"},{"location":"api/jobs/","title":"Jobs","text":""},{"location":"api/jobs/#pyorthanc.Job","title":"<code>pyorthanc.Job</code>","text":"<p>Job class to follow a Job in Orthanc</p> Source code in <code>pyorthanc/jobs.py</code> <pre><code>class Job:\n    \"\"\"Job class to follow a Job in Orthanc\"\"\"\n\n    def __init__(self, id_: str, client: Orthanc):\n        client = util.ensure_non_raw_response(client)\n\n        self.id_ = id_\n        self.client = client\n\n    @property\n    def state(self) -&gt; State:\n        state = self.get_information()['State']\n\n        return State(state)\n\n    @property\n    def content(self) -&gt; Dict:\n        return self.get_information()['Content']\n\n    @property\n    def type(self) -&gt; str:\n        return self.get_information()['Type']\n\n    @property\n    def creation_time(self) -&gt; datetime:\n        creation_time = self.get_information()['CreationTime'].split('T')\n        date = creation_time[0]\n        time = creation_time[1]\n\n        return util.make_datetime_from_dicom_date(date, time)\n\n    @property\n    def effective_runtime(self) -&gt; float:\n        runtime = self.get_information()['EffectiveRuntime']\n\n        return float(runtime)\n\n    @property\n    def priority(self) -&gt; int:\n        return int(self.get_information()['Priority'])\n\n    @property\n    def progress(self) -&gt; int:\n        return int(self.get_information()['Progress'])\n\n    @property\n    def error(self) -&gt; ErrorCode:\n        info = self.get_information()\n\n        return ErrorCode(info['ErrorCode'])\n\n    @property\n    def error_details(self) -&gt; Optional[str]:\n        info = self.get_information()\n\n        if 'ErrorDetails' in info:\n            return info['ErrorDetails']\n\n        return None\n\n    @property\n    def timestamp(self) -&gt; datetime:\n        timestamp = self.get_information()['Timestamp'].split('T')\n        date = timestamp[0]\n        time = timestamp[1]\n\n        return util.make_datetime_from_dicom_date(date, time)\n\n    @property\n    def completion_time(self) -&gt; Optional[datetime]:\n        info = self.get_information()\n\n        if 'CompletionTime' not in info:\n            return\n\n        completion_time = self.get_information()['CompletionTime'].split('T')\n        date = completion_time[0]\n        time = completion_time[1]\n\n        return util.make_datetime_from_dicom_date(date, time)\n\n    def wait_until_completion(self, time_interval: int = 2) -&gt; None:\n        \"\"\"Stop execution until job is not Pending/Running\n\n        Parameters\n        ----------\n        time_interval\n            Time interval to check the job status, default 2s.\n        \"\"\"\n        while self.state in [State.pending, State.running]:\n            time.sleep(time_interval)\n\n    def get_information(self):\n        return self.client.get_jobs_id(self.id_)\n</code></pre>"},{"location":"api/jobs/#pyorthanc.Job.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.completion_time","title":"<code>completion_time</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.content","title":"<code>content</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.creation_time","title":"<code>creation_time</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.effective_runtime","title":"<code>effective_runtime</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.error","title":"<code>error</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.error_details","title":"<code>error_details</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.id_","title":"<code>id_ = id_</code>  <code>instance-attribute</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.priority","title":"<code>priority</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.progress","title":"<code>progress</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.state","title":"<code>state</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.timestamp","title":"<code>timestamp</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.type","title":"<code>type</code>  <code>property</code>","text":""},{"location":"api/jobs/#pyorthanc.Job.__init__","title":"<code>__init__(id_, client)</code>","text":"Source code in <code>pyorthanc/jobs.py</code> <pre><code>def __init__(self, id_: str, client: Orthanc):\n    client = util.ensure_non_raw_response(client)\n\n    self.id_ = id_\n    self.client = client\n</code></pre>"},{"location":"api/jobs/#pyorthanc.Job.get_information","title":"<code>get_information()</code>","text":"Source code in <code>pyorthanc/jobs.py</code> <pre><code>def get_information(self):\n    return self.client.get_jobs_id(self.id_)\n</code></pre>"},{"location":"api/jobs/#pyorthanc.Job.wait_until_completion","title":"<code>wait_until_completion(time_interval=2)</code>","text":"<p>Stop execution until job is not Pending/Running</p> <p>Parameters:</p> Name Type Description Default <code>time_interval</code> <code>int</code> <p>Time interval to check the job status, default 2s.</p> <code>2</code> Source code in <code>pyorthanc/jobs.py</code> <pre><code>def wait_until_completion(self, time_interval: int = 2) -&gt; None:\n    \"\"\"Stop execution until job is not Pending/Running\n\n    Parameters\n    ----------\n    time_interval\n        Time interval to check the job status, default 2s.\n    \"\"\"\n    while self.state in [State.pending, State.running]:\n        time.sleep(time_interval)\n</code></pre>"},{"location":"api/jobs/#pyorthanc.jobs.State","title":"<code>pyorthanc.jobs.State</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Job state enum</p> Source code in <code>pyorthanc/jobs.py</code> <pre><code>class State(Enum):\n    \"\"\"Job state enum\"\"\"\n    failure = 'Failure'\n    paused = 'Paused'\n    pending = 'Pending'\n    retry = 'Retry'\n    running = 'Running'\n    success = 'Success'\n</code></pre>"},{"location":"api/jobs/#pyorthanc.jobs.ErrorCode","title":"<code>pyorthanc.jobs.ErrorCode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginErrorCode</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ErrorCode(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginErrorCode\"\"\"\n    ALREADY_EXISTING_TAG = 2042\n    BAD_APPLICATION_ENTITY_TITLE = 2009\n    BAD_FILE_FORMAT = 15\n    BAD_FONT = 30\n    BAD_GEOMETRY = 38\n    BAD_HTTP_STATUS_IN_REST = 2005\n    BAD_JOB_ORDERING = 2028\n    BAD_JSON = 28\n    BAD_PARAMETER_TYPE = 5\n    BAD_RANGE = 41\n    BAD_REQUEST = 8\n    BAD_SEQUENCE_OF_CALLS = 6\n    CANCELED_JOB = 37\n    CANNOT_CREATE_LUA = 2030\n    CANNOT_EXECUTE_LUA = 2031\n    CANNOT_ORDER_SLICES = 2040\n    CANNOT_STORE_INSTANCE = 2018\n    CANNOT_WRITE_FILE = 14\n    CORRUPTED_FILE = 20\n    CREATE_DICOM_BAD_PARENT = 2024\n    CREATE_DICOM_NOT_STRING = 2019\n    CREATE_DICOM_NO_PAYLOAD = 2022\n    CREATE_DICOM_OVERRIDE_TAG = 2020\n    CREATE_DICOM_PARENT_ENCODING = 2026\n    CREATE_DICOM_PARENT_IS_INSTANCE = 2025\n    CREATE_DICOM_USE_CONTENT = 2021\n    CREATE_DICOM_USE_DATA_URI_SCHEME = 2023\n    DATABASE = 11\n    DATABASE_BACKEND_ALREADY_REGISTERED = 2037\n    DATABASE_CANNOT_SERIALIZE = 42\n    DATABASE_NOT_INITIALIZED = 2038\n    DATABASE_PLUGIN = 31\n    DATABASE_UNAVAILABLE = 36\n    DICOM_FIND_UNAVAILABLE = 2016\n    DICOM_MOVE_UNAVAILABLE = 2017\n    DICOM_PORT_IN_USE = 2004\n    DIRECTORY_EXPECTED = 2002\n    DIRECTORY_OVER_FILE = 2000\n    DISCONTINUED_ABI = 40\n    EMPTY_REQUEST = 33\n    FILE_STORAGE_CANNOT_WRITE = 2001\n    FULL_STORAGE = 19\n    HTTP_PORT_IN_USE = 2003\n    INCOMPATIBLE_DATABASE_VERSION = 18\n    INCOMPATIBLE_IMAGE_FORMAT = 23\n    INCOMPATIBLE_IMAGE_SIZE = 24\n    INEXISTENT_FILE = 13\n    INEXISTENT_ITEM = 7\n    INEXISTENT_TAG = 21\n    INTERNAL_ERROR = -1\n    JSON_TO_LUA_TABLE = 2029\n    LUA_ALREADY_EXECUTED = 2032\n    LUA_BAD_OUTPUT = 2033\n    LUA_RETURNS_NO_STRING = 2035\n    MAKE_DIRECTORY = 2008\n    NETWORK_PROTOCOL = 9\n    NOT_ACCEPTABLE = 34\n    NOT_ENOUGH_MEMORY = 4\n    NOT_IMPLEMENTED = 2\n    NOT_LUA_PREDICATE = 2034\n    NO_APPLICATION_ENTITY_FILTER = 2013\n    NO_CFIND_HANDLER = 2010\n    NO_CGET_HANDLER = 2044\n    NO_CMOVE_HANDLER = 2011\n    NO_CSTORE_HANDLER = 2012\n    NO_PRESENTATION_CONTEXT = 2015\n    NO_SOP_CLASS_OR_INSTANCE = 2014\n    NO_STORAGE_COMMITMENT_HANDLER = 2043\n    NO_WORKLIST_HANDLER = 2041\n    NULL_POINTER = 35\n    PARAMETER_OUT_OF_RANGE = 3\n    PATH_TO_EXECUTABLE = 2007\n    PLUGIN = 1\n    READ_ONLY = 22\n    REGULAR_FILE_EXPECTED = 2006\n    REVISION = 43\n    SHARED_LIBRARY = 25\n    SQLITE_ALREADY_OPENED = 1001\n    SQLITE_BIND_OUT_OF_RANGE = 1011\n    SQLITE_CANNOT_OPEN = 1002\n    SQLITE_CANNOT_RUN = 1009\n    SQLITE_CANNOT_STEP = 1010\n    SQLITE_COMMIT_WITHOUT_TRANSACTION = 1006\n    SQLITE_EXECUTE = 1004\n    SQLITE_FLUSH = 1008\n    SQLITE_NOT_OPENED = 1000\n    SQLITE_PREPARE_STATEMENT = 1012\n    SQLITE_REGISTER_FUNCTION = 1007\n    SQLITE_ROLLBACK_WITHOUT_TRANSACTION = 1005\n    SQLITE_STATEMENT_ALREADY_USED = 1003\n    SQLITE_TRANSACTION_ALREADY_STARTED = 1013\n    SQLITE_TRANSACTION_BEGIN = 1015\n    SQLITE_TRANSACTION_COMMIT = 1014\n    SSL_DISABLED = 2039\n    SSL_INITIALIZATION = 39\n    STORAGE_AREA_ALREADY_REGISTERED = 2036\n    STORAGE_AREA_PLUGIN = 32\n    SUCCESS = 0\n    SYSTEM_COMMAND = 10\n    TIMEOUT = 16\n    UNAUTHORIZED = 29\n    UNKNOWN_DICOM_TAG = 27\n    UNKNOWN_MODALITY = 2027\n    UNKNOWN_PLUGIN_SERVICE = 26\n    UNKNOWN_RESOURCE = 17\n    UNSUPPORTED_MEDIA_TYPE = 3000\n    URI_SYNTAX = 12\n</code></pre>"},{"location":"api/modality/","title":"Modality","text":""},{"location":"api/modality/#pyorthanc.Modality","title":"<code>pyorthanc.Modality</code>","text":"<p>Wrapper around Orthanc API when dealing with a modality.</p> Source code in <code>pyorthanc/_modality.py</code> <pre><code>class Modality:\n    \"\"\"Wrapper around Orthanc API when dealing with a modality.\"\"\"\n\n    def __init__(self, client: Orthanc, modality: str) -&gt; None:\n        \"\"\"Constructor\n\n        Parameters\n        ----------\n        client\n            Orthanc object.\n        modality\n            Remote modality.\n        \"\"\"\n        client = util.ensure_non_raw_response(client)\n\n        self.client = client\n        self.modality = modality\n\n    def echo(self) -&gt; bool:\n        \"\"\"C-Echo to modality\n\n        Returns\n        -------\n        bool\n            True if C-Echo succeeded.\n        \"\"\"\n        try:\n            self.client.post_modalities_id_echo(self.modality)\n            return True\n\n        except httpx.HTTPError:\n            return False\n\n    def get(self, level: str, resources: Union[List[Dict[str, Any]], Dict[str, Any]]) -&gt; Dict:\n        \"\"\"C-GET\n\n        C-Move SCU: Send all the results to another modality whose AET is in the body\n\n        Parameters\n        ----------\n        level\n            Level of the query ['Patient', 'Study', 'Series', 'Instance']\n        resources\n            Dict or list of dict of DICOM tags that identify data to retrieve,\n            e.g. {'StudyInstanceUID': '1.3.6.1.4.1.22213.2.6291.2.1'}\n\n        Returns\n        -------\n        Dict\n            Orthanc Response (probably a Dictionary)\n\n        Examples\n        --------\n        &gt;&gt;&gt; modality = Modality(Orthanc('http://localhost:8042'), 'modality')\n        &gt;&gt;&gt; query_id = modality.get(\n        ...     data={\n        ...         'Level': 'Study',\n        ...         'Resources': {'StudyInstanceUID': '1.3.6.1.4.1.22213.2.6291.2.1'}\n        ...     }\n        ... )\n\n        \"\"\"\n        _validate_level(level)\n        if isinstance(resources, dict):\n            resources = [resources]\n\n        return dict(self.client.post_modalities_id_get(self.modality, json={\n            'Level': level,\n            'Resources': resources\n        }))\n\n    def find(self, data: Dict) -&gt; Dict:\n        \"\"\"C-Find (Querying with data)\n\n        Parameters\n        ----------\n        data\n            Dictionary to send in the body of request.\n\n        Returns\n        -------\n        Dict\n            Returns a dictionary with the query ID and corresponding matches (i.e. answers) to the request\n            {'ID': '&lt;query_id&gt;', 'answers': [{first match metadata}, {second math metadata}, ...]}\n\n        Examples\n        -------\n        &gt;&gt;&gt; data = {'Level': 'Study',\n        ...         'Query': {\n        ...             'PatientID':'03HD*',\n        ...             'StudyDescription':'*Chest*',\n        ...             'PatientName':''\n        ...         }\n        ... }\n\n        &gt;&gt;&gt; modality = Modality(\n        ...     client=Orthanc('http://localhost:8042'),\n        ...     modality='sample'\n        ... )\n\n        &gt;&gt;&gt; response = modality.find(data)\n        &gt;&gt;&gt; print(response['ID'], response['answers'])\n        \"\"\"\n        query_id = self.client.post_modalities_id_query(self.modality, json=data)['ID']\n        answers = self.get_query_answers(query_id)\n\n        return {'ID': query_id, 'answers': answers}\n\n    query = find  # Alias\n\n    def move(self, query_identifier: str, cmove_data: Dict = None) -&gt; Dict:\n        \"\"\"C-Move query results to another modality\n\n        C-Move SCU: Send all the results to another modality whose AET is in the body\n\n        Parameters\n        ----------\n        query_identifier\n            Query identifier.\n        cmove_data\n            Ex. {'TargetAet': 'target_modality_name', \"Synchronous\": False}\n\n        Returns\n        -------\n        Dict\n            Orthanc Response (probably a Dictionary)\n\n        Examples\n        --------\n        &gt;&gt;&gt; modality = Modality(Orthanc('http://localhost:8042'), 'modality')\n        &gt;&gt;&gt; query_id = modality.query(\n        ...     data={'Level': 'Series',\n        ...           'Query': {'PatientID': '',\n        ...                     'Modality':'SR'}})\n\n        &gt;&gt;&gt; modality.move(\n        ...     query_identifier=query_id['ID'],\n        ...     cmove_data={'TargetAet': 'TARGETAET'}\n        ... )\n\n        \"\"\"\n        return dict(self.client.post_queries_id_retrieve(query_identifier, json=cmove_data))\n\n    def store(self, instance_or_series_id: str) -&gt; Dict:\n        \"\"\"Store series or instance to modality.\n\n        Parameters\n        ----------\n        instance_or_series_id\n            Instance or Series Orthanc identifier.\n\n        Returns\n        -------\n        Dict\n            Information related to the C-Store operation.\n        \"\"\"\n        return dict(self.client.post_modalities_id_store(\n            self.modality,\n            json=instance_or_series_id\n        ))\n\n    def get_query_answers(self, query_id: str, simplify: bool = True, short: bool = False) -&gt; List[Dict]:\n        \"\"\"\"\"\"\n        params = self._make_response_format_params(simplify=simplify, short=short)\n\n        answers = []\n        for answer_id in self.client.get_queries_id_answers(query_id):\n            answer_content = self.client.get_queries_id_answers_index_content(query_id, answer_id, params)\n            answers.append(answer_content)\n\n        return answers\n\n    def _make_response_format_params(self, simplify: bool, short: bool) -&gt; Dict:\n        if simplify and not short:\n            params = {'simplify': True}\n        elif short and not simplify:\n            params = {'short': True}\n        elif simplify and short:\n            raise ValueError(\"simplify and short can't be both True.\")\n        else:\n            params = {}\n\n        return params\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"api/modality/#pyorthanc.Modality.modality","title":"<code>modality = modality</code>  <code>instance-attribute</code>","text":""},{"location":"api/modality/#pyorthanc.Modality.query","title":"<code>query = find</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/modality/#pyorthanc.Modality.__init__","title":"<code>__init__(client, modality)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Orthanc</code> <p>Orthanc object.</p> required <code>modality</code> <code>str</code> <p>Remote modality.</p> required Source code in <code>pyorthanc/_modality.py</code> <pre><code>def __init__(self, client: Orthanc, modality: str) -&gt; None:\n    \"\"\"Constructor\n\n    Parameters\n    ----------\n    client\n        Orthanc object.\n    modality\n        Remote modality.\n    \"\"\"\n    client = util.ensure_non_raw_response(client)\n\n    self.client = client\n    self.modality = modality\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality._make_response_format_params","title":"<code>_make_response_format_params(simplify, short)</code>","text":"Source code in <code>pyorthanc/_modality.py</code> <pre><code>def _make_response_format_params(self, simplify: bool, short: bool) -&gt; Dict:\n    if simplify and not short:\n        params = {'simplify': True}\n    elif short and not simplify:\n        params = {'short': True}\n    elif simplify and short:\n        raise ValueError(\"simplify and short can't be both True.\")\n    else:\n        params = {}\n\n    return params\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality.echo","title":"<code>echo()</code>","text":"<p>C-Echo to modality</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if C-Echo succeeded.</p> Source code in <code>pyorthanc/_modality.py</code> <pre><code>def echo(self) -&gt; bool:\n    \"\"\"C-Echo to modality\n\n    Returns\n    -------\n    bool\n        True if C-Echo succeeded.\n    \"\"\"\n    try:\n        self.client.post_modalities_id_echo(self.modality)\n        return True\n\n    except httpx.HTTPError:\n        return False\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality.find","title":"<code>find(data)</code>","text":"<p>C-Find (Querying with data)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary to send in the body of request.</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Returns a dictionary with the query ID and corresponding matches (i.e. answers) to the request {'ID': '', 'answers': [{first match metadata}, {second math metadata}, ...]} <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {'Level': 'Study',\n...         'Query': {\n...             'PatientID':'03HD*',\n...             'StudyDescription':'*Chest*',\n...             'PatientName':''\n...         }\n... }\n</code></pre> <pre><code>&gt;&gt;&gt; modality = Modality(\n...     client=Orthanc('http://localhost:8042'),\n...     modality='sample'\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; response = modality.find(data)\n&gt;&gt;&gt; print(response['ID'], response['answers'])\n</code></pre> Source code in <code>pyorthanc/_modality.py</code> <pre><code>def find(self, data: Dict) -&gt; Dict:\n    \"\"\"C-Find (Querying with data)\n\n    Parameters\n    ----------\n    data\n        Dictionary to send in the body of request.\n\n    Returns\n    -------\n    Dict\n        Returns a dictionary with the query ID and corresponding matches (i.e. answers) to the request\n        {'ID': '&lt;query_id&gt;', 'answers': [{first match metadata}, {second math metadata}, ...]}\n\n    Examples\n    -------\n    &gt;&gt;&gt; data = {'Level': 'Study',\n    ...         'Query': {\n    ...             'PatientID':'03HD*',\n    ...             'StudyDescription':'*Chest*',\n    ...             'PatientName':''\n    ...         }\n    ... }\n\n    &gt;&gt;&gt; modality = Modality(\n    ...     client=Orthanc('http://localhost:8042'),\n    ...     modality='sample'\n    ... )\n\n    &gt;&gt;&gt; response = modality.find(data)\n    &gt;&gt;&gt; print(response['ID'], response['answers'])\n    \"\"\"\n    query_id = self.client.post_modalities_id_query(self.modality, json=data)['ID']\n    answers = self.get_query_answers(query_id)\n\n    return {'ID': query_id, 'answers': answers}\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality.get","title":"<code>get(level, resources)</code>","text":"<p>C-GET</p> <p>C-Move SCU: Send all the results to another modality whose AET is in the body</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Level of the query ['Patient', 'Study', 'Series', 'Instance']</p> required <code>resources</code> <code>Union[List[Dict[str, Any]], Dict[str, Any]]</code> <p>Dict or list of dict of DICOM tags that identify data to retrieve, e.g. {'StudyInstanceUID': '1.3.6.1.4.1.22213.2.6291.2.1'}</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Orthanc Response (probably a Dictionary)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; modality = Modality(Orthanc('http://localhost:8042'), 'modality')\n&gt;&gt;&gt; query_id = modality.get(\n...     data={\n...         'Level': 'Study',\n...         'Resources': {'StudyInstanceUID': '1.3.6.1.4.1.22213.2.6291.2.1'}\n...     }\n... )\n</code></pre> Source code in <code>pyorthanc/_modality.py</code> <pre><code>def get(self, level: str, resources: Union[List[Dict[str, Any]], Dict[str, Any]]) -&gt; Dict:\n    \"\"\"C-GET\n\n    C-Move SCU: Send all the results to another modality whose AET is in the body\n\n    Parameters\n    ----------\n    level\n        Level of the query ['Patient', 'Study', 'Series', 'Instance']\n    resources\n        Dict or list of dict of DICOM tags that identify data to retrieve,\n        e.g. {'StudyInstanceUID': '1.3.6.1.4.1.22213.2.6291.2.1'}\n\n    Returns\n    -------\n    Dict\n        Orthanc Response (probably a Dictionary)\n\n    Examples\n    --------\n    &gt;&gt;&gt; modality = Modality(Orthanc('http://localhost:8042'), 'modality')\n    &gt;&gt;&gt; query_id = modality.get(\n    ...     data={\n    ...         'Level': 'Study',\n    ...         'Resources': {'StudyInstanceUID': '1.3.6.1.4.1.22213.2.6291.2.1'}\n    ...     }\n    ... )\n\n    \"\"\"\n    _validate_level(level)\n    if isinstance(resources, dict):\n        resources = [resources]\n\n    return dict(self.client.post_modalities_id_get(self.modality, json={\n        'Level': level,\n        'Resources': resources\n    }))\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality.get_query_answers","title":"<code>get_query_answers(query_id, simplify=True, short=False)</code>","text":"Source code in <code>pyorthanc/_modality.py</code> <pre><code>def get_query_answers(self, query_id: str, simplify: bool = True, short: bool = False) -&gt; List[Dict]:\n    \"\"\"\"\"\"\n    params = self._make_response_format_params(simplify=simplify, short=short)\n\n    answers = []\n    for answer_id in self.client.get_queries_id_answers(query_id):\n        answer_content = self.client.get_queries_id_answers_index_content(query_id, answer_id, params)\n        answers.append(answer_content)\n\n    return answers\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality.move","title":"<code>move(query_identifier, cmove_data=None)</code>","text":"<p>C-Move query results to another modality</p> <p>C-Move SCU: Send all the results to another modality whose AET is in the body</p> <p>Parameters:</p> Name Type Description Default <code>query_identifier</code> <code>str</code> <p>Query identifier.</p> required <code>cmove_data</code> <code>Dict</code> <p>Ex. {'TargetAet': 'target_modality_name', \"Synchronous\": False}</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Orthanc Response (probably a Dictionary)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; modality = Modality(Orthanc('http://localhost:8042'), 'modality')\n&gt;&gt;&gt; query_id = modality.query(\n...     data={'Level': 'Series',\n...           'Query': {'PatientID': '',\n...                     'Modality':'SR'}})\n</code></pre> <pre><code>&gt;&gt;&gt; modality.move(\n...     query_identifier=query_id['ID'],\n...     cmove_data={'TargetAet': 'TARGETAET'}\n... )\n</code></pre> Source code in <code>pyorthanc/_modality.py</code> <pre><code>def move(self, query_identifier: str, cmove_data: Dict = None) -&gt; Dict:\n    \"\"\"C-Move query results to another modality\n\n    C-Move SCU: Send all the results to another modality whose AET is in the body\n\n    Parameters\n    ----------\n    query_identifier\n        Query identifier.\n    cmove_data\n        Ex. {'TargetAet': 'target_modality_name', \"Synchronous\": False}\n\n    Returns\n    -------\n    Dict\n        Orthanc Response (probably a Dictionary)\n\n    Examples\n    --------\n    &gt;&gt;&gt; modality = Modality(Orthanc('http://localhost:8042'), 'modality')\n    &gt;&gt;&gt; query_id = modality.query(\n    ...     data={'Level': 'Series',\n    ...           'Query': {'PatientID': '',\n    ...                     'Modality':'SR'}})\n\n    &gt;&gt;&gt; modality.move(\n    ...     query_identifier=query_id['ID'],\n    ...     cmove_data={'TargetAet': 'TARGETAET'}\n    ... )\n\n    \"\"\"\n    return dict(self.client.post_queries_id_retrieve(query_identifier, json=cmove_data))\n</code></pre>"},{"location":"api/modality/#pyorthanc.Modality.store","title":"<code>store(instance_or_series_id)</code>","text":"<p>Store series or instance to modality.</p> <p>Parameters:</p> Name Type Description Default <code>instance_or_series_id</code> <code>str</code> <p>Instance or Series Orthanc identifier.</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Information related to the C-Store operation.</p> Source code in <code>pyorthanc/_modality.py</code> <pre><code>def store(self, instance_or_series_id: str) -&gt; Dict:\n    \"\"\"Store series or instance to modality.\n\n    Parameters\n    ----------\n    instance_or_series_id\n        Instance or Series Orthanc identifier.\n\n    Returns\n    -------\n    Dict\n        Information related to the C-Store operation.\n    \"\"\"\n    return dict(self.client.post_modalities_id_store(\n        self.modality,\n        json=instance_or_series_id\n    ))\n</code></pre>"},{"location":"api/modality/#remotemodality","title":"RemoteModality","text":"<p>RemoteModality is an alias for Modality</p> <pre><code>RemoteModality = Modality\n</code></pre>"},{"location":"api/orthanc_sdk/","title":"Orthanc SDK","text":"<p>The <code>orthanc_sdk</code> is useful when developing with the Orthanc's Python Plugin,  it exposes <code>orthanc</code> module when available (i.e. used as an Orthanc script),  or expose the functions/classes signatures when not for linting and autocomplete.</p> <p>Use it the same way you would use the Python Plugin:</p> <pre><code>from pyorthanc import orthanc_sdk\n\ndef on_get(output: orthanc_sdk.RestOutput, *_, **__):\n    output.AnswerBuffer('ok', 'text/plain')\n\northanc_sdk.RegisterRestCallback('/test', on_get)\n</code></pre>"},{"location":"api/orthanc_sdk/#how-it-works","title":"How it works","text":"<p>When developing importing the Orthanc Python Plugin with <code>import orthanc</code> will raise a <code>ModuleNotFoundError</code>. This where the <code>orthanc_sdk</code> submodule is interesting. When <code>orthanc</code> is available, it uses it. When not, <code>orthanc_sdk</code> expose mock functions/classes of everything available from <code>orthanc</code>, however, these functions/classes does nothing.</p> <pre><code>try:\n    from orthanc import *\n\nexcept ModuleNotFoundError:\n    \"\"\"Orthanc SDK methods wrapped in python (plugin version 4.0)\"\"\"\n    ...\n</code></pre>"},{"location":"api/orthanc_sdk/#reference","title":"Reference","text":""},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk","title":"<code>pyorthanc.orthanc_sdk</code>","text":"<p>Orthanc SDK methods wrapped in python</p>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.VERSION","title":"<code>VERSION = '4.1'</code>  <code>module-attribute</code>","text":""},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ChangeType","title":"<code>ChangeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginChangeType</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ChangeType(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginChangeType\"\"\"\n    COMPLETED_SERIES = 0\n    DELETED = 1\n    JOB_FAILURE = 18\n    JOB_SUBMITTED = 16\n    JOB_SUCCESS = 17\n    NEW_CHILD_INSTANCE = 2\n    NEW_INSTANCE = 3\n    NEW_PATIENT = 4\n    NEW_SERIES = 5\n    NEW_STUDY = 6\n    ORTHANC_STARTED = 10\n    ORTHANC_STOPPED = 11\n    STABLE_PATIENT = 7\n    STABLE_SERIES = 8\n    STABLE_STUDY = 9\n    UPDATED_ATTACHMENT = 12\n    UPDATED_METADATA = 13\n    UPDATED_MODALITIES = 15\n    UPDATED_PEERS = 14\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CompressionType","title":"<code>CompressionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginCompressionType</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class CompressionType(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginCompressionType\"\"\"\n    GZIP = 2\n    GZIP_WITH_SIZE = 3\n    ZLIB = 0\n    ZLIB_WITH_SIZE = 1\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ConstraintType","title":"<code>ConstraintType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginConstraintType</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ConstraintType(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginConstraintType\"\"\"\n    EQUAL = 1\n    GREATER_OR_EQUAL = 3\n    LIST = 5\n    SMALLER_OR_EQUAL = 2\n    WILDCARD = 4\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ContentType","title":"<code>ContentType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginContentType</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ContentType(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginContentType\"\"\"\n    DICOM = 1\n    DICOM_AS_JSON = 2\n    DICOM_UNTIL_PIXEL_DATA = 3\n    UNKNOWN = 0\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CreateDicomFlags","title":"<code>CreateDicomFlags</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginCreateDicomFlags</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class CreateDicomFlags(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginCreateDicomFlags\"\"\"\n    DECODE_DATA_URI_SCHEME = 1\n    GENERATE_IDENTIFIERS = 2\n    NONE = 0\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance","title":"<code>DicomInstance</code>","text":"<p>Generated from Orthanc C class: OrthancPluginDicomInstance</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class DicomInstance:\n    \"\"\"Generated from Orthanc C class: OrthancPluginDicomInstance\"\"\"\n\n    def GetInstanceAdvancedJson(self, *args, **kwargs) -&gt; str:\n        \"\"\"This function outputs a JSON string representing the tags of this DICOM file.\"\"\"\n        pass\n\n    def GetInstanceData(self) -&gt; Any:\n        \"\"\"This function returns the content of the given DICOM instance.\"\"\"\n        pass\n\n    def GetInstanceDecodedFrame(self, frameIndex: int) -&gt; Image:\n        \"\"\"This function decodes one frame of a DICOM image that is managed by the Orthanc core.\"\"\"\n        pass\n\n    def GetInstanceFramesCount(self) -&gt; int:\n        \"\"\"This function returns the number of frames that are part of a DICOM image managed by the Orthanc core.\"\"\"\n        pass\n\n    def GetInstanceJson(self) -&gt; str:\n        \"\"\"\n        This function returns a string containing a JSON file.\n        This JSON file encodes the tag hierarchy of the given DICOM instance.\n        \"\"\"\n        pass\n\n    def GetInstanceMetadata(self, metadata: str) -&gt; Any:\n        \"\"\"\n        This functions returns the value of some metadata that is associated with the DICOM instance of interest.\n        Before calling this function, the existence of the metadata must have been checked with HasInstanceMetadata().\n        \"\"\"\n        pass\n\n    def GetInstanceOrigin(self) -&gt; InstanceOrigin:\n        \"\"\"This function returns the origin of a DICOM instance that has been received by Orthanc.\"\"\"\n        pass\n\n    def GetInstanceRawFrame(self, *args) -&gt; Any:\n        \"\"\"Generated from C function OrthancPluginGetInstanceRawFrame()\"\"\"\n        pass\n\n    def GetInstanceRemoteAet(self) -&gt; str:\n        \"\"\"\n        This function returns the Application Entity Title (AET) of the DICOM modality\n        from which a DICOM instance originates.\n        \"\"\"\n        pass\n\n    def GetInstanceSimplifiedJson(self) -&gt; str:\n        \"\"\"\n        This function returns a string containing a JSON file.\n        This JSON file encodes the tag hierarchy of the given DICOM instance.\n        In contrast with GetInstanceJson(), the returned JSON file is in its simplified version.\n        \"\"\"\n        pass\n\n    def GetInstanceSize(self) -&gt; int:\n        \"\"\"This function returns the number of bytes of the given DICOM instance.\"\"\"\n        pass\n\n    def GetInstanceTransferSyntaxUid(self) -&gt; str:\n        \"\"\"\n        This function returns a string that contains the transfer syntax UID of the DICOM instance.\n        The empty string might be returned if this information is unknown.\n        \"\"\"\n        pass\n\n    def HasInstanceMetadata(self, metadata: str) -&gt; bool:\n        \"\"\"\n        This function checks whether the DICOM instance of interest is associated with some metadata.\n        As of Orthanc 0.8.1, in the callbacks registered by OnStoredInstanceCallback(),\n        the only possibly available metadata are \"ReceptionDate\", \"RemoteAET\" and \"IndexInSeries\".\n        \"\"\"\n        pass\n\n    def HasInstancePixelData(self) -&gt; bool:\n        \"\"\"\n        This function returns a Boolean value indicating whether the DICOM instance\n        contains the pixel data (7FE0,0010) tag.\n        \"\"\"\n        pass\n\n    def SerializeDicomInstance(self, *args) -&gt; Any:\n        \"\"\"Generated from C function OrthancPluginSerializeDicomInstance()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceAdvancedJson","title":"<code>GetInstanceAdvancedJson(*args, **kwargs)</code>","text":"<p>This function outputs a JSON string representing the tags of this DICOM file.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceAdvancedJson(self, *args, **kwargs) -&gt; str:\n    \"\"\"This function outputs a JSON string representing the tags of this DICOM file.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceData","title":"<code>GetInstanceData()</code>","text":"<p>This function returns the content of the given DICOM instance.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceData(self) -&gt; Any:\n    \"\"\"This function returns the content of the given DICOM instance.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceDecodedFrame","title":"<code>GetInstanceDecodedFrame(frameIndex)</code>","text":"<p>This function decodes one frame of a DICOM image that is managed by the Orthanc core.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceDecodedFrame(self, frameIndex: int) -&gt; Image:\n    \"\"\"This function decodes one frame of a DICOM image that is managed by the Orthanc core.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceFramesCount","title":"<code>GetInstanceFramesCount()</code>","text":"<p>This function returns the number of frames that are part of a DICOM image managed by the Orthanc core.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceFramesCount(self) -&gt; int:\n    \"\"\"This function returns the number of frames that are part of a DICOM image managed by the Orthanc core.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceJson","title":"<code>GetInstanceJson()</code>","text":"<p>This function returns a string containing a JSON file. This JSON file encodes the tag hierarchy of the given DICOM instance.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceJson(self) -&gt; str:\n    \"\"\"\n    This function returns a string containing a JSON file.\n    This JSON file encodes the tag hierarchy of the given DICOM instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceMetadata","title":"<code>GetInstanceMetadata(metadata)</code>","text":"<p>This functions returns the value of some metadata that is associated with the DICOM instance of interest. Before calling this function, the existence of the metadata must have been checked with HasInstanceMetadata().</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceMetadata(self, metadata: str) -&gt; Any:\n    \"\"\"\n    This functions returns the value of some metadata that is associated with the DICOM instance of interest.\n    Before calling this function, the existence of the metadata must have been checked with HasInstanceMetadata().\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceOrigin","title":"<code>GetInstanceOrigin()</code>","text":"<p>This function returns the origin of a DICOM instance that has been received by Orthanc.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceOrigin(self) -&gt; InstanceOrigin:\n    \"\"\"This function returns the origin of a DICOM instance that has been received by Orthanc.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceRawFrame","title":"<code>GetInstanceRawFrame(*args)</code>","text":"<p>Generated from C function OrthancPluginGetInstanceRawFrame()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceRawFrame(self, *args) -&gt; Any:\n    \"\"\"Generated from C function OrthancPluginGetInstanceRawFrame()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceRemoteAet","title":"<code>GetInstanceRemoteAet()</code>","text":"<p>This function returns the Application Entity Title (AET) of the DICOM modality from which a DICOM instance originates.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceRemoteAet(self) -&gt; str:\n    \"\"\"\n    This function returns the Application Entity Title (AET) of the DICOM modality\n    from which a DICOM instance originates.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceSimplifiedJson","title":"<code>GetInstanceSimplifiedJson()</code>","text":"<p>This function returns a string containing a JSON file. This JSON file encodes the tag hierarchy of the given DICOM instance. In contrast with GetInstanceJson(), the returned JSON file is in its simplified version.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceSimplifiedJson(self) -&gt; str:\n    \"\"\"\n    This function returns a string containing a JSON file.\n    This JSON file encodes the tag hierarchy of the given DICOM instance.\n    In contrast with GetInstanceJson(), the returned JSON file is in its simplified version.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceSize","title":"<code>GetInstanceSize()</code>","text":"<p>This function returns the number of bytes of the given DICOM instance.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceSize(self) -&gt; int:\n    \"\"\"This function returns the number of bytes of the given DICOM instance.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.GetInstanceTransferSyntaxUid","title":"<code>GetInstanceTransferSyntaxUid()</code>","text":"<p>This function returns a string that contains the transfer syntax UID of the DICOM instance. The empty string might be returned if this information is unknown.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetInstanceTransferSyntaxUid(self) -&gt; str:\n    \"\"\"\n    This function returns a string that contains the transfer syntax UID of the DICOM instance.\n    The empty string might be returned if this information is unknown.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.HasInstanceMetadata","title":"<code>HasInstanceMetadata(metadata)</code>","text":"<p>This function checks whether the DICOM instance of interest is associated with some metadata. As of Orthanc 0.8.1, in the callbacks registered by OnStoredInstanceCallback(), the only possibly available metadata are \"ReceptionDate\", \"RemoteAET\" and \"IndexInSeries\".</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def HasInstanceMetadata(self, metadata: str) -&gt; bool:\n    \"\"\"\n    This function checks whether the DICOM instance of interest is associated with some metadata.\n    As of Orthanc 0.8.1, in the callbacks registered by OnStoredInstanceCallback(),\n    the only possibly available metadata are \"ReceptionDate\", \"RemoteAET\" and \"IndexInSeries\".\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.HasInstancePixelData","title":"<code>HasInstancePixelData()</code>","text":"<p>This function returns a Boolean value indicating whether the DICOM instance contains the pixel data (7FE0,0010) tag.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def HasInstancePixelData(self) -&gt; bool:\n    \"\"\"\n    This function returns a Boolean value indicating whether the DICOM instance\n    contains the pixel data (7FE0,0010) tag.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstance.SerializeDicomInstance","title":"<code>SerializeDicomInstance(*args)</code>","text":"<p>Generated from C function OrthancPluginSerializeDicomInstance()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SerializeDicomInstance(self, *args) -&gt; Any:\n    \"\"\"Generated from C function OrthancPluginSerializeDicomInstance()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomToJsonFlags","title":"<code>DicomToJsonFlags</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginDicomToJsonFlags</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class DicomToJsonFlags(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginDicomToJsonFlags\"\"\"\n    CONVERT_BINARY_TO_ASCII = 16\n    CONVERT_BINARY_TO_NULL = 32\n    INCLUDE_BINARY = 1\n    INCLUDE_PIXEL_DATA = 8\n    INCLUDE_PRIVATE_TAGS = 2\n    INCLUDE_UNKNOWN_TAGS = 4\n    NONE = 0\n    SKIP_GROUP_LENGTHS = 128\n    STOP_AFTER_PIXEL_DATA = 64\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomToJsonFormat","title":"<code>DicomToJsonFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginDicomToJsonFormat</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class DicomToJsonFormat(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginDicomToJsonFormat\"\"\"\n    FULL = 1\n    HUMAN = 3\n    SHORT = 2\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomWebBinaryMode","title":"<code>DicomWebBinaryMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginDicomWebBinaryMode</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class DicomWebBinaryMode(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginDicomWebBinaryMode\"\"\"\n    BULK_DATA_URI = 2\n    IGNORE = 0\n    INLINE_BINARY = 1\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomWebNode","title":"<code>DicomWebNode</code>","text":"<p>Generated from Orthanc C class: OrthancPluginDicomWebNode</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class DicomWebNode:\n    \"\"\"Generated from Orthanc C class: OrthancPluginDicomWebNode\"\"\"\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ErrorCode","title":"<code>ErrorCode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginErrorCode</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ErrorCode(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginErrorCode\"\"\"\n    ALREADY_EXISTING_TAG = 2042\n    BAD_APPLICATION_ENTITY_TITLE = 2009\n    BAD_FILE_FORMAT = 15\n    BAD_FONT = 30\n    BAD_GEOMETRY = 38\n    BAD_HTTP_STATUS_IN_REST = 2005\n    BAD_JOB_ORDERING = 2028\n    BAD_JSON = 28\n    BAD_PARAMETER_TYPE = 5\n    BAD_RANGE = 41\n    BAD_REQUEST = 8\n    BAD_SEQUENCE_OF_CALLS = 6\n    CANCELED_JOB = 37\n    CANNOT_CREATE_LUA = 2030\n    CANNOT_EXECUTE_LUA = 2031\n    CANNOT_ORDER_SLICES = 2040\n    CANNOT_STORE_INSTANCE = 2018\n    CANNOT_WRITE_FILE = 14\n    CORRUPTED_FILE = 20\n    CREATE_DICOM_BAD_PARENT = 2024\n    CREATE_DICOM_NOT_STRING = 2019\n    CREATE_DICOM_NO_PAYLOAD = 2022\n    CREATE_DICOM_OVERRIDE_TAG = 2020\n    CREATE_DICOM_PARENT_ENCODING = 2026\n    CREATE_DICOM_PARENT_IS_INSTANCE = 2025\n    CREATE_DICOM_USE_CONTENT = 2021\n    CREATE_DICOM_USE_DATA_URI_SCHEME = 2023\n    DATABASE = 11\n    DATABASE_BACKEND_ALREADY_REGISTERED = 2037\n    DATABASE_CANNOT_SERIALIZE = 42\n    DATABASE_NOT_INITIALIZED = 2038\n    DATABASE_PLUGIN = 31\n    DATABASE_UNAVAILABLE = 36\n    DICOM_FIND_UNAVAILABLE = 2016\n    DICOM_MOVE_UNAVAILABLE = 2017\n    DICOM_PORT_IN_USE = 2004\n    DIRECTORY_EXPECTED = 2002\n    DIRECTORY_OVER_FILE = 2000\n    DISCONTINUED_ABI = 40\n    EMPTY_REQUEST = 33\n    FILE_STORAGE_CANNOT_WRITE = 2001\n    FULL_STORAGE = 19\n    HTTP_PORT_IN_USE = 2003\n    INCOMPATIBLE_DATABASE_VERSION = 18\n    INCOMPATIBLE_IMAGE_FORMAT = 23\n    INCOMPATIBLE_IMAGE_SIZE = 24\n    INEXISTENT_FILE = 13\n    INEXISTENT_ITEM = 7\n    INEXISTENT_TAG = 21\n    INTERNAL_ERROR = -1\n    JSON_TO_LUA_TABLE = 2029\n    LUA_ALREADY_EXECUTED = 2032\n    LUA_BAD_OUTPUT = 2033\n    LUA_RETURNS_NO_STRING = 2035\n    MAKE_DIRECTORY = 2008\n    NETWORK_PROTOCOL = 9\n    NOT_ACCEPTABLE = 34\n    NOT_ENOUGH_MEMORY = 4\n    NOT_IMPLEMENTED = 2\n    NOT_LUA_PREDICATE = 2034\n    NO_APPLICATION_ENTITY_FILTER = 2013\n    NO_CFIND_HANDLER = 2010\n    NO_CGET_HANDLER = 2044\n    NO_CMOVE_HANDLER = 2011\n    NO_CSTORE_HANDLER = 2012\n    NO_PRESENTATION_CONTEXT = 2015\n    NO_SOP_CLASS_OR_INSTANCE = 2014\n    NO_STORAGE_COMMITMENT_HANDLER = 2043\n    NO_WORKLIST_HANDLER = 2041\n    NULL_POINTER = 35\n    PARAMETER_OUT_OF_RANGE = 3\n    PATH_TO_EXECUTABLE = 2007\n    PLUGIN = 1\n    READ_ONLY = 22\n    REGULAR_FILE_EXPECTED = 2006\n    REVISION = 43\n    SHARED_LIBRARY = 25\n    SQLITE_ALREADY_OPENED = 1001\n    SQLITE_BIND_OUT_OF_RANGE = 1011\n    SQLITE_CANNOT_OPEN = 1002\n    SQLITE_CANNOT_RUN = 1009\n    SQLITE_CANNOT_STEP = 1010\n    SQLITE_COMMIT_WITHOUT_TRANSACTION = 1006\n    SQLITE_EXECUTE = 1004\n    SQLITE_FLUSH = 1008\n    SQLITE_NOT_OPENED = 1000\n    SQLITE_PREPARE_STATEMENT = 1012\n    SQLITE_REGISTER_FUNCTION = 1007\n    SQLITE_ROLLBACK_WITHOUT_TRANSACTION = 1005\n    SQLITE_STATEMENT_ALREADY_USED = 1003\n    SQLITE_TRANSACTION_ALREADY_STARTED = 1013\n    SQLITE_TRANSACTION_BEGIN = 1015\n    SQLITE_TRANSACTION_COMMIT = 1014\n    SSL_DISABLED = 2039\n    SSL_INITIALIZATION = 39\n    STORAGE_AREA_ALREADY_REGISTERED = 2036\n    STORAGE_AREA_PLUGIN = 32\n    SUCCESS = 0\n    SYSTEM_COMMAND = 10\n    TIMEOUT = 16\n    UNAUTHORIZED = 29\n    UNKNOWN_DICOM_TAG = 27\n    UNKNOWN_MODALITY = 2027\n    UNKNOWN_PLUGIN_SERVICE = 26\n    UNKNOWN_RESOURCE = 17\n    UNSUPPORTED_MEDIA_TYPE = 3000\n    URI_SYNTAX = 12\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindAnswers","title":"<code>FindAnswers</code>","text":"<p>Generated from Orthanc C class: OrthancPluginFindAnswers</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class FindAnswers:\n    \"\"\"Generated from Orthanc C class: OrthancPluginFindAnswers\"\"\"\n\n    def FindAddAnswer(self, *args):\n        \"\"\"Generated from C function OrthancPluginFindAddAnswer()\"\"\"\n        pass\n\n    def FindMarkIncomplete(self, *args):\n        \"\"\"Generated from C function OrthancPluginFindMarkIncomplete()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindAnswers.FindAddAnswer","title":"<code>FindAddAnswer(*args)</code>","text":"<p>Generated from C function OrthancPluginFindAddAnswer()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def FindAddAnswer(self, *args):\n    \"\"\"Generated from C function OrthancPluginFindAddAnswer()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindAnswers.FindMarkIncomplete","title":"<code>FindMarkIncomplete(*args)</code>","text":"<p>Generated from C function OrthancPluginFindMarkIncomplete()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def FindMarkIncomplete(self, *args):\n    \"\"\"Generated from C function OrthancPluginFindMarkIncomplete()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindMatcher","title":"<code>FindMatcher</code>","text":"<p>Generated from Orthanc C class: OrthancPluginFindMatcher</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class FindMatcher:\n    \"\"\"Generated from Orthanc C class: OrthancPluginFindMatcher\"\"\"\n\n    def FindMatcherIsMatch(self, *args):\n        \"\"\"Generated from C function OrthancPluginFindMatcherIsMatch()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindMatcher.FindMatcherIsMatch","title":"<code>FindMatcherIsMatch(*args)</code>","text":"<p>Generated from C function OrthancPluginFindMatcherIsMatch()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def FindMatcherIsMatch(self, *args):\n    \"\"\"Generated from C function OrthancPluginFindMatcherIsMatch()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindQuery","title":"<code>FindQuery</code>","text":"<p>Generated from Orthanc C class: OrthancPluginFindQuery</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class FindQuery:\n    \"\"\"Generated from Orthanc C class: OrthancPluginFindQuery\"\"\"\n\n    def GetFindQuerySize(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetFindQuerySize()\"\"\"\n        pass\n\n    def GetFindQueryTagElement(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetFindQueryTag()\"\"\"\n        pass\n\n    def GetFindQueryTagGroup(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetFindQueryTag()\"\"\"\n        pass\n\n    def GetFindQueryTagName(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetFindQueryTagName()\"\"\"\n        pass\n\n    def GetFindQueryValue(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetFindQueryValue()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindQuery.GetFindQuerySize","title":"<code>GetFindQuerySize(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFindQuerySize()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFindQuerySize(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetFindQuerySize()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindQuery.GetFindQueryTagElement","title":"<code>GetFindQueryTagElement(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFindQueryTag()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFindQueryTagElement(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetFindQueryTag()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindQuery.GetFindQueryTagGroup","title":"<code>GetFindQueryTagGroup(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFindQueryTag()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFindQueryTagGroup(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetFindQueryTag()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindQuery.GetFindQueryTagName","title":"<code>GetFindQueryTagName(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFindQueryTagName()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFindQueryTagName(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetFindQueryTagName()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.FindQuery.GetFindQueryValue","title":"<code>GetFindQueryValue(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFindQueryValue()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFindQueryValue(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetFindQueryValue()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.HttpMethod","title":"<code>HttpMethod</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginHttpMethod</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class HttpMethod(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginHttpMethod\"\"\"\n    DELETE = 4\n    GET = 1\n    POST = 2\n    PUT = 3\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.IdentifierConstraint","title":"<code>IdentifierConstraint</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginIdentifierConstraint</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class IdentifierConstraint(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginIdentifierConstraint\"\"\"\n    EQUAL = 1\n    GREATER_OR_EQUAL = 3\n    SMALLER_OR_EQUAL = 2\n    WILDCARD = 4\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image","title":"<code>Image</code>","text":"<p>Generated from Orthanc C class: OrthancPluginImage</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class Image:\n    \"\"\"Generated from Orthanc C class: OrthancPluginImage\"\"\"\n\n    def ConvertPixelFormat(self, *args):\n        \"\"\"Generated from C function OrthancPluginConvertPixelFormat()\"\"\"\n        pass\n\n    def DrawText(self, *args):\n        \"\"\"Generated from C function OrthancPluginDrawText()\"\"\"\n        pass\n\n    def GetImageBuffer(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetImageBuffer()\"\"\"\n        pass\n\n    def GetImageHeight(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetImageHeight()\"\"\"\n        pass\n\n    def GetImagePitch(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetImagePitch()\"\"\"\n        pass\n\n    def GetImagePixelFormat(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetImagePixelFormat()\"\"\"\n        pass\n\n    def GetImageWidth(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetImageWidth()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image.ConvertPixelFormat","title":"<code>ConvertPixelFormat(*args)</code>","text":"<p>Generated from C function OrthancPluginConvertPixelFormat()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def ConvertPixelFormat(self, *args):\n    \"\"\"Generated from C function OrthancPluginConvertPixelFormat()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image.DrawText","title":"<code>DrawText(*args)</code>","text":"<p>Generated from C function OrthancPluginDrawText()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def DrawText(self, *args):\n    \"\"\"Generated from C function OrthancPluginDrawText()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image.GetImageBuffer","title":"<code>GetImageBuffer(*args)</code>","text":"<p>Generated from C function OrthancPluginGetImageBuffer()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetImageBuffer(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetImageBuffer()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image.GetImageHeight","title":"<code>GetImageHeight(*args)</code>","text":"<p>Generated from C function OrthancPluginGetImageHeight()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetImageHeight(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetImageHeight()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image.GetImagePitch","title":"<code>GetImagePitch(*args)</code>","text":"<p>Generated from C function OrthancPluginGetImagePitch()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetImagePitch(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetImagePitch()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image.GetImagePixelFormat","title":"<code>GetImagePixelFormat(*args)</code>","text":"<p>Generated from C function OrthancPluginGetImagePixelFormat()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetImagePixelFormat(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetImagePixelFormat()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Image.GetImageWidth","title":"<code>GetImageWidth(*args)</code>","text":"<p>Generated from C function OrthancPluginGetImageWidth()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetImageWidth(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetImageWidth()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ImageFormat","title":"<code>ImageFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginImageFormat</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ImageFormat(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginImageFormat\"\"\"\n    DICOM = 2\n    JPEG = 1\n    PNG = 0\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.InstanceOrigin","title":"<code>InstanceOrigin</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginInstanceOrigin</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class InstanceOrigin(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginInstanceOrigin\"\"\"\n    DICOM_PROTOCOL = 2\n    LUA = 5\n    PLUGIN = 4\n    REST_API = 3\n    UNKNOWN = 1\n    WEB_DAV = 6\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Job","title":"<code>Job</code>","text":"<p>Generated from Orthanc C class: OrthancPluginJob</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class Job:\n    \"\"\"Generated from Orthanc C class: OrthancPluginJob\"\"\"\n\n    def SubmitJob(self, *args):\n        \"\"\"Generated from C function OrthancPluginSubmitJob()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Job.SubmitJob","title":"<code>SubmitJob(*args)</code>","text":"<p>Generated from C function OrthancPluginSubmitJob()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SubmitJob(self, *args):\n    \"\"\"Generated from C function OrthancPluginSubmitJob()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.JobStepStatus","title":"<code>JobStepStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginJobStepStatus</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class JobStepStatus(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginJobStepStatus\"\"\"\n    CONTINUE = 3\n    FAILURE = 2\n    SUCCESS = 1\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.JobStopReason","title":"<code>JobStopReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginJobStopReason</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class JobStopReason(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginJobStopReason\"\"\"\n    CANCELED = 4\n    FAILURE = 3\n    PAUSED = 2\n    SUCCESS = 1\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.MetricsType","title":"<code>MetricsType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginMetricsType</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class MetricsType(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginMetricsType\"\"\"\n    DEFAULT = 0\n    TIMER = 1\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.OrthancException","title":"<code>OrthancException</code>","text":"<p>Common base class for all non-exit exceptions.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class OrthancException:\n    \"\"\"Common base class for all non-exit exceptions.\"\"\"\n\n    def with_traceback(self, *args):\n        \"\"\"Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.OrthancException.with_traceback","title":"<code>with_traceback(*args)</code>","text":"<p>Exception.with_traceback(tb) -- set self.traceback to tb and return self.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def with_traceback(self, *args):\n    \"\"\"Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Peers","title":"<code>Peers</code>","text":"<p>Generated from Orthanc C class: OrthancPluginPeers</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class Peers:\n    \"\"\"Generated from Orthanc C class: OrthancPluginPeers\"\"\"\n\n    def GetPeerName(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetPeerName()\"\"\"\n        pass\n\n    def GetPeerUrl(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetPeerUrl()\"\"\"\n        pass\n\n    def GetPeerUserProperty(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetPeerUserProperty()\"\"\"\n        pass\n\n    def GetPeersCount(self, *args):\n        \"\"\"Generated from C function OrthancPluginGetPeersCount()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Peers.GetPeerName","title":"<code>GetPeerName(*args)</code>","text":"<p>Generated from C function OrthancPluginGetPeerName()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetPeerName(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetPeerName()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Peers.GetPeerUrl","title":"<code>GetPeerUrl(*args)</code>","text":"<p>Generated from C function OrthancPluginGetPeerUrl()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetPeerUrl(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetPeerUrl()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Peers.GetPeerUserProperty","title":"<code>GetPeerUserProperty(*args)</code>","text":"<p>Generated from C function OrthancPluginGetPeerUserProperty()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetPeerUserProperty(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetPeerUserProperty()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.Peers.GetPeersCount","title":"<code>GetPeersCount(*args)</code>","text":"<p>Generated from C function OrthancPluginGetPeersCount()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetPeersCount(self, *args):\n    \"\"\"Generated from C function OrthancPluginGetPeersCount()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.PixelFormat","title":"<code>PixelFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginPixelFormat</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class PixelFormat(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginPixelFormat\"\"\"\n    BGRA32 = 10\n    FLOAT32 = 9\n    GRAYSCALE16 = 2\n    GRAYSCALE32 = 8\n    GRAYSCALE64 = 11\n    GRAYSCALE8 = 1\n    RGB24 = 4\n    RGB48 = 7\n    RGBA32 = 5\n    SIGNED_GRAYSCALE16 = 3\n    UNKNOWN = 6\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ReceivedInstanceAction","title":"<code>ReceivedInstanceAction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginReceivedInstanceAction</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ReceivedInstanceAction(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginReceivedInstanceAction\"\"\"\n    DISCARD = 3\n    KEEP_AS_IS = 1\n    MODIFY = 2\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ResourceType","title":"<code>ResourceType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginResourceType</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ResourceType(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginResourceType\"\"\"\n    INSTANCE = 3\n    NONE = 4\n    PATIENT = 0\n    SERIES = 2\n    STUDY = 1\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput","title":"<code>RestOutput</code>","text":"<p>Generated from Orthanc C class: OrthancPluginRestOutput</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class RestOutput:\n    \"\"\"Generated from Orthanc C class: OrthancPluginRestOutput\"\"\"\n\n    def AnswerBuffer(self, *args):\n        \"\"\"Generated from C function OrthancPluginAnswerBuffer()\"\"\"\n        pass\n\n    def CompressAndAnswerJpegImage(self, *args):\n        \"\"\"Generated from C function OrthancPluginCompressAndAnswerJpegImage()\"\"\"\n        pass\n\n    def CompressAndAnswerPngImage(self, *args):\n        \"\"\"Generated from C function OrthancPluginCompressAndAnswerPngImage()\"\"\"\n        pass\n\n    def Redirect(self, *args):\n        \"\"\"Generated from C function OrthancPluginRedirect()\"\"\"\n        pass\n\n    def SendHttpStatus(self, *args):\n        \"\"\"Generated from C function OrthancPluginSendHttpStatus()\"\"\"\n        pass\n\n    def SendHttpStatusCode(self, *args):\n        \"\"\"Generated from C function OrthancPluginSendHttpStatusCode()\"\"\"\n        pass\n\n    def SendMethodNotAllowed(self, *args):\n        \"\"\"Generated from C function OrthancPluginSendMethodNotAllowed()\"\"\"\n        pass\n\n    def SendMultipartItem(self, *args):\n        \"\"\"Generated from C function OrthancPluginSendMultipartItem()\"\"\"\n        pass\n\n    def SendUnauthorized(self, *args):\n        \"\"\"Generated from C function OrthancPluginSendUnauthorized()\"\"\"\n        pass\n\n    def SetCookie(self, *args):\n        \"\"\"Generated from C function OrthancPluginSetCookie()\"\"\"\n        pass\n\n    def SetHttpErrorDetails(self, *args):\n        \"\"\"Generated from C function OrthancPluginSetHttpErrorDetails()\"\"\"\n        pass\n\n    def SetHttpHeader(self, *args):\n        \"\"\"Generated from C function OrthancPluginSetHttpHeader()\"\"\"\n        pass\n\n    def StartMultipartAnswer(self, *args):\n        \"\"\"Generated from C function OrthancPluginStartMultipartAnswer()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.AnswerBuffer","title":"<code>AnswerBuffer(*args)</code>","text":"<p>Generated from C function OrthancPluginAnswerBuffer()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def AnswerBuffer(self, *args):\n    \"\"\"Generated from C function OrthancPluginAnswerBuffer()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.CompressAndAnswerJpegImage","title":"<code>CompressAndAnswerJpegImage(*args)</code>","text":"<p>Generated from C function OrthancPluginCompressAndAnswerJpegImage()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CompressAndAnswerJpegImage(self, *args):\n    \"\"\"Generated from C function OrthancPluginCompressAndAnswerJpegImage()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.CompressAndAnswerPngImage","title":"<code>CompressAndAnswerPngImage(*args)</code>","text":"<p>Generated from C function OrthancPluginCompressAndAnswerPngImage()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CompressAndAnswerPngImage(self, *args):\n    \"\"\"Generated from C function OrthancPluginCompressAndAnswerPngImage()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.Redirect","title":"<code>Redirect(*args)</code>","text":"<p>Generated from C function OrthancPluginRedirect()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def Redirect(self, *args):\n    \"\"\"Generated from C function OrthancPluginRedirect()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SendHttpStatus","title":"<code>SendHttpStatus(*args)</code>","text":"<p>Generated from C function OrthancPluginSendHttpStatus()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SendHttpStatus(self, *args):\n    \"\"\"Generated from C function OrthancPluginSendHttpStatus()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SendHttpStatusCode","title":"<code>SendHttpStatusCode(*args)</code>","text":"<p>Generated from C function OrthancPluginSendHttpStatusCode()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SendHttpStatusCode(self, *args):\n    \"\"\"Generated from C function OrthancPluginSendHttpStatusCode()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SendMethodNotAllowed","title":"<code>SendMethodNotAllowed(*args)</code>","text":"<p>Generated from C function OrthancPluginSendMethodNotAllowed()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SendMethodNotAllowed(self, *args):\n    \"\"\"Generated from C function OrthancPluginSendMethodNotAllowed()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SendMultipartItem","title":"<code>SendMultipartItem(*args)</code>","text":"<p>Generated from C function OrthancPluginSendMultipartItem()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SendMultipartItem(self, *args):\n    \"\"\"Generated from C function OrthancPluginSendMultipartItem()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SendUnauthorized","title":"<code>SendUnauthorized(*args)</code>","text":"<p>Generated from C function OrthancPluginSendUnauthorized()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SendUnauthorized(self, *args):\n    \"\"\"Generated from C function OrthancPluginSendUnauthorized()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SetCookie","title":"<code>SetCookie(*args)</code>","text":"<p>Generated from C function OrthancPluginSetCookie()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SetCookie(self, *args):\n    \"\"\"Generated from C function OrthancPluginSetCookie()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SetHttpErrorDetails","title":"<code>SetHttpErrorDetails(*args)</code>","text":"<p>Generated from C function OrthancPluginSetHttpErrorDetails()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SetHttpErrorDetails(self, *args):\n    \"\"\"Generated from C function OrthancPluginSetHttpErrorDetails()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.SetHttpHeader","title":"<code>SetHttpHeader(*args)</code>","text":"<p>Generated from C function OrthancPluginSetHttpHeader()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SetHttpHeader(self, *args):\n    \"\"\"Generated from C function OrthancPluginSetHttpHeader()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestOutput.StartMultipartAnswer","title":"<code>StartMultipartAnswer(*args)</code>","text":"<p>Generated from C function OrthancPluginStartMultipartAnswer()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def StartMultipartAnswer(self, *args):\n    \"\"\"Generated from C function OrthancPluginStartMultipartAnswer()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ServerChunkedRequestReader","title":"<code>ServerChunkedRequestReader</code>","text":"<p>Generated from Orthanc C class: OrthancPluginServerChunkedRequestReader</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class ServerChunkedRequestReader:\n    \"\"\"Generated from Orthanc C class: OrthancPluginServerChunkedRequestReader\"\"\"\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.StorageArea","title":"<code>StorageArea</code>","text":"<p>Generated from Orthanc C class: OrthancPluginStorageArea</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class StorageArea:\n    \"\"\"Generated from Orthanc C class: OrthancPluginStorageArea\"\"\"\n\n    def ReconstructMainDicomTags(self, *args):\n        \"\"\"Generated from C function OrthancPluginReconstructMainDicomTags()\"\"\"\n        pass\n\n    def StorageAreaCreate(self, *args):\n        \"\"\"Generated from C function OrthancPluginStorageAreaCreate()\"\"\"\n        pass\n\n    def StorageAreaRead(self, *args):\n        \"\"\"Generated from C function OrthancPluginStorageAreaRead()\"\"\"\n        pass\n\n    def StorageAreaRemove(self, *args):\n        \"\"\"Generated from C function OrthancPluginStorageAreaRemove()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.StorageArea.ReconstructMainDicomTags","title":"<code>ReconstructMainDicomTags(*args)</code>","text":"<p>Generated from C function OrthancPluginReconstructMainDicomTags()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def ReconstructMainDicomTags(self, *args):\n    \"\"\"Generated from C function OrthancPluginReconstructMainDicomTags()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.StorageArea.StorageAreaCreate","title":"<code>StorageAreaCreate(*args)</code>","text":"<p>Generated from C function OrthancPluginStorageAreaCreate()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def StorageAreaCreate(self, *args):\n    \"\"\"Generated from C function OrthancPluginStorageAreaCreate()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.StorageArea.StorageAreaRead","title":"<code>StorageAreaRead(*args)</code>","text":"<p>Generated from C function OrthancPluginStorageAreaRead()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def StorageAreaRead(self, *args):\n    \"\"\"Generated from C function OrthancPluginStorageAreaRead()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.StorageArea.StorageAreaRemove","title":"<code>StorageAreaRemove(*args)</code>","text":"<p>Generated from C function OrthancPluginStorageAreaRemove()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def StorageAreaRemove(self, *args):\n    \"\"\"Generated from C function OrthancPluginStorageAreaRemove()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.StorageCommitmentFailureReason","title":"<code>StorageCommitmentFailureReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginStorageCommitmentFailureReason</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class StorageCommitmentFailureReason(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginStorageCommitmentFailureReason\"\"\"\n    CLASS_INSTANCE_CONFLICT = 5\n    DUPLICATE_TRANSACTION_UID = 6\n    NO_SUCH_OBJECT_INSTANCE = 2\n    PROCESSING_FAILURE = 1\n    REFERENCED_SOPCLASS_NOT_SUPPORTED = 4\n    RESOURCE_LIMITATION = 3\n    SUCCESS = 0\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ValueRepresentation","title":"<code>ValueRepresentation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Generated from C enumeration OrthancPluginOrthancPluginValueRepresentation</p> Source code in <code>pyorthanc/_orthanc_sdk_enums.py</code> <pre><code>class ValueRepresentation(Enum):\n    \"\"\"Generated from C enumeration OrthancPluginOrthancPluginValueRepresentation\"\"\"\n    AE = 1\n    AS = 2\n    AT = 3\n    CS = 4\n    DA = 5\n    DS = 6\n    DT = 7\n    FD = 8\n    FL = 9\n    IS = 10\n    LO = 11\n    LT = 12\n    OB = 13\n    OF = 14\n    OW = 15\n    PN = 16\n    SH = 17\n    SL = 18\n    SQ = 19\n    SS = 20\n    ST = 21\n    TM = 22\n    UI = 23\n    UL = 24\n    UN = 25\n    US = 26\n    UT = 27\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.WorklistAnswers","title":"<code>WorklistAnswers</code>","text":"<p>Generated from Orthanc C class: OrthancPluginWorklistAnswers</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class WorklistAnswers:\n    \"\"\"Generated from Orthanc C class: OrthancPluginWorklistAnswers\"\"\"\n\n    def WorklistAddAnswer(self, *args):\n        \"\"\"Generated from C function OrthancPluginWorklistAddAnswer()\"\"\"\n        pass\n\n    def WorklistMarkIncomplete(self, *args):\n        \"\"\"Generated from C function OrthancPluginWorklistMarkIncomplete()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.WorklistAnswers.WorklistAddAnswer","title":"<code>WorklistAddAnswer(*args)</code>","text":"<p>Generated from C function OrthancPluginWorklistAddAnswer()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def WorklistAddAnswer(self, *args):\n    \"\"\"Generated from C function OrthancPluginWorklistAddAnswer()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.WorklistAnswers.WorklistMarkIncomplete","title":"<code>WorklistMarkIncomplete(*args)</code>","text":"<p>Generated from C function OrthancPluginWorklistMarkIncomplete()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def WorklistMarkIncomplete(self, *args):\n    \"\"\"Generated from C function OrthancPluginWorklistMarkIncomplete()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.WorklistQuery","title":"<code>WorklistQuery</code>","text":"<p>Generated from Orthanc C class: OrthancPluginWorklistQuery</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class WorklistQuery:\n    \"\"\"Generated from Orthanc C class: OrthancPluginWorklistQuery\"\"\"\n\n    def WorklistGetDicomQuery(self, *args):\n        \"\"\"Generated from C function OrthancPluginWorklistGetDicomQuery()\"\"\"\n        pass\n\n    def WorklistIsMatch(self, *args):\n        \"\"\"Generated from C function OrthancPluginWorklistIsMatch()\"\"\"\n        pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.WorklistQuery.WorklistGetDicomQuery","title":"<code>WorklistGetDicomQuery(*args)</code>","text":"<p>Generated from C function OrthancPluginWorklistGetDicomQuery()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def WorklistGetDicomQuery(self, *args):\n    \"\"\"Generated from C function OrthancPluginWorklistGetDicomQuery()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.WorklistQuery.WorklistIsMatch","title":"<code>WorklistIsMatch(*args)</code>","text":"<p>Generated from C function OrthancPluginWorklistIsMatch()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def WorklistIsMatch(self, *args):\n    \"\"\"Generated from C function OrthancPluginWorklistIsMatch()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.__loader__","title":"<code>__loader__</code>","text":"<p>Meta path import for built-in modules.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>class __loader__:\n    \"\"\"Meta path import for built-in modules.\"\"\"\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.AutodetectMimeType","title":"<code>AutodetectMimeType(*args)</code>","text":"<p>Generated from C function OrthancPluginAutodetectMimeType()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def AutodetectMimeType(*args):\n    \"\"\"Generated from C function OrthancPluginAutodetectMimeType()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.BufferCompression","title":"<code>BufferCompression(memory_buffer, source, size, compression, uncompress)</code>","text":"<p>Compress or decompress a buffer.</p> <p>This function compresses or decompresses a buffer, using the version of the zlib library that is used by the Orthanc core.</p> <p>Parameters:</p> Name Type Description Default <code>memory_buffer</code> <code>Any</code> <p>The target memory buffer. It must be freed with OrthancPluginFreeMemoryBuffer()</p> required <code>source</code> <code>Any</code> <p>The source buffer.</p> required <code>size</code> <code>int</code> <p>The size in bytes of the source buffer.</p> required <code>compression</code> <code>CompressionType</code> <p>The compression algorithm.</p> required <code>uncompress</code> <code>int</code> <p>If set to \"0\", the buffer must be compressed.</p> required <p>Returns:</p> Type Description <code>    0 if success, or the error code if failure.</code> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def BufferCompression(memory_buffer: Any,\n                      source: Any,\n                      size: int,\n                      compression: CompressionType,\n                      uncompress: int) -&gt; int:\n    \"\"\"Compress or decompress a buffer.\n\n    This function compresses or decompresses a buffer, using the version of the zlib\n    library that is used by the Orthanc core.\n\n    Parameters\n    ----------\n    memory_buffer\n        The target memory buffer. It must be freed with OrthancPluginFreeMemoryBuffer()\n    source\n        The source buffer.\n    size\n        The size in bytes of the source buffer.\n    compression\n        The compression algorithm.\n    uncompress\n        If set to \"0\", the buffer must be compressed.\n\n    Returns\n    -------\n        0 if success, or the error code if failure.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CheckVersion","title":"<code>CheckVersion()</code>","text":"<p>Check the compatibility of the plugin wrt. the version of its hosting Orthanc.</p> <p>This function checks whether the version of the Orthanc server running this plugin, is above the version of the current Orthanc SDK header. This guarantees that the plugin is compatible with the hosting Orthanc (i.e. it will not call unavailable services). The result of this function should always be checked in the OrthancPluginInitialize() entry point of the plugin.</p> <p>Returns:</p> Type Description <code>    1 if and only if the versions are compatible. If the result is 0,</code> <p>the initialization of the plugin should fail.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CheckVersion() -&gt; int:\n    \"\"\"Check the compatibility of the plugin wrt. the version of its hosting Orthanc.\n\n    This function checks whether the version of the Orthanc server\n    running this plugin, is above the version of the current Orthanc\n    SDK header. This guarantees that the plugin is compatible with\n    the hosting Orthanc (i.e. it will not call unavailable services).\n    The result of this function should always be checked in the\n    OrthancPluginInitialize() entry point of the plugin.\n\n    Returns\n    -------\n        1 if and only if the versions are compatible. If the result is 0,\n        the initialization of the plugin should fail.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CheckVersionAdvanced","title":"<code>CheckVersionAdvanced(*args)</code>","text":"<p>Generated from C function OrthancPluginCheckVersionAdvanced()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CheckVersionAdvanced(*args):\n    \"\"\"Generated from C function OrthancPluginCheckVersionAdvanced()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CompressJpegImage","title":"<code>CompressJpegImage(*args)</code>","text":"<p>Generated from C function OrthancPluginCompressJpegImage()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CompressJpegImage(*args):\n    \"\"\"Generated from C function OrthancPluginCompressJpegImage()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CompressPngImage","title":"<code>CompressPngImage(*args)</code>","text":"<p>Generated from C function OrthancPluginCompressPngImage()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CompressPngImage(*args):\n    \"\"\"Generated from C function OrthancPluginCompressPngImage()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ComputeMd5","title":"<code>ComputeMd5(*args)</code>","text":"<p>Generated from C function OrthancPluginComputeMd5()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def ComputeMd5(*args):\n    \"\"\"Generated from C function OrthancPluginComputeMd5()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ComputeSha1","title":"<code>ComputeSha1(*args)</code>","text":"<p>Generated from C function OrthancPluginComputeSha1()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def ComputeSha1(*args):\n    \"\"\"Generated from C function OrthancPluginComputeSha1()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CreateDicom","title":"<code>CreateDicom(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CreateDicom(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CreateDicomInstance","title":"<code>CreateDicomInstance(*args)</code>","text":"<p>Generated from C function OrthancPluginCreateDicomInstance()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CreateDicomInstance(*args):\n    \"\"\"Generated from C function OrthancPluginCreateDicomInstance()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CreateFindMatcher","title":"<code>CreateFindMatcher(*args)</code>","text":"<p>Generated from C function OrthancPluginCreateFindMatcher()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CreateFindMatcher(*args):\n    \"\"\"Generated from C function OrthancPluginCreateFindMatcher()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CreateImage","title":"<code>CreateImage(*args)</code>","text":"<p>Generated from C function OrthancPluginCreateImage()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CreateImage(*args):\n    \"\"\"Generated from C function OrthancPluginCreateImage()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CreateImageFromBuffer","title":"<code>CreateImageFromBuffer(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CreateImageFromBuffer(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.CreateMemoryBuffer","title":"<code>CreateMemoryBuffer(*args)</code>","text":"<p>Generated from C function OrthancPluginCreateMemoryBuffer()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def CreateMemoryBuffer(*args):\n    \"\"\"Generated from C function OrthancPluginCreateMemoryBuffer()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DecodeDicomImage","title":"<code>DecodeDicomImage(*args)</code>","text":"<p>Generated from C function OrthancPluginDecodeDicomImage()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def DecodeDicomImage(*args):\n    \"\"\"Generated from C function OrthancPluginDecodeDicomImage()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomBufferToJson","title":"<code>DicomBufferToJson(*args)</code>","text":"<p>Generated from C function OrthancPluginDicomBufferToJson()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def DicomBufferToJson(*args):\n    \"\"\"Generated from C function OrthancPluginDicomBufferToJson()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.DicomInstanceToJson","title":"<code>DicomInstanceToJson(*args)</code>","text":"<p>Generated from C function OrthancPluginDicomInstanceToJson()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def DicomInstanceToJson(*args):\n    \"\"\"Generated from C function OrthancPluginDicomInstanceToJson()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ExtendOrthancExplorer","title":"<code>ExtendOrthancExplorer(*args)</code>","text":"<p>Generated from C function OrthancPluginExtendOrthancExplorer()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def ExtendOrthancExplorer(*args):\n    \"\"\"Generated from C function OrthancPluginExtendOrthancExplorer()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GenerateRestApiAuthorizationToken","title":"<code>GenerateRestApiAuthorizationToken(*args)</code>","text":"<p>Generated from C function OrthancPluginGenerateRestApiAuthorizationToken()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GenerateRestApiAuthorizationToken(*args):\n    \"\"\"Generated from C function OrthancPluginGenerateRestApiAuthorizationToken()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GenerateUuid","title":"<code>GenerateUuid(*args)</code>","text":"<p>Generated from C function OrthancPluginGenerateUuid()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GenerateUuid(*args):\n    \"\"\"Generated from C function OrthancPluginGenerateUuid()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetCommandLineArgument","title":"<code>GetCommandLineArgument(*args)</code>","text":"<p>Generated from C function OrthancPluginGetCommandLineArgument()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetCommandLineArgument(*args):\n    \"\"\"Generated from C function OrthancPluginGetCommandLineArgument()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetCommandLineArgumentsCount","title":"<code>GetCommandLineArgumentsCount(*args)</code>","text":"<p>Generated from C function OrthancPluginGetCommandLineArgumentsCount()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetCommandLineArgumentsCount(*args):\n    \"\"\"Generated from C function OrthancPluginGetCommandLineArgumentsCount()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetConfiguration","title":"<code>GetConfiguration(*args)</code>","text":"<p>Generated from C function OrthancPluginGetConfiguration()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetConfiguration(*args):\n    \"\"\"Generated from C function OrthancPluginGetConfiguration()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetConfigurationPath","title":"<code>GetConfigurationPath(*args)</code>","text":"<p>Generated from C function OrthancPluginGetConfigurationPath()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetConfigurationPath(*args):\n    \"\"\"Generated from C function OrthancPluginGetConfigurationPath()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetDicomForInstance","title":"<code>GetDicomForInstance(*args)</code>","text":"<p>Generated from C function OrthancPluginGetDicomForInstance()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetDicomForInstance(*args):\n    \"\"\"Generated from C function OrthancPluginGetDicomForInstance()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetErrorDescription","title":"<code>GetErrorDescription(*args)</code>","text":"<p>Generated from C function OrthancPluginGetErrorDescription()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetErrorDescription(*args):\n    \"\"\"Generated from C function OrthancPluginGetErrorDescription()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetExpectedDatabaseVersion","title":"<code>GetExpectedDatabaseVersion(*args)</code>","text":"<p>Generated from C function OrthancPluginGetExpectedDatabaseVersion()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetExpectedDatabaseVersion(*args):\n    \"\"\"Generated from C function OrthancPluginGetExpectedDatabaseVersion()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetFontName","title":"<code>GetFontName(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFontName()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFontName(*args):\n    \"\"\"Generated from C function OrthancPluginGetFontName()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetFontSize","title":"<code>GetFontSize(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFontSize()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFontSize(*args):\n    \"\"\"Generated from C function OrthancPluginGetFontSize()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetFontsCount","title":"<code>GetFontsCount(*args)</code>","text":"<p>Generated from C function OrthancPluginGetFontsCount()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetFontsCount(*args):\n    \"\"\"Generated from C function OrthancPluginGetFontsCount()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetGlobalProperty","title":"<code>GetGlobalProperty(*args)</code>","text":"<p>Generated from C function OrthancPluginGetGlobalProperty()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetGlobalProperty(*args):\n    \"\"\"Generated from C function OrthancPluginGetGlobalProperty()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetOrthancDirectory","title":"<code>GetOrthancDirectory(*args)</code>","text":"<p>Generated from C function OrthancPluginGetOrthancDirectory()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetOrthancDirectory(*args):\n    \"\"\"Generated from C function OrthancPluginGetOrthancDirectory()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetOrthancPath","title":"<code>GetOrthancPath(*args)</code>","text":"<p>Generated from C function OrthancPluginGetOrthancPath()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetOrthancPath(*args):\n    \"\"\"Generated from C function OrthancPluginGetOrthancPath()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetPeers","title":"<code>GetPeers(*args)</code>","text":"<p>Generated from C function OrthancPluginGetPeers()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetPeers(*args):\n    \"\"\"Generated from C function OrthancPluginGetPeers()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.GetTagName","title":"<code>GetTagName(*args)</code>","text":"<p>Generated from C function OrthancPluginGetTagName()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def GetTagName(*args):\n    \"\"\"Generated from C function OrthancPluginGetTagName()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.HttpDelete","title":"<code>HttpDelete(*args)</code>","text":"<p>Generated from C function OrthancPluginHttpDelete()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def HttpDelete(*args):\n    \"\"\"Generated from C function OrthancPluginHttpDelete()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.HttpGet","title":"<code>HttpGet(*args)</code>","text":"<p>Generated from C function OrthancPluginHttpGet()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def HttpGet(*args):\n    \"\"\"Generated from C function OrthancPluginHttpGet()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.HttpPost","title":"<code>HttpPost(*args)</code>","text":"<p>Generated from C function OrthancPluginHttpPost()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def HttpPost(*args):\n    \"\"\"Generated from C function OrthancPluginHttpPost()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.HttpPut","title":"<code>HttpPut(*args)</code>","text":"<p>Generated from C function OrthancPluginHttpPut()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def HttpPut(*args):\n    \"\"\"Generated from C function OrthancPluginHttpPut()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LogError","title":"<code>LogError(*args)</code>","text":"<p>Generated from C function OrthancPluginLogError()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LogError(*args):\n    \"\"\"Generated from C function OrthancPluginLogError()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LogInfo","title":"<code>LogInfo(*args)</code>","text":"<p>Generated from C function OrthancPluginLogInfo()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LogInfo(*args):\n    \"\"\"Generated from C function OrthancPluginLogInfo()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LogWarning","title":"<code>LogWarning(*args)</code>","text":"<p>Generated from C function OrthancPluginLogWarning()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LogWarning(*args):\n    \"\"\"Generated from C function OrthancPluginLogWarning()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LookupDictionary","title":"<code>LookupDictionary(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LookupDictionary(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LookupInstance","title":"<code>LookupInstance(*args)</code>","text":"<p>Generated from C function OrthancPluginLookupInstance()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LookupInstance(*args):\n    \"\"\"Generated from C function OrthancPluginLookupInstance()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LookupPatient","title":"<code>LookupPatient(*args)</code>","text":"<p>Generated from C function OrthancPluginLookupPatient()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LookupPatient(*args):\n    \"\"\"Generated from C function OrthancPluginLookupPatient()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LookupSeries","title":"<code>LookupSeries(*args)</code>","text":"<p>Generated from C function OrthancPluginLookupSeries()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LookupSeries(*args):\n    \"\"\"Generated from C function OrthancPluginLookupSeries()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LookupStudy","title":"<code>LookupStudy(*args)</code>","text":"<p>Generated from C function OrthancPluginLookupStudy()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LookupStudy(*args):\n    \"\"\"Generated from C function OrthancPluginLookupStudy()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.LookupStudyWithAccessionNumber","title":"<code>LookupStudyWithAccessionNumber(*args)</code>","text":"<p>Generated from C function OrthancPluginLookupStudyWithAccessionNumber()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def LookupStudyWithAccessionNumber(*args):\n    \"\"\"Generated from C function OrthancPluginLookupStudyWithAccessionNumber()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.ReadFile","title":"<code>ReadFile(*args)</code>","text":"<p>Generated from C function OrthancPluginReadFile()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def ReadFile(*args):\n    \"\"\"Generated from C function OrthancPluginReadFile()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterDictionaryTag","title":"<code>RegisterDictionaryTag(*args)</code>","text":"<p>Generated from C function OrthancPluginRegisterDictionaryTag()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterDictionaryTag(*args):\n    \"\"\"Generated from C function OrthancPluginRegisterDictionaryTag()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterErrorCode","title":"<code>RegisterErrorCode(*args)</code>","text":"<p>Generated from C function OrthancPluginRegisterErrorCode()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterErrorCode(*args):\n    \"\"\"Generated from C function OrthancPluginRegisterErrorCode()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterFindCallback","title":"<code>RegisterFindCallback(func)</code>","text":"<p>Register on C-Find Callback</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[FindAnswers, FindQuery, str, str], None]</code> <p>Function that is call when Orthanc receive an incoming C-Find request</p> required <p>Examples:</p> <p>From https://orthanc.uclouvain.be/book/plugins/python.html#handling-dicom-scp-requests-new-in-3-2</p> <pre><code>def on_find(answers, query, issuerAet, calledAet):\n    print('Received incoming C-FIND request from %s:' % issuerAet)\n\n    answer = {}\n    for i in range(query.GetFindQuerySize()):\n        print('  %s (%04x,%04x) = [%s]' % (query.GetFindQueryTagName(i),\n                                           query.GetFindQueryTagGroup(i),\n                                           query.GetFindQueryTagElement(i),\n                                           query.GetFindQueryValue(i)))\n        answer[query.GetFindQueryTagName(i)] = ('HELLO%d-%s' % (i, query.GetFindQueryValue(i)))\n\n    answers.FindAddAnswer(orthanc.CreateDicom(json.dumps(answer), None, orthanc.CreateDicomFlags.NONE))\n\northanc.RegisterFindCallback(on_find)\n</code></pre> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterFindCallback(func: Callable[[FindAnswers, FindQuery, str, str], None]) -&gt; None:\n    \"\"\"Register on C-Find Callback\n\n    Parameters\n    ----------\n    func\n        Function that is call when Orthanc receive an incoming C-Find request\n\n    Examples\n    --------\n    From https://orthanc.uclouvain.be/book/plugins/python.html#handling-dicom-scp-requests-new-in-3-2\n    ```python\n    def on_find(answers, query, issuerAet, calledAet):\n        print('Received incoming C-FIND request from %s:' % issuerAet)\n\n        answer = {}\n        for i in range(query.GetFindQuerySize()):\n            print('  %s (%04x,%04x) = [%s]' % (query.GetFindQueryTagName(i),\n                                               query.GetFindQueryTagGroup(i),\n                                               query.GetFindQueryTagElement(i),\n                                               query.GetFindQueryValue(i)))\n            answer[query.GetFindQueryTagName(i)] = ('HELLO%d-%s' % (i, query.GetFindQueryValue(i)))\n\n        answers.FindAddAnswer(orthanc.CreateDicom(json.dumps(answer), None, orthanc.CreateDicomFlags.NONE))\n\n    orthanc.RegisterFindCallback(on_find)\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterIncomingCStoreInstanceFilter","title":"<code>RegisterIncomingCStoreInstanceFilter(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterIncomingCStoreInstanceFilter(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterIncomingHttpRequestFilter","title":"<code>RegisterIncomingHttpRequestFilter(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterIncomingHttpRequestFilter(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterMoveCallback","title":"<code>RegisterMoveCallback(func)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterMoveCallback(func: Callable):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterMoveCallback2","title":"<code>RegisterMoveCallback2(create_move_func, get_move_func, apply_move_func, free_move_func)</code>","text":"<p>See https://github.com/orthanc-team/dicom-dicomweb-proxy/blob/main/proxy.py for an example from the OrthancTeam.</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterMoveCallback2(create_move_func: Callable, get_move_func: Callable, apply_move_func: Callable, free_move_func: Callable) -&gt; None:\n    \"\"\"See https://github.com/orthanc-team/dicom-dicomweb-proxy/blob/main/proxy.py for an example from the OrthancTeam.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterOnChangeCallback","title":"<code>RegisterOnChangeCallback(func)</code>","text":"<p>Register on change callback</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ChangeType, ResourceType, str], None]</code> <p>Function that is called as callback.</p> required <p>Examples:</p> <p>From https://book.orthanc-server.com/plugins/python.html#listening-to-changes.</p> <pre><code>def on_change(change_type: orthanc_sdk.ChangeType, level: orthanc_sdk.ResourceType, resource: str) -&gt; None:\n    if changeType == orthanc_sdk.ChangeType.ORTHANC_STARTED:\n        with open('/tmp/sample.dcm', 'rb') as f:\n            orthanc.RestApiPost('/instances', f.read())\n\n    elif changeType == orthanc_sdk.ChangeType.ORTHANC_STOPPED:\n        print('Stopped')\n\n    elif changeType == orthanc_sdk.ChangeType.NEW_INSTANCE:\n        print('A new instance was uploaded: %s' % resource)\n\northanc_sdk.RegisterOnChangeCallback(on_change)\n</code></pre> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterOnChangeCallback(func: Callable[[ChangeType, ResourceType, str], None]):\n    \"\"\"Register on change callback\n\n    Parameters\n    ----------\n    func\n        Function that is called as callback.\n\n    Examples\n    --------\n    From https://book.orthanc-server.com/plugins/python.html#listening-to-changes.\n    ```python\n    def on_change(change_type: orthanc_sdk.ChangeType, level: orthanc_sdk.ResourceType, resource: str) -&gt; None:\n        if changeType == orthanc_sdk.ChangeType.ORTHANC_STARTED:\n            with open('/tmp/sample.dcm', 'rb') as f:\n                orthanc.RestApiPost('/instances', f.read())\n\n        elif changeType == orthanc_sdk.ChangeType.ORTHANC_STOPPED:\n            print('Stopped')\n\n        elif changeType == orthanc_sdk.ChangeType.NEW_INSTANCE:\n            print('A new instance was uploaded: %s' % resource)\n\n    orthanc_sdk.RegisterOnChangeCallback(on_change)\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterOnStoredInstanceCallback","title":"<code>RegisterOnStoredInstanceCallback(func)</code>","text":"<p>Register a callback for when an instance is stored.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[DicomInstance, str], None]</code> <p>Function that is called as callback.</p> required <p>Examples:</p> <p>Example from https://book.orthanc-server.com/plugins/python.html#accessing-the-content-of-a-new-instance</p> <pre><code>def on_store_instance(dicom: orthanc_sdk.DicomInstance, instance_id: str):\n    print('Received instance %s of size %d (transfer syntax %s, SOP class UID %s)' % (\n        instance_id, dicom.GetInstanceSize(),\n        dicom.GetInstanceMetadata('TransferSyntax'),\n        dicom.GetInstanceMetadata('SopClassUid')))\n\n    if dicom.GetInstanceOrigin() == orthanc_sdk.InstanceOrigin.DICOM_PROTOCOL:\n        print('This instance was received through the DICOM protocol')\n    elif dicom.GetInstanceOrigin() == orthanc_sdk.InstanceOrigin.REST_API:\n        print('This instance was received through the REST API')\n\northanc_sdk.RegisterOnStoredInstanceCallback(on_store_instance)\n</code></pre> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterOnStoredInstanceCallback(func: Callable[[DicomInstance, str], None]):\n    \"\"\"Register a callback for when an instance is stored.\n\n    Parameters\n    ----------\n    func\n        Function that is called as callback.\n\n    Examples\n    --------\n    Example from https://book.orthanc-server.com/plugins/python.html#accessing-the-content-of-a-new-instance\n    ```python\n    def on_store_instance(dicom: orthanc_sdk.DicomInstance, instance_id: str):\n        print('Received instance %s of size %d (transfer syntax %s, SOP class UID %s)' % (\n            instance_id, dicom.GetInstanceSize(),\n            dicom.GetInstanceMetadata('TransferSyntax'),\n            dicom.GetInstanceMetadata('SopClassUid')))\n\n        if dicom.GetInstanceOrigin() == orthanc_sdk.InstanceOrigin.DICOM_PROTOCOL:\n            print('This instance was received through the DICOM protocol')\n        elif dicom.GetInstanceOrigin() == orthanc_sdk.InstanceOrigin.REST_API:\n            print('This instance was received through the REST API')\n\n    orthanc_sdk.RegisterOnStoredInstanceCallback(on_store_instance)\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterPrivateDictionaryTag","title":"<code>RegisterPrivateDictionaryTag(*args)</code>","text":"<p>Generated from C function OrthancPluginRegisterPrivateDictionaryTag()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterPrivateDictionaryTag(*args):\n    \"\"\"Generated from C function OrthancPluginRegisterPrivateDictionaryTag()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterReceivedInstanceCallback","title":"<code>RegisterReceivedInstanceCallback(func)</code>","text":"<p>Register a callback for when an instance arrives (but hasn't been stored).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[DicomInstance, InstanceOrigin], Tuple[ReceivedInstanceAction, Optional[bytes]]]</code> <p>Function that is called as callback.</p> required <p>Examples:</p> <pre><code>def on_received_instance(dicom: orthanc_sdk.DicomInstance, origin: orthanc_sdk.InstanceOrigin):\n    if origin == origin.REST_API:\n        LogInfo('Not accepting DICOM from REST API.')\n        return ReceivedInstanceAction.DISCARD, None\n\n    return ReceivedInstanceAction.KEEP_AS_IS, None\n\northanc.RegisterReceivedInstanceCallback(on_received_instance)\n</code></pre> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterReceivedInstanceCallback(\n        func: Callable[[DicomInstance, InstanceOrigin], Tuple[ReceivedInstanceAction, Optional[bytes]]]):\n    \"\"\"Register a callback for when an instance arrives (but hasn't been stored).\n\n    Parameters\n    ----------\n    func\n        Function that is called as callback.\n\n    Examples\n    --------\n    ```python\n    def on_received_instance(dicom: orthanc_sdk.DicomInstance, origin: orthanc_sdk.InstanceOrigin):\n        if origin == origin.REST_API:\n            LogInfo('Not accepting DICOM from REST API.')\n            return ReceivedInstanceAction.DISCARD, None\n\n        return ReceivedInstanceAction.KEEP_AS_IS, None\n\n    orthanc.RegisterReceivedInstanceCallback(on_received_instance)\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterRestCallback","title":"<code>RegisterRestCallback(new_route, func)</code>","text":"<p>Register a REST callback.</p> <p>This function registers a REST callback against a regular expression for a URI. This function must be called during the initialization of the plugin, i.e. inside the OrthancPluginInitialize() public function.</p> <p>Parameters:</p> Name Type Description Default <code>new_route</code> <code>str</code> <p>Regular expression for the URI. May contain groups.</p> required <code>func</code> <code>Callable[[RestOutput, str, Any], None]</code> <p>The callback function to handle the REST call.</p> required <p>Examples:</p> <p>Example from https://book.orthanc-server.com/plugins/python.html#extending-the-rest-api</p> <pre><code>def on_rest(output: orthanc_sdk.RestOutput, uri: str, **request):\n    print(request)\n    output.AnswerBuffer('ok', 'text/plain')\n\northanc.RegisterRestCallback('/tata', on_rest)\n</code></pre> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterRestCallback(new_route: str, func: Callable[[RestOutput, str, Any], None]) -&gt; None:\n    \"\"\"Register a REST callback.\n\n    This function registers a REST callback against a regular\n    expression for a URI. This function must be called during the\n    initialization of the plugin, i.e. inside the\n    OrthancPluginInitialize() public function.\n\n    Parameters\n    ----------\n    new_route\n        Regular expression for the URI. May contain groups.\n    func\n        The callback function to handle the REST call.\n\n    Examples\n    --------\n    Example from https://book.orthanc-server.com/plugins/python.html#extending-the-rest-api\n    ```python\n    def on_rest(output: orthanc_sdk.RestOutput, uri: str, **request):\n        print(request)\n        output.AnswerBuffer('ok', 'text/plain')\n\n    orthanc.RegisterRestCallback('/tata', on_rest)\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterStorageArea","title":"<code>RegisterStorageArea(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterStorageArea(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterStorageCommitmentScpCallback","title":"<code>RegisterStorageCommitmentScpCallback(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterStorageCommitmentScpCallback(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RegisterWorklistCallback","title":"<code>RegisterWorklistCallback(*args)</code>","text":"<p>None</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RegisterWorklistCallback(*args):\n    \"\"\"None\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiDelete","title":"<code>RestApiDelete(*args)</code>","text":"<p>Generated from C function OrthancPluginRestApiDelete()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiDelete(*args):\n    \"\"\"Generated from C function OrthancPluginRestApiDelete()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiDeleteAfterPlugins","title":"<code>RestApiDeleteAfterPlugins(*args)</code>","text":"<p>Generated from C function OrthancPluginRestApiDeleteAfterPlugins()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiDeleteAfterPlugins(*args):\n    \"\"\"Generated from C function OrthancPluginRestApiDeleteAfterPlugins()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiGet","title":"<code>RestApiGet(*args)</code>","text":"<p>Generated from C function OrthancPluginRestApiGet()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiGet(*args):\n    \"\"\"Generated from C function OrthancPluginRestApiGet()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiGetAfterPlugins","title":"<code>RestApiGetAfterPlugins(*args)</code>","text":"<p>Generated from C function OrthancPluginRestApiGetAfterPlugins()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiGetAfterPlugins(*args):\n    \"\"\"Generated from C function OrthancPluginRestApiGetAfterPlugins()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiPost","title":"<code>RestApiPost(uri, body, *args, **kwargs)</code>","text":"<p>Make a POST call to the built-in Orthanc REST API.</p> <p>Make a POST call to the built-in Orthanc REST API. The result to the query is stored into a newly allocated memory buffer.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI in the built-in Orthanc API.</p> required <code>body</code> <code>Any</code> <p>The body of the POST request.</p> required <code>*args</code> <code>()</code> <code>**kwargs</code> <code>{}</code> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiPost(uri: str, body: Any, *args, **kwargs):\n    \"\"\"Make a POST call to the built-in Orthanc REST API.\n\n    Make a POST call to the built-in Orthanc REST API. The result to\n    the query is stored into a newly allocated memory buffer.\n\n    Parameters\n    ----------\n    uri\n        The URI in the built-in Orthanc API.\n    body\n        The body of the POST request.\n    *args\n    **kwargs\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiPostAfterPlugins","title":"<code>RestApiPostAfterPlugins(*args)</code>","text":"<p>Generated from C function OrthancPluginRestApiPostAfterPlugins()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiPostAfterPlugins(*args):\n    \"\"\"Generated from C function OrthancPluginRestApiPostAfterPlugins()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiPut","title":"<code>RestApiPut(*args)</code>","text":"<p>Generated from C function OrthancPluginRestApiPut()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiPut(*args):\n    \"\"\"Generated from C function OrthancPluginRestApiPut()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.RestApiPutAfterPlugins","title":"<code>RestApiPutAfterPlugins(*args)</code>","text":"<p>Generated from C function OrthancPluginRestApiPutAfterPlugins()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def RestApiPutAfterPlugins(*args):\n    \"\"\"Generated from C function OrthancPluginRestApiPutAfterPlugins()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.SetDescription","title":"<code>SetDescription(*args)</code>","text":"<p>Generated from C function OrthancPluginSetDescription()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SetDescription(*args):\n    \"\"\"Generated from C function OrthancPluginSetDescription()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.SetGlobalProperty","title":"<code>SetGlobalProperty(*args)</code>","text":"<p>Generated from C function OrthancPluginSetGlobalProperty()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SetGlobalProperty(*args):\n    \"\"\"Generated from C function OrthancPluginSetGlobalProperty()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.SetMetricsValue","title":"<code>SetMetricsValue(*args)</code>","text":"<p>Generated from C function OrthancPluginSetMetricsValue()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SetMetricsValue(*args):\n    \"\"\"Generated from C function OrthancPluginSetMetricsValue()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.SetRootUri","title":"<code>SetRootUri(*args)</code>","text":"<p>Generated from C function OrthancPluginSetRootUri()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def SetRootUri(*args):\n    \"\"\"Generated from C function OrthancPluginSetRootUri()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.TranscodeDicomInstance","title":"<code>TranscodeDicomInstance(*args)</code>","text":"<p>Generated from C function OrthancPluginTranscodeDicomInstance()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def TranscodeDicomInstance(*args):\n    \"\"\"Generated from C function OrthancPluginTranscodeDicomInstance()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.UncompressImage","title":"<code>UncompressImage(*args)</code>","text":"<p>Generated from C function OrthancPluginUncompressImage()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def UncompressImage(*args):\n    \"\"\"Generated from C function OrthancPluginUncompressImage()\"\"\"\n    pass\n</code></pre>"},{"location":"api/orthanc_sdk/#pyorthanc.orthanc_sdk.WriteFile","title":"<code>WriteFile(*args)</code>","text":"<p>Generated from C function OrthancPluginWriteFile()</p> Source code in <code>pyorthanc/orthanc_sdk.py</code> <pre><code>def WriteFile(*args):\n    \"\"\"Generated from C function OrthancPluginWriteFile()\"\"\"\n    pass\n</code></pre>"},{"location":"api/retrieve/","title":"Retrieve","text":""},{"location":"api/retrieve/#pyorthanc.retrieve","title":"<code>pyorthanc.retrieve</code>","text":""},{"location":"api/retrieve/#pyorthanc.retrieve.retrieve_and_write_patients","title":"<code>retrieve_and_write_patients(patients, path)</code>","text":"<p>Retrieve and write patients to given path</p> <p>Parameters:</p> Name Type Description Default <code>patients</code> <code>List[Patient]</code> <p>List of patients.</p> required <code>path</code> <code>Union[str, PathLike]</code> <p>Path where you want to write the files.</p> required Source code in <code>pyorthanc/retrieve.py</code> <pre><code>def retrieve_and_write_patients(patients: List[Patient], path: Union[str, os.PathLike]) -&gt; None:\n    \"\"\"Retrieve and write patients to given path\n\n    Parameters\n    ----------\n    patients\n        List of patients.\n    path\n        Path where you want to write the files.\n    \"\"\"\n    for patient in patients:\n        retrieve_and_write_patient(patient, path)\n</code></pre>"},{"location":"api/upload/","title":"Upload","text":"<p>The Orthanc REST API is commonly used to upload DICOM files. To do so, you can use the <code>upload()</code> function.</p> <pre><code>from pyorthanc import Orthanc, upload\n\northanc = Orthanc(url='http://localhost:8042')\n\n# The file can be a DICOM file, a zip file containing one or multiple DICOM\nupload(orthanc, 'dicom_filepath.dcm')\n\n# You can also upload a zip file containing one or multiple DICOM\nupload(orthanc, 'dicoms.zip')\n\n# A directory path can be also used. All DICOM files from the directory will be uploaded\nupload(orthanc, 'directory/path')\nupload(orthanc, 'directory/path', recursive=True)  # For nested dicom files\n\n# Note that `upload` returns a list of the uploaded instances `list[pyorthanc.Instance]`\ninstances = upload(orthanc, 'directory/path')\nprint(instances)\n</code></pre>"},{"location":"api/upload/#avoid-uploading-the-same-file-twice","title":"Avoid uploading the same file twice","text":"<p>DICOM files are often big, and uploading them multiple times can be time-consuming. To avoid uploading the same file twice, you can use the <code>check_before_upload</code> option.</p> <p>Note that ZIP files will always be re-uploaded.</p> <pre><code>from pyorthanc import Orthanc, upload\n\northanc = Orthanc(url='http://localhost:8042')\n\n# For each DICOM file, it will check if the file is in Orthanc before uploading it.\nupload(orthanc, 'directory/path', recursive=True, check_before_upload=True)\n</code></pre>"},{"location":"api/upload/#reference","title":"Reference","text":"<p>options: members: true :docstring: :members:</p>"},{"location":"api/upload/#pyorthanc._upload","title":"<code>pyorthanc._upload</code>","text":""},{"location":"api/upload/#pyorthanc._upload.async_upload","title":"<code>async_upload(client, path_or_ds)</code>  <code>async</code>","text":"<p>Upload a DICOM file or dataset to Orthanc asynchronously</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AsyncOrthanc</code> <p>The async Orthanc client to use for upload</p> required <code>path_or_ds</code> <code>Union[str, Path, Dataset]</code> <p>Either a path to a DICOM file, zip file or a pydicom Dataset object</p> required Source code in <code>pyorthanc/_upload.py</code> <pre><code>async def async_upload(client: AsyncOrthanc, path_or_ds: Union[str, Path, pydicom.Dataset]) -&gt; Union[Dict, httpx.Response]:\n    \"\"\"Upload a DICOM file or dataset to Orthanc asynchronously\n\n    Parameters\n    ----------\n    client : AsyncOrthanc\n        The async Orthanc client to use for upload\n    path_or_ds : Union[str, Path, pydicom.Dataset]\n        Either a path to a DICOM file, zip file or a pydicom Dataset object\n    \"\"\"\n    dicom_bytes = _prepare_data_from_ds_or_file(path_or_ds)\n\n    return await client.post_instances(dicom_bytes)\n</code></pre>"},{"location":"api/upload/#pyorthanc._upload.upload","title":"<code>upload(client, path_or_ds, recursive=False, check_before_upload=False)</code>","text":"<p>Upload a DICOM file or dataset to Orthanc synchronously</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Orthanc</code> <p>The Orthanc client to use for upload</p> required <code>path_or_ds</code> <code>Union[str, Path, Dataset]</code> <p>Either a path to a DICOM file, directory, zip file or a pydicom Dataset object</p> required <code>recursive</code> <code>bool</code> <p>When <code>path_or_ds</code> is a directory, whether to upload recursively all the DICOM files in the directory</p> <code>False</code> <code>check_before_upload</code> <code>bool</code> <p>Verify if data is already in Orthanc before sending it. It verifies if a file is stored, there is no file comparison.</p> <code>False</code> Source code in <code>pyorthanc/_upload.py</code> <pre><code>def upload(\n        client: Orthanc,\n        path_or_ds: Union[str, Path, pydicom.Dataset],\n        recursive: bool = False,\n        check_before_upload: bool = False) -&gt; List[Instance]:\n    \"\"\"Upload a DICOM file or dataset to Orthanc synchronously\n\n    Parameters\n    ----------\n    client : Orthanc\n        The Orthanc client to use for upload\n    path_or_ds : Union[str, Path, pydicom.Dataset]\n        Either a path to a DICOM file, directory, zip file or a pydicom Dataset object\n    recursive : bool\n        When `path_or_ds` is a directory, whether to upload recursively all the DICOM files in the directory\n    check_before_upload : bool\n         Verify if data is already in Orthanc before sending it. It verifies if a file is stored, there is no file comparison.\n    \"\"\"\n    client = ensure_non_raw_response(client)\n\n    instances = []\n\n    # If path_or_ds is a directory, upload all the DICOM files in the directory.\n    if (isinstance(path_or_ds, str) or isinstance(path_or_ds, Path)) and os.path.isdir(path_or_ds):\n        for dicom_bytes in _generate_dicom_bytes_from_directory(path_or_ds, recursive=recursive):\n            if check_before_upload:\n                data_is_in_orthanc, instance = _is_data_already_in_orthanc(client, dicom_bytes)\n\n                # If data is already in Orthanc, skip uploading it and go to the next file.\n                if data_is_in_orthanc:\n                    instances.append(instance)\n                    continue\n\n            result = client.post_instances(dicom_bytes)\n            instance = Instance(result['ID'], client)\n            instances.append(instance)\n\n    # If path_or_ds is a DICOM file, zip file or a pydicom Dataset, upload it.\n    else:\n        dicom_bytes = _prepare_data_from_ds_or_file(path_or_ds)\n\n        if check_before_upload:\n            data_in_orthanc, instance = _is_data_already_in_orthanc(client, dicom_bytes)\n            # If data is already in Orthanc, returns the instance directly.\n            if data_in_orthanc:\n                instances.append(instance)\n                return instances\n\n        result = client.post_instances(dicom_bytes)\n\n        # When a zip is uploaded, result can be a list of instances if the zip contained multiple DICOM files.\n        if isinstance(result, list):\n            instances += [Instance(i['ID'], client) for i in result]\n        else:\n            instance = Instance(result['ID'], client)\n            instances.append(instance)\n\n    return instances\n</code></pre>"},{"location":"api/util/","title":"Util","text":""},{"location":"api/util/#pyorthanc.util","title":"<code>pyorthanc.util</code>","text":""},{"location":"api/util/#pyorthanc.util.get_pydicom","title":"<code>get_pydicom(orthanc, instance_identifier)</code>","text":"<p>Get a pydicom.FileDataset from the instance's Orthanc identifier</p> Source code in <code>pyorthanc/util.py</code> <pre><code>def get_pydicom(orthanc: Orthanc, instance_identifier: str) -&gt; pydicom.FileDataset:\n    \"\"\"Get a pydicom.FileDataset from the instance's Orthanc identifier\"\"\"\n    dicom_bytes = orthanc.get_instances_id_file(instance_identifier)\n\n    return pydicom.dcmread(BytesIO(dicom_bytes))\n</code></pre>"},{"location":"api/util/#pyorthanc.util.make_datetime_from_dicom_date","title":"<code>make_datetime_from_dicom_date(date, time=None)</code>","text":"<p>Attempt to decode date</p> Source code in <code>pyorthanc/util.py</code> <pre><code>def make_datetime_from_dicom_date(date: str, time: str = None) -&gt; Optional[datetime]:\n    \"\"\"Attempt to decode date\"\"\"\n    try:\n        return datetime(\n            year=int(date[:4]),\n            month=int(date[4:6]),\n            day=int(date[6:8]),\n            hour=int(time[:2]),\n            minute=int(time[2:4]),\n            second=int(time[4:6])\n        )\n    except (ValueError, TypeError):\n        try:\n            return datetime(\n                year=int(date[:4]),\n                month=int(date[4:6]),\n                day=int(date[6:8]),\n            )\n        except (ValueError, TypeError):\n            return None\n</code></pre>"},{"location":"api/resources/instance/","title":"Instance","text":""},{"location":"api/resources/instance/#pyorthanc.Instance","title":"<code>pyorthanc.Instance</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Represent an instance that is in an Orthanc server</p> <p>This object has many getters that allow the user to retrieve metadata or the entire DICOM file of the Instance</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>class Instance(Resource):\n    \"\"\"Represent an instance that is in an Orthanc server\n\n    This object has many getters that allow the user to retrieve metadata\n    or the entire DICOM file of the Instance\n    \"\"\"\n\n    def get_dicom_file_content(self) -&gt; bytes:\n        \"\"\"Retrieves DICOM file\n\n        This method retrieves bytes corresponding to DICOM file.\n\n        Returns\n        -------\n        bytes\n            Bytes corresponding to DICOM file\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Instance\n        instance = Instance('instance_identifier', Orthanc('http://localhost:8042'))\n\n        dicom_file_bytes = instance.get_dicom_file_content()\n        with open('your_path', 'wb') as file_handler:\n            file_handler.write(dicom_file_bytes)\n        ```\n        \"\"\"\n        return self.client.get_instances_id_file(self.id_)\n\n    def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n        \"\"\"Download the DICOM file to a target path or buffer\n\n        This method is an alternative to the `.get_dicom_file_content()` method for large files.\n        The `.get_dicom_file_content()` method will pull all the data in a single GET call,\n        while `.download()` stream the data to a file or a buffer.\n        Favor the `.download()` method to avoid timeout and memory issues.\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Orthanc, Instance\n        instance = Instance('instance_identifier', Orthanc('http://localhost:8042'))\n\n        # Download the dicom file\n        instance.download('instance.dcm')\n\n        # Download the file and show progress\n        instance.download('instance.dcm', with_progres=True)\n\n        # Or download in a buffer in memory\n        buffer = io.BytesIO()\n        instance.download(buffer)\n        # Now do whatever you want to do\n        buffer.seek(0)\n        dicom_bytes = buffer.read()\n        ```\n        \"\"\"\n        self._download_file(f'{self.client.url}/instances/{self.id_}/file', filepath, with_progres)\n\n    @property\n    def uid(self) -&gt; str:\n        \"\"\"Get SOPInstanceUID\"\"\"\n        return self._get_main_dicom_tag_value('SOPInstanceUID')\n\n    def get_main_information(self) -&gt; Dict:\n        \"\"\"Get instance information\n\n        Returns\n        -------\n        Dict\n            Dictionary with tags as key and information as value\n        \"\"\"\n        return self.client.get_instances_id(self.id_)\n\n    @property\n    def legacy_viewer_url(self) -&gt; str:\n        \"\"\"Get Instance (legacy viewer) URL\n\n        Returns\n        -------\n        str\n            URL of instance (legacy viewer)\n        \"\"\"\n        return f'{self.client.url}/app/explorer.html#instance?uuid={self.id_}'\n\n    @property\n    def file_size(self) -&gt; int:\n        \"\"\"Get the file size\n\n        The output is in bytes. Divide by 1_000_000 to\n        get it in Mb.\n\n        Returns\n        -------\n        int\n            The file size in bytes.\n        \"\"\"\n        return self.get_main_information()['FileSize']\n\n    @property\n    def creation_date(self) -&gt; datetime:\n        \"\"\"Get creation date\n\n        The date have precision to the second.\n\n        Returns\n        -------\n        datetime\n            Creation Date\n        \"\"\"\n        date_string = self._get_main_dicom_tag_value('InstanceCreationDate')\n        time_string = self._get_main_dicom_tag_value('InstanceCreationTime')\n\n        return util.make_datetime_from_dicom_date(date_string, time_string)\n\n    @property\n    def series_identifier(self) -&gt; str:\n        \"\"\"Get the parent series identifier\"\"\"\n        return self.get_main_information()['ParentSeries']\n\n    @property\n    def parent_series(self) -&gt; Series:\n        from . import Series\n        return Series(self.series_identifier, self.client)\n\n    @property\n    def parent_study(self) -&gt; Study:\n        return self.parent_series.parent_study\n\n    @property\n    def parent_patient(self) -&gt; Patient:\n        return self.parent_study.parent_patient\n\n    @property\n    def acquisition_number(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('AcquisitionNumber'))\n\n    @property\n    def image_index(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('ImageIndex'))\n\n    @property\n    def image_orientation_patient(self) -&gt; List[float]:\n        orientation = self._get_main_dicom_tag_value('ImageOrientationPatient')\n\n        return [float(i) for i in orientation.split('\\\\')]\n\n    @property\n    def image_position_patient(self) -&gt; List[float]:\n        position = self._get_main_dicom_tag_value('ImagePositionPatient')\n\n        return [float(i) for i in position.split('\\\\')]\n\n    @property\n    def image_comments(self) -&gt; str:\n        return self._get_main_dicom_tag_value('ImageComments')\n\n    @property\n    def instance_number(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('InstanceNumber'))\n\n    @property\n    def number_of_frames(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('NumberOfFrames'))\n\n    @property\n    def temporal_position_identifier(self) -&gt; str:\n        return self._get_main_dicom_tag_value('TemporalPositionIdentifier')\n\n    @property\n    def first_level_tags(self) -&gt; Any:\n        \"\"\"Get first level tags\"\"\"\n        from warnings import warn\n        warn(\"`Instance.first_level_tags` is deprecated. Use `Instance.tags` instead.\")\n        return self.tags\n\n    @property\n    def tags(self) -&gt; Dict:\n        \"\"\"Get tags\"\"\"\n        return dict(self.client.get_instances_id_tags(self.id_))\n\n    @property\n    def simplified_tags(self) -&gt; Dict:\n        \"\"\"Get simplified tags\"\"\"\n        return dict(self.client.get_instances_id_tags(self.id_, params={'simplify': True}))\n\n    @property\n    def labels(self) -&gt; List[str]:\n        \"\"\"Get instance labels\"\"\"\n        return self.get_main_information()['Labels']\n\n    def add_label(self, label: str) -&gt; None:\n        \"\"\"Add label to resource\"\"\"\n        self.client.put_instances_id_labels_label(self.id_, label)\n\n    def remove_label(self, label):\n        \"\"\"Remove label from resource\"\"\"\n        self.client.delete_instances_id_labels_label(self.id_, label)\n\n    def get_content_by_tag(self, tag: str) -&gt; Any:\n        \"\"\"Get content by tag\n\n        Parameters\n        ----------\n        tag\n            Tag like 'ManufacturerModelName' or '0008-1090' or a group element like '' or '0008-1110/0/0008-1150'.\n\n        Returns\n        -------\n        Any\n            Content corresponding to specified tag.\n        \"\"\"\n        result = self.client.get_instances_id_content_path(id_=self.id_, path=tag)\n\n        try:\n            return result.decode('utf-8').strip().replace('\\x00', '')\n        except AttributeError:\n            return result\n\n    def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n                  keep_private_tags: bool = False, keep_source: bool = True,\n                  private_creator: str = None, force: bool = False, dicom_version: str = None) -&gt; bytes:\n        \"\"\"Anonymize Instance\n\n        If no error has been raise, then it creates a new anonymous instance.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            List of tag to keep unchanged\n        force\n            Some tags can't be changed without forcing it (e.g. SOPInstanceUID) for security reason\n        keep_private_tags\n            If True, keep the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        private_creator\n            The private creator to be used for private tags in replace.\n        dicom_version\n            Version of the DICOM standard to be used for anonymization.\n            Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n        Returns\n        -------\n        bytes\n            Raw bytes of the anonymized instance.\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        data = {\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'KeepPrivateTags': keep_private_tags,\n            'KeepSource': keep_source,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n        if dicom_version is not None:\n            data['DicomVersion'] = dicom_version\n\n        return self.client.post_instances_id_anonymize(self.id_, data)\n\n    def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n               remove_private_tags: bool = False, keep_source: bool = True,\n               private_creator: str = None, force: bool = False) -&gt; bytes:\n        \"\"\"Modify Instance\n\n        If no error has been raise, then it creates a new modified instance.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n            SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n            as this breaks the DICOM model of the real world.\n        force\n            Some tags can't be changed without forcing it (e.g. SOPInstanceUID) for security reason\n        remove_private_tags\n            If True, remove the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        private_creator\n            The private creator to be used for private tags in replace.\n\n        Returns\n        -------\n        bytes\n            Raw bytes of the modified instance.\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        if 'SOPInstanceUID' in replace and not force:\n            raise errors.ModificationError('If SOPInstanceUID is replaced, `force` must be `True`')\n\n        data = {\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'RemovePrivateTags': remove_private_tags,\n            'KeepSource': keep_source,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n\n        return self.client.post_instances_id_modify(self.id_, data)\n\n    def get_pydicom(self) -&gt; pydicom.FileDataset:\n        \"\"\"Retrieve a pydicom.FileDataset object corresponding to the instance.\"\"\"\n        return util.get_pydicom(self.client, self.id_)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.acquisition_number","title":"<code>acquisition_number</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.creation_date","title":"<code>creation_date</code>  <code>property</code>","text":"<p>Get creation date</p> <p>The date have precision to the second.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>Creation Date</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.file_size","title":"<code>file_size</code>  <code>property</code>","text":"<p>Get the file size</p> <p>The output is in bytes. Divide by 1_000_000 to get it in Mb.</p> <p>Returns:</p> Type Description <code>int</code> <p>The file size in bytes.</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.first_level_tags","title":"<code>first_level_tags</code>  <code>property</code>","text":"<p>Get first level tags</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.image_comments","title":"<code>image_comments</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.image_index","title":"<code>image_index</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.image_orientation_patient","title":"<code>image_orientation_patient</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.image_position_patient","title":"<code>image_position_patient</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.instance_number","title":"<code>instance_number</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get instance labels</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.legacy_viewer_url","title":"<code>legacy_viewer_url</code>  <code>property</code>","text":"<p>Get Instance (legacy viewer) URL</p> <p>Returns:</p> Type Description <code>str</code> <p>URL of instance (legacy viewer)</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.number_of_frames","title":"<code>number_of_frames</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.parent_patient","title":"<code>parent_patient</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.parent_series","title":"<code>parent_series</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.parent_study","title":"<code>parent_study</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.series_identifier","title":"<code>series_identifier</code>  <code>property</code>","text":"<p>Get the parent series identifier</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.simplified_tags","title":"<code>simplified_tags</code>  <code>property</code>","text":"<p>Get simplified tags</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.tags","title":"<code>tags</code>  <code>property</code>","text":"<p>Get tags</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.temporal_position_identifier","title":"<code>temporal_position_identifier</code>  <code>property</code>","text":""},{"location":"api/resources/instance/#pyorthanc.Instance.uid","title":"<code>uid</code>  <code>property</code>","text":"<p>Get SOPInstanceUID</p>"},{"location":"api/resources/instance/#pyorthanc.Instance.add_label","title":"<code>add_label(label)</code>","text":"<p>Add label to resource</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def add_label(self, label: str) -&gt; None:\n    \"\"\"Add label to resource\"\"\"\n    self.client.put_instances_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.anonymize","title":"<code>anonymize(remove=None, replace=None, keep=None, keep_private_tags=False, keep_source=True, private_creator=None, force=False, dicom_version=None)</code>","text":"<p>Anonymize Instance</p> <p>If no error has been raise, then it creates a new anonymous instance. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>List of tag to keep unchanged</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. SOPInstanceUID) for security reason</p> <code>False</code> <code>keep_private_tags</code> <code>bool</code> <p>If True, keep the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in replace.</p> <code>None</code> <code>dicom_version</code> <code>str</code> <p>Version of the DICOM standard to be used for anonymization. Check out configuration option DeidentifyLogsDicomVersion for possible values.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Raw bytes of the anonymized instance.</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n              keep_private_tags: bool = False, keep_source: bool = True,\n              private_creator: str = None, force: bool = False, dicom_version: str = None) -&gt; bytes:\n    \"\"\"Anonymize Instance\n\n    If no error has been raise, then it creates a new anonymous instance.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        List of tag to keep unchanged\n    force\n        Some tags can't be changed without forcing it (e.g. SOPInstanceUID) for security reason\n    keep_private_tags\n        If True, keep the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    private_creator\n        The private creator to be used for private tags in replace.\n    dicom_version\n        Version of the DICOM standard to be used for anonymization.\n        Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n    Returns\n    -------\n    bytes\n        Raw bytes of the anonymized instance.\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    data = {\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'KeepPrivateTags': keep_private_tags,\n        'KeepSource': keep_source,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n    if dicom_version is not None:\n        data['DicomVersion'] = dicom_version\n\n    return self.client.post_instances_id_anonymize(self.id_, data)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.download","title":"<code>download(filepath, with_progres=False)</code>","text":"<p>Download the DICOM file to a target path or buffer</p> <p>This method is an alternative to the <code>.get_dicom_file_content()</code> method for large files. The <code>.get_dicom_file_content()</code> method will pull all the data in a single GET call, while <code>.download()</code> stream the data to a file or a buffer. Favor the <code>.download()</code> method to avoid timeout and memory issues.</p> <p>Examples:</p> <pre><code>from pyorthanc import Orthanc, Instance\ninstance = Instance('instance_identifier', Orthanc('http://localhost:8042'))\n\n# Download the dicom file\ninstance.download('instance.dcm')\n\n# Download the file and show progress\ninstance.download('instance.dcm', with_progres=True)\n\n# Or download in a buffer in memory\nbuffer = io.BytesIO()\ninstance.download(buffer)\n# Now do whatever you want to do\nbuffer.seek(0)\ndicom_bytes = buffer.read()\n</code></pre> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n    \"\"\"Download the DICOM file to a target path or buffer\n\n    This method is an alternative to the `.get_dicom_file_content()` method for large files.\n    The `.get_dicom_file_content()` method will pull all the data in a single GET call,\n    while `.download()` stream the data to a file or a buffer.\n    Favor the `.download()` method to avoid timeout and memory issues.\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Orthanc, Instance\n    instance = Instance('instance_identifier', Orthanc('http://localhost:8042'))\n\n    # Download the dicom file\n    instance.download('instance.dcm')\n\n    # Download the file and show progress\n    instance.download('instance.dcm', with_progres=True)\n\n    # Or download in a buffer in memory\n    buffer = io.BytesIO()\n    instance.download(buffer)\n    # Now do whatever you want to do\n    buffer.seek(0)\n    dicom_bytes = buffer.read()\n    ```\n    \"\"\"\n    self._download_file(f'{self.client.url}/instances/{self.id_}/file', filepath, with_progres)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.get_content_by_tag","title":"<code>get_content_by_tag(tag)</code>","text":"<p>Get content by tag</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag like 'ManufacturerModelName' or '0008-1090' or a group element like '' or '0008-1110/0/0008-1150'.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Content corresponding to specified tag.</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def get_content_by_tag(self, tag: str) -&gt; Any:\n    \"\"\"Get content by tag\n\n    Parameters\n    ----------\n    tag\n        Tag like 'ManufacturerModelName' or '0008-1090' or a group element like '' or '0008-1110/0/0008-1150'.\n\n    Returns\n    -------\n    Any\n        Content corresponding to specified tag.\n    \"\"\"\n    result = self.client.get_instances_id_content_path(id_=self.id_, path=tag)\n\n    try:\n        return result.decode('utf-8').strip().replace('\\x00', '')\n    except AttributeError:\n        return result\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.get_dicom_file_content","title":"<code>get_dicom_file_content()</code>","text":"<p>Retrieves DICOM file</p> <p>This method retrieves bytes corresponding to DICOM file.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes corresponding to DICOM file</p> <p>Examples:</p> <pre><code>from pyorthanc import Instance\ninstance = Instance('instance_identifier', Orthanc('http://localhost:8042'))\n\ndicom_file_bytes = instance.get_dicom_file_content()\nwith open('your_path', 'wb') as file_handler:\n    file_handler.write(dicom_file_bytes)\n</code></pre> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def get_dicom_file_content(self) -&gt; bytes:\n    \"\"\"Retrieves DICOM file\n\n    This method retrieves bytes corresponding to DICOM file.\n\n    Returns\n    -------\n    bytes\n        Bytes corresponding to DICOM file\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Instance\n    instance = Instance('instance_identifier', Orthanc('http://localhost:8042'))\n\n    dicom_file_bytes = instance.get_dicom_file_content()\n    with open('your_path', 'wb') as file_handler:\n        file_handler.write(dicom_file_bytes)\n    ```\n    \"\"\"\n    return self.client.get_instances_id_file(self.id_)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.get_main_information","title":"<code>get_main_information()</code>","text":"<p>Get instance information</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with tags as key and information as value</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def get_main_information(self) -&gt; Dict:\n    \"\"\"Get instance information\n\n    Returns\n    -------\n    Dict\n        Dictionary with tags as key and information as value\n    \"\"\"\n    return self.client.get_instances_id(self.id_)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.get_pydicom","title":"<code>get_pydicom()</code>","text":"<p>Retrieve a pydicom.FileDataset object corresponding to the instance.</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def get_pydicom(self) -&gt; pydicom.FileDataset:\n    \"\"\"Retrieve a pydicom.FileDataset object corresponding to the instance.\"\"\"\n    return util.get_pydicom(self.client, self.id_)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.modify","title":"<code>modify(remove=None, replace=None, keep=None, remove_private_tags=False, keep_source=True, private_creator=None, force=False)</code>","text":"<p>Modify Instance</p> <p>If no error has been raise, then it creates a new modified instance. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>Keep the original value of the specified tags, to be chosen among the StudyInstanceUID, SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. SOPInstanceUID) for security reason</p> <code>False</code> <code>remove_private_tags</code> <code>bool</code> <p>If True, remove the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in replace.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Raw bytes of the modified instance.</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n           remove_private_tags: bool = False, keep_source: bool = True,\n           private_creator: str = None, force: bool = False) -&gt; bytes:\n    \"\"\"Modify Instance\n\n    If no error has been raise, then it creates a new modified instance.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n        SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n        as this breaks the DICOM model of the real world.\n    force\n        Some tags can't be changed without forcing it (e.g. SOPInstanceUID) for security reason\n    remove_private_tags\n        If True, remove the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    private_creator\n        The private creator to be used for private tags in replace.\n\n    Returns\n    -------\n    bytes\n        Raw bytes of the modified instance.\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    if 'SOPInstanceUID' in replace and not force:\n        raise errors.ModificationError('If SOPInstanceUID is replaced, `force` must be `True`')\n\n    data = {\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'RemovePrivateTags': remove_private_tags,\n        'KeepSource': keep_source,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n\n    return self.client.post_instances_id_modify(self.id_, data)\n</code></pre>"},{"location":"api/resources/instance/#pyorthanc.Instance.remove_label","title":"<code>remove_label(label)</code>","text":"<p>Remove label from resource</p> Source code in <code>pyorthanc/_resources/instance.py</code> <pre><code>def remove_label(self, label):\n    \"\"\"Remove label from resource\"\"\"\n    self.client.delete_instances_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"api/resources/patient/","title":"Patient","text":""},{"location":"api/resources/patient/#pyorthanc.Patient","title":"<code>pyorthanc.Patient</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Represent a Patient that is in an Orthanc server</p> <p>This object has many getters that allow the user to retrieve metadata or the entire DICOM file of the Patient</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>class Patient(Resource):\n    \"\"\"Represent a Patient that is in an Orthanc server\n\n    This object has many getters that allow the user to retrieve metadata\n    or the entire DICOM file of the Patient\n    \"\"\"\n\n    def get_main_information(self) -&gt; Dict:\n        \"\"\"Get Patient information\n\n        Returns\n        -------\n        Dict\n            Dictionary of patient main information.\n        \"\"\"\n        return self.client.get_patients_id(self.id_)\n\n    @property\n    def legacy_viewer_url(self) -&gt; str:\n        \"\"\"Get Patient (legacy viewer) URL\n\n        Returns\n        -------\n        str\n            URL of patient (legacy viewer)\n        \"\"\"\n        return f'{self.client.url}/app/explorer.html#patient?uuid={self.id_}'\n\n    @property\n    def patient_id(self) -&gt; str:\n        \"\"\"Get patient ID\"\"\"\n        return self._get_main_dicom_tag_value('PatientID')\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get patient name\"\"\"\n        return self._get_main_dicom_tag_value('PatientName')\n\n    @property\n    def birth_date(self) -&gt; datetime:\n        \"\"\"Get patient birthdate\"\"\"\n        date = self._get_main_dicom_tag_value('PatientBirthDate')\n\n        return util.make_datetime_from_dicom_date(date)\n\n    @property\n    def sex(self) -&gt; str:\n        \"\"\"Get patient sex\"\"\"\n        return self._get_main_dicom_tag_value('PatientSex')\n\n    @property\n    def other_patient_ids(self) -&gt; str:\n        return self._get_main_dicom_tag_value('OtherPatientIDs').split('\\\\')\n\n    @property\n    def is_stable(self):\n        return self.get_main_information()['IsStable']\n\n    @property\n    def last_update(self) -&gt; datetime:\n        last_updated_date_and_time = self.get_main_information()['LastUpdate'].split('T')\n        date = last_updated_date_and_time[0]\n        time = last_updated_date_and_time[1]\n\n        return util.make_datetime_from_dicom_date(date, time)\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return self.get_main_information()['Labels']\n\n    def add_label(self, label: str) -&gt; None:\n        self.client.put_patients_id_labels_label(self.id_, label)\n\n    def remove_label(self, label):\n        self.client.delete_patients_id_labels_label(self.id_, label)\n\n    def get_zip(self) -&gt; bytes:\n        \"\"\"Get the bytes of the zip file\n\n        Get the .zip file.\n\n        Returns\n        -------\n        bytes\n            Bytes of Zip file of the patient.\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Orthanc, Patient\n        a_patient = Patient(\n            'A_PATIENT_IDENTIFIER',\n            Orthanc('http://localhost:8042')\n        )\n        bytes_content = a_patient.get_zip()\n        with open('patient_zip_file_path.zip', 'wb') as file_handler:\n            file_handler.write(bytes_content)\n        ```\n        \"\"\"\n        return self.client.get_patients_id_archive(self.id_)\n\n    def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n        \"\"\"Download the zip file to a target path or buffer\n\n        This method is an alternative to the `.get_zip()` method for large files.\n        The `.get_zip()` method will pull all the data in a single GET call,\n        while `.download()` stream the data to a file or a buffer.\n        Favor the `.download()` method to avoid timeout and memory issues.\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Orthanc, Patient\n        a_patient = Patient('A_PATIENT_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n        # Download a zip\n        a_patient.download('patient.zip')\n\n        # Download a zip and show progress\n        a_patient.download('patient.zip', with_progres=True)\n\n        # Or download in a buffer in memory\n        buffer = io.BytesIO()\n        a_patient.download(buffer)\n        # Now do whatever you want to do\n        buffer.seek(0)\n        zip_bytes = buffer.read()\n        ```\n        \"\"\"\n        self._download_file(f'{self.client.url}/patients/{self.id_}/archive', filepath, with_progres)\n\n    def get_patient_module(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n        \"\"\"Get patient module in a simplified version\n\n        The method returns the DICOM patient module\n        (PatientName, PatientID, PatientBirthDate, ...)\n\n        Parameters\n        ----------\n        simplify\n            Get the simplified version of the tags\n        short\n            Get the short version of the tags\n\n        Returns\n        -------\n        Dict\n            DICOM Patient module.\n        \"\"\"\n        params = self._make_response_format_params(simplify, short)\n\n        return dict(self.client.get_patients_id_module(\n            self.id_,\n            params=params\n        ))\n\n    @property\n    def protected(self) -&gt; bool:\n        \"\"\"Get if patient is protected against recycling\n\n        Protection against recycling: False means unprotected, True protected.\n\n        Returns\n        -------\n        bool\n            False means unprotected, True means protected.\n        \"\"\"\n        return '1' == self.client.get_patients_id_protected(self.id_)\n\n    @protected.setter\n    def protected(self, value: bool):\n        # As of version 1.11.1, the Orthanc OPEN API file has missing information\n        self.client._put(\n            f'{self.client.url}/patients/{self.id_}/protected',\n            json=1 if value else 0  # 1 means it will be protected, 0 means unprotected\n        )\n\n    def is_protected(self) -&gt; bool:\n        \"\"\"Get if patient is protected against recycling\n\n        Protection against recycling: False means unprotected, True protected.\n\n        Returns\n        -------\n        bool\n            False means unprotected, True means protected.\n        \"\"\"\n        DeprecationWarning(\n            '`patient.is_protected()` is deprecated and will be removed in future release. '\n            'Use `patient.protected` instead.'\n        )\n        return self.protected\n\n    def set_to_protected(self):\n        \"\"\"Set patient to protected state\n\n        Returns\n        -------\n        None\n            Nothing.\n        \"\"\"\n        # As of version 1.11.1, the Orthanc OPEN API file has missing information\n        warnings.warn(\n            '`patient.set_to_protected()` is deprecated and will be removed in future release. '\n            'Use `patient.protected = True` instead.',\n            DeprecationWarning\n        )\n        self.protected = True\n\n    def set_to_unprotected(self):\n        \"\"\"Set patient to unprotected state\n\n        Returns\n        -------\n        None\n            Nothing.\n        \"\"\"\n        # As of version 1.11.1, the Orthanc OPEN API file has missing information\n        warnings.warn(\n            '`patient.set_to_protected()` is deprecated and will be removed in future release. '\n            'Use `patient.protected = True` instead.',\n            DeprecationWarning\n        )\n        self.protected = False\n\n    @property\n    def studies(self) -&gt; List[Study]:\n        \"\"\"Get patient's studies\n\n        Returns\n        -------\n        List[Study]\n            List of the patient's studies\n        \"\"\"\n        if self._lock_children:\n            if self._child_resources is None:\n                studies_ids = self.get_main_information()['Studies']\n                self._child_resources = [Study(i, self.client, self._lock_children) for i in studies_ids]\n\n            return self._child_resources\n\n        studies_ids = self.get_main_information()['Studies']\n\n        return [Study(i, self.client) for i in studies_ids]\n\n    def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n                  force: bool = False, keep_private_tags: bool = False,\n                  keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                  private_creator: str = None, dicom_version: str = None) -&gt; 'Patient':\n        \"\"\"Anonymize patient\n\n        If no error has been raise, then it creates a new anonymous patient.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method might be long to run, especially on large patient or when multiple\n        patients are anonymized. In those cases, it is recommended to use the `.anonymize_as_job()`\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            List of tag to keep unchanged\n        force\n            Some tags can't be changed without forcing it (e.g. PatientID) for security reason\n        keep_private_tags\n            If True, keep the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n        dicom_version\n            Version of the DICOM standard to be used for anonymization.\n            Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n        Returns\n        -------\n        Patient\n            A New anonymous patient.\n\n        Examples\n        --------\n        ```python\n        new_patient = patient.anonymize()\n\n        new_patient_with_specific_patient_id = patient.anonymize(\n            keep=['PatientName'],\n            replace={'PatientID': 'TheNewPatientID'},\n            force=True\n        )\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        data = {\n            'Asynchronous': False,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'KeepPrivateTags': keep_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n        if dicom_version is not None:\n            data['DicomVersion'] = dicom_version\n\n        try:\n            anonymous_patient = self.client.post_patients_id_anonymize(self.id_, data)\n        except ReadTimeout:\n            raise ReadTimeout(\n                'Patient anonymization is too long to process. '\n                'Use `.anonymize_as_job` or increase client.timeout.'\n            )\n\n        return Patient(anonymous_patient['ID'], self.client)\n\n    def anonymize_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                         force: bool = False, keep_private_tags: bool = False,\n                         keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                         private_creator: str = None, dicom_version: str = None) -&gt; Job:\n        \"\"\"Anonymize patient and return a job\n\n        Launch an anonymization job.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method is useful when anonymizing large patient or launching many\n        anonymization jobs. The jobs are sent to Orthanc and processed according\n        to the priority.\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            List of tag to keep unchanged\n        force\n            Some tags can't be changed without forcing it (e.g. PatientID) for security reason\n        keep_private_tags\n            If True, keep the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n        dicom_version\n            Version of the DICOM standard to be used for anonymization.\n            Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n        Returns\n        -------\n        Job\n            Return a Job object of the anonymization job.\n\n        Examples\n        --------\n        For large patient (recommended)\n        ```python\n        job = patient.anonymize_as_job()\n        job.state  # You can follow the job state\n\n        job.wait_until_completion() # Or just wait on its completion\n        new_patient = Patient(job.content['ID'], orthanc)\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        data = {\n            'Asynchronous': True,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'KeepPrivateTags': keep_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n        if dicom_version is not None:\n            data['DicomVersion'] = dicom_version\n\n        job_info = self.client.post_patients_id_anonymize(self.id_, data)\n\n        return Job(job_info['ID'], self.client)\n\n    def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n               force: bool = False, remove_private_tags: bool = False,\n               keep_source: bool = True, priority: int = 0, permissive: bool = False,\n               private_creator: str = None) -&gt; 'Patient':\n        \"\"\"Modify patient\n\n        If no error has been raise, then modify the patient. If the PatientID is replaced\n        (with `force=True`), then return a new patient.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method might be long to run, especially on large patient or when multiple\n        patients are modified. In those cases, it is recommended to use the `.modify_as_job()`\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n            SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n            as this breaks the DICOM model of the real world.\n        force\n            Some tags can't be changed without forcing it (e.g. PatientID) for security reason\n        remove_private_tags\n            If True, remove the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n\n        Returns\n        -------\n        Patient\n            Returns a new patient if the \"PatientID\" tag has been replaced,\n            returns itself if not (in this case, the patient itself is modified).\n\n        Examples\n        --------\n        ```python\n        patient.modify(remove=['PatientName'])\n        patient.name  # will raise\n\n        modified_patient = patient.modify(replace={'PatientID': 'TheNewPatientID'}, force=True)\n        assert modified_patient.patient_id == 'TheNewPatientID'\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        if 'PatientID' in replace and not force:\n            raise errors.ModificationError('If PatientID is replaced, `force` must be `True`')\n\n        data = {\n            'Asynchronous': False,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'RemovePrivateTags': remove_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n\n        try:\n            modified_patient = self.client.post_patients_id_modify(self.id_, data)\n        except ReadTimeout:\n            raise ReadTimeout(\n                'Patient modification is too long to process. '\n                'Use `.modify_as_job` or increase client.timeout.'\n            )\n\n        # Reset cache since a main DICOM tag may have be changed\n        self._main_dicom_tags = None\n\n        # if 'PatientID' is not affected, the modified_patient['ID'] is the same as self.id_\n        return Patient(modified_patient['ID'], self.client)\n\n    def modify_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                      force: bool = False, remove_private_tags: bool = False,\n                      keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                      private_creator: str = None) -&gt; Job:\n        \"\"\"Modify patient and return a job\n\n        Launch a modification job. If the PatientID is replaced (with `force=True`),\n        then return a new patient. If the PatientID is not replaced, the patient itself is modified.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method is useful when modifying large patient or launching many\n        modification jobs. The jobs are sent to Orthanc and processed according\n        to the priority.\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n            SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n            as this breaks the DICOM model of the real world.\n        force\n            Allow the modification of tags related to DICOM identifiers, at the risk of breaking\n            the DICOM model of the real world.\n        remove_private_tags\n            If True, remove the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n\n        Returns\n        -------\n        Job\n            Return a Job object of the anonymization job.\n\n        Examples\n        --------\n        For large patient (recommended)\n        ```python\n        job = patient.modify_as_job(replace={'PatientName': 'NewName'})\n        job.state  # You can follow the job state\n\n        job.wait_until_completion() # Or just wait on its completion\n        assert patient.name == 'NewName'\n        ```\n        Or modify the PatientID\n        ```python\n        job = patient.modify_as_job(replace={'PatientID': 'new-id'}, force=True)\n        job.wait_until_completion() # Or just wait on its completion\n\n        modified_patient = Patient(job.content['ID'], client)\n        assert patient.patient_id != 'new_id'\n        assert modified_patient.patient_id == 'new_id'\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        if 'PatientID' in replace and not force:\n            raise errors.ModificationError('If PatientID is affected, `force` must be `True`')\n\n        data = {\n            'Asynchronous': True,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'RemovePrivateTags': remove_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n\n        job_info = self.client.post_patients_id_modify(self.id_, data)\n\n        # Reset cache since a main DICOM tag may have be changed\n        self._main_dicom_tags = None\n\n        return Job(job_info['ID'], self.client)\n\n    def get_shared_tags(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n        \"\"\"Retrieve the shared tags of the patient\"\"\"\n        params = self._make_response_format_params(simplify, short)\n\n        return dict(self.client.get_patients_id_shared_tags(\n            self.id_,\n            params=params\n        ))\n\n    @property\n    def shared_tags(self) -&gt; Dict:\n        return self.get_shared_tags(simplify=True)\n\n    def remove_empty_studies(self) -&gt; None:\n        \"\"\"Delete empty studies.\"\"\"\n        if self._child_resources is None:\n            return\n\n        for study in self._child_resources:\n            study.remove_empty_series()\n\n        self._child_resources = [study for study in self._child_resources if study._child_resources != []]\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.birth_date","title":"<code>birth_date</code>  <code>property</code>","text":"<p>Get patient birthdate</p>"},{"location":"api/resources/patient/#pyorthanc.Patient.is_stable","title":"<code>is_stable</code>  <code>property</code>","text":""},{"location":"api/resources/patient/#pyorthanc.Patient.labels","title":"<code>labels</code>  <code>property</code>","text":""},{"location":"api/resources/patient/#pyorthanc.Patient.last_update","title":"<code>last_update</code>  <code>property</code>","text":""},{"location":"api/resources/patient/#pyorthanc.Patient.legacy_viewer_url","title":"<code>legacy_viewer_url</code>  <code>property</code>","text":"<p>Get Patient (legacy viewer) URL</p> <p>Returns:</p> Type Description <code>str</code> <p>URL of patient (legacy viewer)</p>"},{"location":"api/resources/patient/#pyorthanc.Patient.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get patient name</p>"},{"location":"api/resources/patient/#pyorthanc.Patient.other_patient_ids","title":"<code>other_patient_ids</code>  <code>property</code>","text":""},{"location":"api/resources/patient/#pyorthanc.Patient.patient_id","title":"<code>patient_id</code>  <code>property</code>","text":"<p>Get patient ID</p>"},{"location":"api/resources/patient/#pyorthanc.Patient.protected","title":"<code>protected</code>  <code>property</code> <code>writable</code>","text":"<p>Get if patient is protected against recycling</p> <p>Protection against recycling: False means unprotected, True protected.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False means unprotected, True means protected.</p>"},{"location":"api/resources/patient/#pyorthanc.Patient.sex","title":"<code>sex</code>  <code>property</code>","text":"<p>Get patient sex</p>"},{"location":"api/resources/patient/#pyorthanc.Patient.shared_tags","title":"<code>shared_tags</code>  <code>property</code>","text":""},{"location":"api/resources/patient/#pyorthanc.Patient.studies","title":"<code>studies</code>  <code>property</code>","text":"<p>Get patient's studies</p> <p>Returns:</p> Type Description <code>List[Study]</code> <p>List of the patient's studies</p>"},{"location":"api/resources/patient/#pyorthanc.Patient.add_label","title":"<code>add_label(label)</code>","text":"Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def add_label(self, label: str) -&gt; None:\n    self.client.put_patients_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.anonymize","title":"<code>anonymize(remove=None, replace=None, keep=None, force=False, keep_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None, dicom_version=None)</code>","text":"<p>Anonymize patient</p> <p>If no error has been raise, then it creates a new anonymous patient. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method might be long to run, especially on large patient or when multiple patients are anonymized. In those cases, it is recommended to use the <code>.anonymize_as_job()</code></p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>List of tag to keep unchanged</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. PatientID) for security reason</p> <code>False</code> <code>keep_private_tags</code> <code>bool</code> <p>If True, keep the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <code>dicom_version</code> <code>str</code> <p>Version of the DICOM standard to be used for anonymization. Check out configuration option DeidentifyLogsDicomVersion for possible values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Patient</code> <p>A New anonymous patient.</p> <p>Examples:</p> <pre><code>new_patient = patient.anonymize()\n\nnew_patient_with_specific_patient_id = patient.anonymize(\n    keep=['PatientName'],\n    replace={'PatientID': 'TheNewPatientID'},\n    force=True\n)\n</code></pre> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n              force: bool = False, keep_private_tags: bool = False,\n              keep_source: bool = True, priority: int = 0, permissive: bool = False,\n              private_creator: str = None, dicom_version: str = None) -&gt; 'Patient':\n    \"\"\"Anonymize patient\n\n    If no error has been raise, then it creates a new anonymous patient.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method might be long to run, especially on large patient or when multiple\n    patients are anonymized. In those cases, it is recommended to use the `.anonymize_as_job()`\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        List of tag to keep unchanged\n    force\n        Some tags can't be changed without forcing it (e.g. PatientID) for security reason\n    keep_private_tags\n        If True, keep the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n    dicom_version\n        Version of the DICOM standard to be used for anonymization.\n        Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n    Returns\n    -------\n    Patient\n        A New anonymous patient.\n\n    Examples\n    --------\n    ```python\n    new_patient = patient.anonymize()\n\n    new_patient_with_specific_patient_id = patient.anonymize(\n        keep=['PatientName'],\n        replace={'PatientID': 'TheNewPatientID'},\n        force=True\n    )\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    data = {\n        'Asynchronous': False,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'KeepPrivateTags': keep_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n    if dicom_version is not None:\n        data['DicomVersion'] = dicom_version\n\n    try:\n        anonymous_patient = self.client.post_patients_id_anonymize(self.id_, data)\n    except ReadTimeout:\n        raise ReadTimeout(\n            'Patient anonymization is too long to process. '\n            'Use `.anonymize_as_job` or increase client.timeout.'\n        )\n\n    return Patient(anonymous_patient['ID'], self.client)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.anonymize_as_job","title":"<code>anonymize_as_job(remove=None, replace=None, keep=None, force=False, keep_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None, dicom_version=None)</code>","text":"<p>Anonymize patient and return a job</p> <p>Launch an anonymization job. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method is useful when anonymizing large patient or launching many anonymization jobs. The jobs are sent to Orthanc and processed according to the priority.</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>List of tag to keep unchanged</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. PatientID) for security reason</p> <code>False</code> <code>keep_private_tags</code> <code>bool</code> <p>If True, keep the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <code>dicom_version</code> <code>str</code> <p>Version of the DICOM standard to be used for anonymization. Check out configuration option DeidentifyLogsDicomVersion for possible values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Job</code> <p>Return a Job object of the anonymization job.</p> <p>Examples:</p> <p>For large patient (recommended)</p> <pre><code>job = patient.anonymize_as_job()\njob.state  # You can follow the job state\n\njob.wait_until_completion() # Or just wait on its completion\nnew_patient = Patient(job.content['ID'], orthanc)\n</code></pre> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def anonymize_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                     force: bool = False, keep_private_tags: bool = False,\n                     keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                     private_creator: str = None, dicom_version: str = None) -&gt; Job:\n    \"\"\"Anonymize patient and return a job\n\n    Launch an anonymization job.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method is useful when anonymizing large patient or launching many\n    anonymization jobs. The jobs are sent to Orthanc and processed according\n    to the priority.\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        List of tag to keep unchanged\n    force\n        Some tags can't be changed without forcing it (e.g. PatientID) for security reason\n    keep_private_tags\n        If True, keep the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n    dicom_version\n        Version of the DICOM standard to be used for anonymization.\n        Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n    Returns\n    -------\n    Job\n        Return a Job object of the anonymization job.\n\n    Examples\n    --------\n    For large patient (recommended)\n    ```python\n    job = patient.anonymize_as_job()\n    job.state  # You can follow the job state\n\n    job.wait_until_completion() # Or just wait on its completion\n    new_patient = Patient(job.content['ID'], orthanc)\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    data = {\n        'Asynchronous': True,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'KeepPrivateTags': keep_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n    if dicom_version is not None:\n        data['DicomVersion'] = dicom_version\n\n    job_info = self.client.post_patients_id_anonymize(self.id_, data)\n\n    return Job(job_info['ID'], self.client)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.download","title":"<code>download(filepath, with_progres=False)</code>","text":"<p>Download the zip file to a target path or buffer</p> <p>This method is an alternative to the <code>.get_zip()</code> method for large files. The <code>.get_zip()</code> method will pull all the data in a single GET call, while <code>.download()</code> stream the data to a file or a buffer. Favor the <code>.download()</code> method to avoid timeout and memory issues.</p> <p>Examples:</p> <pre><code>from pyorthanc import Orthanc, Patient\na_patient = Patient('A_PATIENT_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n# Download a zip\na_patient.download('patient.zip')\n\n# Download a zip and show progress\na_patient.download('patient.zip', with_progres=True)\n\n# Or download in a buffer in memory\nbuffer = io.BytesIO()\na_patient.download(buffer)\n# Now do whatever you want to do\nbuffer.seek(0)\nzip_bytes = buffer.read()\n</code></pre> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n    \"\"\"Download the zip file to a target path or buffer\n\n    This method is an alternative to the `.get_zip()` method for large files.\n    The `.get_zip()` method will pull all the data in a single GET call,\n    while `.download()` stream the data to a file or a buffer.\n    Favor the `.download()` method to avoid timeout and memory issues.\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Orthanc, Patient\n    a_patient = Patient('A_PATIENT_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n    # Download a zip\n    a_patient.download('patient.zip')\n\n    # Download a zip and show progress\n    a_patient.download('patient.zip', with_progres=True)\n\n    # Or download in a buffer in memory\n    buffer = io.BytesIO()\n    a_patient.download(buffer)\n    # Now do whatever you want to do\n    buffer.seek(0)\n    zip_bytes = buffer.read()\n    ```\n    \"\"\"\n    self._download_file(f'{self.client.url}/patients/{self.id_}/archive', filepath, with_progres)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.get_main_information","title":"<code>get_main_information()</code>","text":"<p>Get Patient information</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary of patient main information.</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def get_main_information(self) -&gt; Dict:\n    \"\"\"Get Patient information\n\n    Returns\n    -------\n    Dict\n        Dictionary of patient main information.\n    \"\"\"\n    return self.client.get_patients_id(self.id_)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.get_patient_module","title":"<code>get_patient_module(simplify=False, short=False)</code>","text":"<p>Get patient module in a simplified version</p> <p>The method returns the DICOM patient module (PatientName, PatientID, PatientBirthDate, ...)</p> <p>Parameters:</p> Name Type Description Default <code>simplify</code> <code>bool</code> <p>Get the simplified version of the tags</p> <code>False</code> <code>short</code> <code>bool</code> <p>Get the short version of the tags</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>DICOM Patient module.</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def get_patient_module(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n    \"\"\"Get patient module in a simplified version\n\n    The method returns the DICOM patient module\n    (PatientName, PatientID, PatientBirthDate, ...)\n\n    Parameters\n    ----------\n    simplify\n        Get the simplified version of the tags\n    short\n        Get the short version of the tags\n\n    Returns\n    -------\n    Dict\n        DICOM Patient module.\n    \"\"\"\n    params = self._make_response_format_params(simplify, short)\n\n    return dict(self.client.get_patients_id_module(\n        self.id_,\n        params=params\n    ))\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.get_shared_tags","title":"<code>get_shared_tags(simplify=False, short=False)</code>","text":"<p>Retrieve the shared tags of the patient</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def get_shared_tags(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n    \"\"\"Retrieve the shared tags of the patient\"\"\"\n    params = self._make_response_format_params(simplify, short)\n\n    return dict(self.client.get_patients_id_shared_tags(\n        self.id_,\n        params=params\n    ))\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.get_zip","title":"<code>get_zip()</code>","text":"<p>Get the bytes of the zip file</p> <p>Get the .zip file.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes of Zip file of the patient.</p> <p>Examples:</p> <pre><code>from pyorthanc import Orthanc, Patient\na_patient = Patient(\n    'A_PATIENT_IDENTIFIER',\n    Orthanc('http://localhost:8042')\n)\nbytes_content = a_patient.get_zip()\nwith open('patient_zip_file_path.zip', 'wb') as file_handler:\n    file_handler.write(bytes_content)\n</code></pre> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def get_zip(self) -&gt; bytes:\n    \"\"\"Get the bytes of the zip file\n\n    Get the .zip file.\n\n    Returns\n    -------\n    bytes\n        Bytes of Zip file of the patient.\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Orthanc, Patient\n    a_patient = Patient(\n        'A_PATIENT_IDENTIFIER',\n        Orthanc('http://localhost:8042')\n    )\n    bytes_content = a_patient.get_zip()\n    with open('patient_zip_file_path.zip', 'wb') as file_handler:\n        file_handler.write(bytes_content)\n    ```\n    \"\"\"\n    return self.client.get_patients_id_archive(self.id_)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.is_protected","title":"<code>is_protected()</code>","text":"<p>Get if patient is protected against recycling</p> <p>Protection against recycling: False means unprotected, True protected.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False means unprotected, True means protected.</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def is_protected(self) -&gt; bool:\n    \"\"\"Get if patient is protected against recycling\n\n    Protection against recycling: False means unprotected, True protected.\n\n    Returns\n    -------\n    bool\n        False means unprotected, True means protected.\n    \"\"\"\n    DeprecationWarning(\n        '`patient.is_protected()` is deprecated and will be removed in future release. '\n        'Use `patient.protected` instead.'\n    )\n    return self.protected\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.modify","title":"<code>modify(remove=None, replace=None, keep=None, force=False, remove_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None)</code>","text":"<p>Modify patient</p> <p>If no error has been raise, then modify the patient. If the PatientID is replaced (with <code>force=True</code>), then return a new patient. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method might be long to run, especially on large patient or when multiple patients are modified. In those cases, it is recommended to use the <code>.modify_as_job()</code></p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>Keep the original value of the specified tags, to be chosen among the StudyInstanceUID, SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. PatientID) for security reason</p> <code>False</code> <code>remove_private_tags</code> <code>bool</code> <p>If True, remove the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <p>Returns:</p> Type Description <code>Patient</code> <p>Returns a new patient if the \"PatientID\" tag has been replaced, returns itself if not (in this case, the patient itself is modified).</p> <p>Examples:</p> <pre><code>patient.modify(remove=['PatientName'])\npatient.name  # will raise\n\nmodified_patient = patient.modify(replace={'PatientID': 'TheNewPatientID'}, force=True)\nassert modified_patient.patient_id == 'TheNewPatientID'\n</code></pre> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n           force: bool = False, remove_private_tags: bool = False,\n           keep_source: bool = True, priority: int = 0, permissive: bool = False,\n           private_creator: str = None) -&gt; 'Patient':\n    \"\"\"Modify patient\n\n    If no error has been raise, then modify the patient. If the PatientID is replaced\n    (with `force=True`), then return a new patient.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method might be long to run, especially on large patient or when multiple\n    patients are modified. In those cases, it is recommended to use the `.modify_as_job()`\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n        SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n        as this breaks the DICOM model of the real world.\n    force\n        Some tags can't be changed without forcing it (e.g. PatientID) for security reason\n    remove_private_tags\n        If True, remove the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n\n    Returns\n    -------\n    Patient\n        Returns a new patient if the \"PatientID\" tag has been replaced,\n        returns itself if not (in this case, the patient itself is modified).\n\n    Examples\n    --------\n    ```python\n    patient.modify(remove=['PatientName'])\n    patient.name  # will raise\n\n    modified_patient = patient.modify(replace={'PatientID': 'TheNewPatientID'}, force=True)\n    assert modified_patient.patient_id == 'TheNewPatientID'\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    if 'PatientID' in replace and not force:\n        raise errors.ModificationError('If PatientID is replaced, `force` must be `True`')\n\n    data = {\n        'Asynchronous': False,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'RemovePrivateTags': remove_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n\n    try:\n        modified_patient = self.client.post_patients_id_modify(self.id_, data)\n    except ReadTimeout:\n        raise ReadTimeout(\n            'Patient modification is too long to process. '\n            'Use `.modify_as_job` or increase client.timeout.'\n        )\n\n    # Reset cache since a main DICOM tag may have be changed\n    self._main_dicom_tags = None\n\n    # if 'PatientID' is not affected, the modified_patient['ID'] is the same as self.id_\n    return Patient(modified_patient['ID'], self.client)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.modify_as_job","title":"<code>modify_as_job(remove=None, replace=None, keep=None, force=False, remove_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None)</code>","text":"<p>Modify patient and return a job</p> <p>Launch a modification job. If the PatientID is replaced (with <code>force=True</code>), then return a new patient. If the PatientID is not replaced, the patient itself is modified. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method is useful when modifying large patient or launching many modification jobs. The jobs are sent to Orthanc and processed according to the priority.</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>Keep the original value of the specified tags, to be chosen among the StudyInstanceUID, SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world.</p> <code>False</code> <code>remove_private_tags</code> <code>bool</code> <p>If True, remove the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <p>Returns:</p> Type Description <code>Job</code> <p>Return a Job object of the anonymization job.</p> <p>Examples:</p> <p>For large patient (recommended)</p> <pre><code>job = patient.modify_as_job(replace={'PatientName': 'NewName'})\njob.state  # You can follow the job state\n\njob.wait_until_completion() # Or just wait on its completion\nassert patient.name == 'NewName'\n</code></pre> <p>Or modify the PatientID</p> <pre><code>job = patient.modify_as_job(replace={'PatientID': 'new-id'}, force=True)\njob.wait_until_completion() # Or just wait on its completion\n\nmodified_patient = Patient(job.content['ID'], client)\nassert patient.patient_id != 'new_id'\nassert modified_patient.patient_id == 'new_id'\n</code></pre> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def modify_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                  force: bool = False, remove_private_tags: bool = False,\n                  keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                  private_creator: str = None) -&gt; Job:\n    \"\"\"Modify patient and return a job\n\n    Launch a modification job. If the PatientID is replaced (with `force=True`),\n    then return a new patient. If the PatientID is not replaced, the patient itself is modified.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method is useful when modifying large patient or launching many\n    modification jobs. The jobs are sent to Orthanc and processed according\n    to the priority.\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n        SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n        as this breaks the DICOM model of the real world.\n    force\n        Allow the modification of tags related to DICOM identifiers, at the risk of breaking\n        the DICOM model of the real world.\n    remove_private_tags\n        If True, remove the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n\n    Returns\n    -------\n    Job\n        Return a Job object of the anonymization job.\n\n    Examples\n    --------\n    For large patient (recommended)\n    ```python\n    job = patient.modify_as_job(replace={'PatientName': 'NewName'})\n    job.state  # You can follow the job state\n\n    job.wait_until_completion() # Or just wait on its completion\n    assert patient.name == 'NewName'\n    ```\n    Or modify the PatientID\n    ```python\n    job = patient.modify_as_job(replace={'PatientID': 'new-id'}, force=True)\n    job.wait_until_completion() # Or just wait on its completion\n\n    modified_patient = Patient(job.content['ID'], client)\n    assert patient.patient_id != 'new_id'\n    assert modified_patient.patient_id == 'new_id'\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    if 'PatientID' in replace and not force:\n        raise errors.ModificationError('If PatientID is affected, `force` must be `True`')\n\n    data = {\n        'Asynchronous': True,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'RemovePrivateTags': remove_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n\n    job_info = self.client.post_patients_id_modify(self.id_, data)\n\n    # Reset cache since a main DICOM tag may have be changed\n    self._main_dicom_tags = None\n\n    return Job(job_info['ID'], self.client)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.remove_empty_studies","title":"<code>remove_empty_studies()</code>","text":"<p>Delete empty studies.</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def remove_empty_studies(self) -&gt; None:\n    \"\"\"Delete empty studies.\"\"\"\n    if self._child_resources is None:\n        return\n\n    for study in self._child_resources:\n        study.remove_empty_series()\n\n    self._child_resources = [study for study in self._child_resources if study._child_resources != []]\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.remove_label","title":"<code>remove_label(label)</code>","text":"Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def remove_label(self, label):\n    self.client.delete_patients_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.set_to_protected","title":"<code>set_to_protected()</code>","text":"<p>Set patient to protected state</p> <p>Returns:</p> Type Description <code>None</code> <p>Nothing.</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def set_to_protected(self):\n    \"\"\"Set patient to protected state\n\n    Returns\n    -------\n    None\n        Nothing.\n    \"\"\"\n    # As of version 1.11.1, the Orthanc OPEN API file has missing information\n    warnings.warn(\n        '`patient.set_to_protected()` is deprecated and will be removed in future release. '\n        'Use `patient.protected = True` instead.',\n        DeprecationWarning\n    )\n    self.protected = True\n</code></pre>"},{"location":"api/resources/patient/#pyorthanc.Patient.set_to_unprotected","title":"<code>set_to_unprotected()</code>","text":"<p>Set patient to unprotected state</p> <p>Returns:</p> Type Description <code>None</code> <p>Nothing.</p> Source code in <code>pyorthanc/_resources/patient.py</code> <pre><code>def set_to_unprotected(self):\n    \"\"\"Set patient to unprotected state\n\n    Returns\n    -------\n    None\n        Nothing.\n    \"\"\"\n    # As of version 1.11.1, the Orthanc OPEN API file has missing information\n    warnings.warn(\n        '`patient.set_to_protected()` is deprecated and will be removed in future release. '\n        'Use `patient.protected = True` instead.',\n        DeprecationWarning\n    )\n    self.protected = False\n</code></pre>"},{"location":"api/resources/resource/","title":"Resource","text":""},{"location":"api/resources/resource/#pyorthanc._resources.Resource","title":"<code>pyorthanc._resources.Resource</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>class Resource:\n\n    def __init__(self, id_: str, client: Orthanc, _lock_children: bool = False) -&gt; None:\n        \"\"\"Constructor\n\n        Parameters\n        ----------\n        id_\n            Orthanc identifier of the resource\n        client\n            Orthanc client\n        _lock_children\n            If `_lock_children` is True, the resource children (ex. instances of a series via `Series.instances`)\n            will be cached at the first query rather than queried every time. This is useful when you want\n            to filter the children of a resource and want to maintain the filter result.\n        \"\"\"\n        client = util.ensure_non_raw_response(client)\n\n        self.id_ = id_\n        self.client = client\n\n        self._lock_children = _lock_children\n        self._main_dicom_tags: Optional[Dict] = None\n        self._child_resources: Optional[List['Resource']] = None\n\n    @property\n    def identifier(self) -&gt; str:\n        \"\"\"Get Orthanc's identifier\n\n        Returns\n        -------\n        str\n            Resource's identifier\n        \"\"\"\n        return self.id_\n\n    @property\n    def main_dicom_tags(self) -&gt; Dict[str, str]:\n        if self._main_dicom_tags is None:\n            self._main_dicom_tags = self.get_main_information()['MainDicomTags']\n\n        return self._main_dicom_tags\n\n    @abc.abstractmethod\n    def legacy_viewer_url(self):\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def get_main_information(self):\n        raise NotImplementedError\n\n    def _get_main_dicom_tag_value(self, tag: str) -&gt; Any:\n        try:\n            return self.main_dicom_tags[tag]\n        except KeyError:\n            raise errors.TagDoesNotExistError(f'{self} has no {tag} tag.')\n\n    def _make_response_format_params(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n        if simplify and not short:\n            params = {'simplify': True}\n        elif short and not simplify:\n            params = {'short': True}\n        elif simplify and short:\n            raise ValueError('simplify and short can\\'t be both True.')\n        else:\n            params = {}\n\n        return params\n\n    def _download_file(\n            self, url: str,\n            filepath: Union[str, BinaryIO],\n            with_progress: bool = False,\n            params: Optional[QueryParamTypes] = None):\n        # Check if filepath is a path or a file object.\n        if isinstance(filepath, str):\n            is_file_object = False\n            filepath = open(filepath, 'wb')\n        elif hasattr(filepath, 'write') and hasattr(filepath, 'seek'):\n            is_file_object = True\n        else:\n            raise TypeError(f'\"path\" must be a file-like object or a file path, got \"{type(filepath).__name__}\".')\n\n        try:\n            with self.client.stream('GET', url, params=params) as response:\n                if with_progress:\n                    try:\n                        from tqdm import tqdm\n                    except ModuleNotFoundError:\n                        raise ModuleNotFoundError(\n                            'Optional dependency tqdm have to be installed for the progress indicator. '\n                            'Install with `pip install pyorthanc[progress]` or `pip install pyorthanc[all]'\n                        )\n\n                    last_num_bytes_downloaded = response.num_bytes_downloaded\n\n                    with tqdm(unit='B', unit_scale=True, desc=self.__repr__()) as progress:\n                        for chunk in response.iter_bytes():\n                            filepath.write(chunk)\n                            progress.update(response.num_bytes_downloaded - last_num_bytes_downloaded)\n                            last_num_bytes_downloaded = response.num_bytes_downloaded\n\n                else:\n                    for chunk in response.iter_bytes():\n                        filepath.write(chunk)\n\n        finally:\n            if not is_file_object:\n                filepath.close()\n\n    def __eq__(self, other: 'Resource') -&gt; bool:\n        return self.id_ == other.id_\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.id_})'\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource._child_resources","title":"<code>_child_resources = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/resources/resource/#pyorthanc._resources.Resource._lock_children","title":"<code>_lock_children = _lock_children</code>  <code>instance-attribute</code>","text":""},{"location":"api/resources/resource/#pyorthanc._resources.Resource._main_dicom_tags","title":"<code>_main_dicom_tags = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/resources/resource/#pyorthanc._resources.Resource.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"api/resources/resource/#pyorthanc._resources.Resource.id_","title":"<code>id_ = id_</code>  <code>instance-attribute</code>","text":""},{"location":"api/resources/resource/#pyorthanc._resources.Resource.identifier","title":"<code>identifier</code>  <code>property</code>","text":"<p>Get Orthanc's identifier</p> <p>Returns:</p> Type Description <code>str</code> <p>Resource's identifier</p>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource.main_dicom_tags","title":"<code>main_dicom_tags</code>  <code>property</code>","text":""},{"location":"api/resources/resource/#pyorthanc._resources.Resource.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>def __eq__(self, other: 'Resource') -&gt; bool:\n    return self.id_ == other.id_\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource.__init__","title":"<code>__init__(id_, client, _lock_children=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Orthanc identifier of the resource</p> required <code>client</code> <code>Orthanc</code> <p>Orthanc client</p> required <code>_lock_children</code> <code>bool</code> <p>If <code>_lock_children</code> is True, the resource children (ex. instances of a series via <code>Series.instances</code>) will be cached at the first query rather than queried every time. This is useful when you want to filter the children of a resource and want to maintain the filter result.</p> <code>False</code> Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>def __init__(self, id_: str, client: Orthanc, _lock_children: bool = False) -&gt; None:\n    \"\"\"Constructor\n\n    Parameters\n    ----------\n    id_\n        Orthanc identifier of the resource\n    client\n        Orthanc client\n    _lock_children\n        If `_lock_children` is True, the resource children (ex. instances of a series via `Series.instances`)\n        will be cached at the first query rather than queried every time. This is useful when you want\n        to filter the children of a resource and want to maintain the filter result.\n    \"\"\"\n    client = util.ensure_non_raw_response(client)\n\n    self.id_ = id_\n    self.client = client\n\n    self._lock_children = _lock_children\n    self._main_dicom_tags: Optional[Dict] = None\n    self._child_resources: Optional[List['Resource']] = None\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>def __repr__(self):\n    return f'{self.__class__.__name__}({self.id_})'\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource._download_file","title":"<code>_download_file(url, filepath, with_progress=False, params=None)</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>def _download_file(\n        self, url: str,\n        filepath: Union[str, BinaryIO],\n        with_progress: bool = False,\n        params: Optional[QueryParamTypes] = None):\n    # Check if filepath is a path or a file object.\n    if isinstance(filepath, str):\n        is_file_object = False\n        filepath = open(filepath, 'wb')\n    elif hasattr(filepath, 'write') and hasattr(filepath, 'seek'):\n        is_file_object = True\n    else:\n        raise TypeError(f'\"path\" must be a file-like object or a file path, got \"{type(filepath).__name__}\".')\n\n    try:\n        with self.client.stream('GET', url, params=params) as response:\n            if with_progress:\n                try:\n                    from tqdm import tqdm\n                except ModuleNotFoundError:\n                    raise ModuleNotFoundError(\n                        'Optional dependency tqdm have to be installed for the progress indicator. '\n                        'Install with `pip install pyorthanc[progress]` or `pip install pyorthanc[all]'\n                    )\n\n                last_num_bytes_downloaded = response.num_bytes_downloaded\n\n                with tqdm(unit='B', unit_scale=True, desc=self.__repr__()) as progress:\n                    for chunk in response.iter_bytes():\n                        filepath.write(chunk)\n                        progress.update(response.num_bytes_downloaded - last_num_bytes_downloaded)\n                        last_num_bytes_downloaded = response.num_bytes_downloaded\n\n            else:\n                for chunk in response.iter_bytes():\n                    filepath.write(chunk)\n\n    finally:\n        if not is_file_object:\n            filepath.close()\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource._get_main_dicom_tag_value","title":"<code>_get_main_dicom_tag_value(tag)</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>def _get_main_dicom_tag_value(self, tag: str) -&gt; Any:\n    try:\n        return self.main_dicom_tags[tag]\n    except KeyError:\n        raise errors.TagDoesNotExistError(f'{self} has no {tag} tag.')\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource._make_response_format_params","title":"<code>_make_response_format_params(simplify=False, short=False)</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>def _make_response_format_params(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n    if simplify and not short:\n        params = {'simplify': True}\n    elif short and not simplify:\n        params = {'short': True}\n    elif simplify and short:\n        raise ValueError('simplify and short can\\'t be both True.')\n    else:\n        params = {}\n\n    return params\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource.get_main_information","title":"<code>get_main_information()</code>  <code>abstractmethod</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>@abc.abstractmethod\ndef get_main_information(self):\n    raise NotImplementedError\n</code></pre>"},{"location":"api/resources/resource/#pyorthanc._resources.Resource.legacy_viewer_url","title":"<code>legacy_viewer_url()</code>  <code>abstractmethod</code>","text":"Source code in <code>pyorthanc/_resources/resource.py</code> <pre><code>@abc.abstractmethod\ndef legacy_viewer_url(self):\n    raise NotImplementedError\n</code></pre>"},{"location":"api/resources/series/","title":"Series","text":""},{"location":"api/resources/series/#pyorthanc.Series","title":"<code>pyorthanc.Series</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Represent a series that is in an Orthanc server</p> <p>This object has many getters that allow the user to retrieve metadata or the entire DICOM file of the Series</p> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>class Series(Resource):\n    \"\"\"Represent a series that is in an Orthanc server\n\n    This object has many getters that allow the user to retrieve metadata\n    or the entire DICOM file of the Series\n    \"\"\"\n\n    @property\n    def instances(self) -&gt; List[Instance]:\n        \"\"\"Get series instance\"\"\"\n        if self._lock_children:\n            if self._child_resources is None:\n                instances_ids = self.get_main_information()['Instances']\n                self._child_resources = [Instance(i, self.client, self._lock_children) for i in instances_ids]\n\n            return self._child_resources\n\n        instances_ids = self.get_main_information()['Instances']\n\n        return [Instance(i, self.client) for i in instances_ids]\n\n    @property\n    def uid(self) -&gt; str:\n        \"\"\"Get SeriesInstanceUID\"\"\"\n        return self._get_main_dicom_tag_value('SeriesInstanceUID')\n\n    def get_main_information(self) -&gt; Dict:\n        \"\"\"Get series main information\n\n        Returns\n        -------\n        Dict\n            Dictionary of series information\n        \"\"\"\n        return self.client.get_series_id(self.id_)\n\n    @property\n    def legacy_viewer_url(self) -&gt; str:\n        \"\"\"Get Series (legacy viewer) URL\n\n        Returns\n        -------\n        str\n            URL of series (legacy viewer)\n        \"\"\"\n        return f'{self.client.url}/app/explorer.html#series?uuid={self.id_}'\n\n    @property\n    def manufacturer(self) -&gt; str:\n        \"\"\"Get the manufacturer\"\"\"\n        return self._get_main_dicom_tag_value('Manufacturer')\n\n    @property\n    def study_identifier(self) -&gt; str:\n        \"\"\"Get the parent study identifier\"\"\"\n        return self.get_main_information()['ParentStudy']\n\n    @property\n    def parent_study(self) -&gt; Study:\n        from . import Study\n        return Study(self.study_identifier, self.client)\n\n    @property\n    def parent_patient(self) -&gt; Patient:\n        return self.parent_study.parent_patient\n\n    @property\n    def date(self) -&gt; datetime:\n        \"\"\"Get series datetime\n\n        The date have precision to the second (if available).\n\n        Returns\n        -------\n        datetime\n            Series date\n        \"\"\"\n        date_string = self._get_main_dicom_tag_value('SeriesDate')\n        try:\n            time_string = self._get_main_dicom_tag_value('SeriesTime')\n        except errors.TagDoesNotExistError:\n            time_string = None\n\n        return util.make_datetime_from_dicom_date(date_string, time_string)\n\n    @property\n    def modality(self) -&gt; str:\n        \"\"\"Get series modality\"\"\"\n        return self._get_main_dicom_tag_value('Modality')\n\n    @property\n    def series_number(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('SeriesNumber'))\n\n    @property\n    def performed_procedure_step_description(self) -&gt; str:\n        return self._get_main_dicom_tag_value('PerformedProcedureStepDescription')\n\n    @property\n    def protocol_name(self) -&gt; str:\n        return self._get_main_dicom_tag_value('ProtocolName')\n\n    @property\n    def station_name(self) -&gt; str:\n        return self._get_main_dicom_tag_value('StationName')\n\n    @property\n    def description(self) -&gt; str:\n        return self._get_main_dicom_tag_value('SeriesDescription')\n\n    @property\n    def body_part_examined(self) -&gt; str:\n        return self._get_main_dicom_tag_value('BodyPartExamined')\n\n    @property\n    def sequence_name(self) -&gt; str:\n        return self._get_main_dicom_tag_value('SequenceName')\n\n    @property\n    def cardiac_number_of_images(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('CardiacNumberOfImages'))\n\n    @property\n    def images_in_acquisition(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('ImagesInAcquisition'))\n\n    @property\n    def number_of_temporal_positions(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('NumberOfTemporalPositions'))\n\n    @property\n    def number_of_slices(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('NumberOfSlices'))\n\n    @property\n    def number_of_time_slices(self) -&gt; int:\n        return int(self._get_main_dicom_tag_value('NumberOfTimeSlices'))\n\n    @property\n    def image_orientation_patient(self) -&gt; List[float]:\n        orientation = self._get_main_dicom_tag_value('ImageOrientationPatient')\n\n        return [float(i) for i in orientation.split('\\\\')]\n\n    @property\n    def series_type(self) -&gt; str:\n        return self._get_main_dicom_tag_value('SeriesType')\n\n    @property\n    def operators_name(self) -&gt; str:\n        return self._get_main_dicom_tag_value('OperatorsName')\n\n    @property\n    def acquisition_device_processing_description(self) -&gt; str:\n        return self._get_main_dicom_tag_value('AcquisitionDeviceProcessingDescription')\n\n    @property\n    def contrast_bolus_agent(self) -&gt; str:\n        return self._get_main_dicom_tag_value('ContrastBolusAgent')\n\n    @property\n    def is_stable(self) -&gt; bool:\n        return self.get_main_information()['IsStable']\n\n    @property\n    def last_update(self) -&gt; datetime:\n        last_updated_date_and_time = self.get_main_information()['LastUpdate'].split('T')\n        date = last_updated_date_and_time[0]\n        time = last_updated_date_and_time[1]\n\n        return util.make_datetime_from_dicom_date(date, time)\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return self.get_main_information()['Labels']\n\n    def add_label(self, label: str) -&gt; None:\n        self.client.put_series_id_labels_label(self.id_, label)\n\n    def remove_label(self, label):\n        self.client.delete_series_id_labels_label(self.id_, label)\n\n    def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n                  force: bool = False, keep_private_tags: bool = False,\n                  keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                  private_creator: str = None, dicom_version: str = None) -&gt; 'Series':\n        \"\"\"Anonymize series\n\n        If no error has been raise, return an anonymous series.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method might be long to run, especially on large series or when multiple\n        series are anonymized. In those cases, it is recommended to use the `.anonymize_as_job()`\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            List of tag to keep unchanged\n        force\n            Some tags can't be changed without forcing it (e.g. SeriesID) for security reason\n        keep_private_tags\n            If True, keep the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in replace.\n        dicom_version\n            Version of the DICOM standard to be used for anonymization.\n            Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n        Returns\n        -------\n        Series\n            A New anonymous series.\n\n        Examples\n        --------\n        ```python\n        new_series = series.anonymize()\n\n        new_series_with_specific_series_id = series.anonymize(\n            replace={'SeriesDescription': 'A description'}\n        )\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        data = {\n            'Asynchronous': False,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'KeepPrivateTags': keep_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n        if dicom_version is not None:\n            data['DicomVersion'] = dicom_version\n\n        try:\n            anonymous_series = self.client.post_series_id_anonymize(self.id_, data)\n        except ReadTimeout:\n            raise ReadTimeout(\n                'Series anonymization is too long to process. '\n                'Use `.anonymize_as_job` or increase client.timeout.'\n            )\n\n        return Series(anonymous_series['ID'], self.client)\n\n    def anonymize_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                         force: bool = False, keep_private_tags: bool = False,\n                         keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                         private_creator: str = None, dicom_version: str = None) -&gt; Job:\n        \"\"\"Anonymize series and return a job\n\n        Launch an anonymization job.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method is useful when anonymizing large series or launching many\n        anonymization jobs. The jobs are sent to Orthanc and processed according\n        to the priority.\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            List of tag to keep unchanged\n        force\n            Some tags can't be changed without forcing it (e.g. SeriesInstanceUID) for security reason\n        keep_private_tags\n            If True, keep the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in replace.\n        dicom_version\n            Version of the DICOM standard to be used for anonymization.\n            Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n        Returns\n        -------\n        Job\n            Return a Job object of the anonymization job.\n\n        Examples\n        --------\n        For large series (recommended)\n        ```python\n        job = series.anonymize_as_job()\n        job.state  # You can follow the job state\n\n        job.wait_until_completion() # Or just wait on its completion\n        new_series = Series(job.content['ID'], orthanc)\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        data = {\n            'Asynchronous': True,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'KeepPrivateTags': keep_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n        if dicom_version is not None:\n            data['DicomVersion'] = dicom_version\n\n        job_info = self.client.post_series_id_anonymize(self.id_, data)\n\n        return Job(job_info['ID'], self.client)\n\n    def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n               force: bool = False, remove_private_tags: bool = False,\n               keep_source: bool = True, priority: int = 0, permissive: bool = False,\n               private_creator: str = None) -&gt; 'Series':\n        \"\"\"Modify series\n\n        If no error has been raise, then create a modified version of the series.\n        If keep=['SeriesInstanceUID'] and force=True are use, then the series itself is changed.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method might be long to run, especially on large series or when multiple\n        series are modified. In those cases, it is recommended to use the `.modify_as_job()`\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            Keep the original value of the specified tags, to be chosen among the SeriesInstanceUID,\n            SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n            as this breaks the DICOM model of the real world.\n        force\n            Some tags can't be changed without forcing it (e.g. SeriesInstanceUID) for security reason\n        remove_private_tags\n            If True, remove the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n\n        Returns\n        -------\n        Series\n            Returns a new modified series or returns itself if keep=['SeriesInstanceUID']\n            (in this case, the series itself is modified).\n\n        Examples\n        --------\n        ```python\n        # Create a modified series\n        modified_series = series.modify(replace={'SeriesInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'}, force=True)\n        assert modified_series.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n\n        # Modify itself\n        series.modify(replace={'ReferringPhysicianName': 'last^first'}, keep=['SeriesInstanceUID'], force=True)\n        assert series.referring_physician_name == 'last^first'\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        if 'SeriesInstanceUID' in replace and not force:\n            raise errors.ModificationError('If SeriesInstanceUID is replaced, `force` must be `True`')\n\n        data = {\n            'Asynchronous': False,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'RemovePrivateTags': remove_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n\n        try:\n            modified_series = self.client.post_series_id_modify(self.id_, data)\n        except ReadTimeout:\n            raise ReadTimeout(\n                'Series modification is too long to process. '\n                'Use `.modify_as_job` or increase client.timeout.'\n            )\n\n        # Reset cache since a main DICOM tag may have be changed\n        self._main_dicom_tags = None\n\n        # if 'SeriesInstanceUID' is not affected, the modified_series['ID'] is the same as self.id_\n        return Series(modified_series['ID'], self.client)\n\n    def modify_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                      force: bool = False, remove_private_tags: bool = False,\n                      keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                      private_creator: str = None) -&gt; Job:\n        \"\"\"Modify series and return a job\n\n        Launch a modification job. If keep=['SeriesInstanceUID'] (with `force=True`),\n        then modified this series. If the SeriesInstanceUID is not keeped, this creates\n        a new modified series.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method is useful when modifying large series or launching many\n        modification jobs. The jobs are sent to Orthanc and processed according\n        to the priority.\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            Keep the original value of the specified tags, to be chosen among the SeriesInstanceUID,\n            SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n            as this breaks the DICOM model of the real world.\n        force\n            Allow the modification of tags related to DICOM identifiers, at the risk of breaking\n            the DICOM model of the real world.\n        remove_private_tags\n            If True, remove the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n\n        Returns\n        -------\n        Job\n            Return a Job object of the modification job.\n\n        Examples\n        --------\n        For large series (recommended)\n        ```python\n        job = series.modify_as_job(replace={'SeriesDescription': 'a description'})\n        job.state  # You can follow the job state\n\n        job.wait_until_completion() # Or just wait on its completion\n        modified_series = Series(job.content['ID'], client)\n        assert modified_series.description == 'a description'\n        ```\n        Or modify the SeriesInstanceUID\n        ```python\n        job = series.modify_as_job(\n            replace={'SeriesInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'},\n            force=True\n        )\n        job.wait_until_completion() # Or just wait on its completion\n\n        modified_series = Series(job.content['ID'], client)\n        modified_series.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n        ```\n        Or keep the SeriesInstanceUID\n        ```python\n        job = series.modify_as_job(\n            replace={'SeriesDescription': 'a description'},\n            keep=['SeriesInstanceUID'],\n            force=True\n        )\n        job.wait_until_completion()\n\n        assert series.description == 'a description'\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        if 'SeriesInstanceUID' in replace and not force:\n            raise errors.ModificationError('If SeriesInstanceUID is affected, `force` must be `True`')\n\n        data = {\n            'Asynchronous': True,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'RemovePrivateTags': remove_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n\n        job_info = self.client.post_series_id_modify(self.id_, data)\n\n        # Reset cache since a main DICOM tag may have be changed\n        self._main_dicom_tags = None\n\n        return Job(job_info['ID'], self.client)\n\n    def get_zip(self) -&gt; bytes:\n        \"\"\"Get the bytes of the zip file\n\n        Get the .zip file.\n\n        Returns\n        -------\n        bytes\n            Bytes of Zip file of the series.\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Orthanc, Series\n        a_series = Series('SERIES_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n        bytes_content = a_series.get_zip()\n        with open('series_zip_file_path.zip', 'wb') as file_handler:\n            file_handler.write(bytes_content)\n        ```\n\n        \"\"\"\n        return self.client.get_series_id_archive(self.id_)\n\n    def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n        \"\"\"Download the zip file to a target path or buffer\n\n        This method is an alternative to the `.get_zip()` method for large files.\n        The `.get_zip()` method will pull all the data in a single GET call,\n        while `.download()` stream the data to a file or a buffer.\n        Favor the `.download()` method to avoid timeout and memory issues.\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Orthanc, Series\n        a_series = Series('SERIES_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n        # Download a zip\n        a_series.download('series.zip')\n\n        # Download a zip and show progress\n        a_series.download('series.zip', with_progres=True)\n\n        # Or download in a buffer in memory\n        buffer = io.BytesIO()\n        a_series.download(buffer)\n        # Now do whatever you want to do\n        buffer.seek(0)\n        zip_bytes = buffer.read()\n        ```\n        \"\"\"\n        self._download_file(f'{self.client.url}/series/{self.id_}/archive', filepath, with_progres)\n\n    def get_shared_tags(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n        \"\"\"Retrieve the shared tags of the series\"\"\"\n        params = self._make_response_format_params(simplify, short)\n\n        return dict(self.client.get_series_id_shared_tags(\n            self.id_,\n            params=params\n        ))\n\n    @property\n    def shared_tags(self) -&gt; Dict:\n        return self.get_shared_tags(simplify=True)\n\n    def remove_empty_instances(self) -&gt; None:\n        if self._child_resources is not None:\n            self._child_resources = [i for i in self._child_resources if i is not None]\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.acquisition_device_processing_description","title":"<code>acquisition_device_processing_description</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.body_part_examined","title":"<code>body_part_examined</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.cardiac_number_of_images","title":"<code>cardiac_number_of_images</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.contrast_bolus_agent","title":"<code>contrast_bolus_agent</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.date","title":"<code>date</code>  <code>property</code>","text":"<p>Get series datetime</p> <p>The date have precision to the second (if available).</p> <p>Returns:</p> Type Description <code>datetime</code> <p>Series date</p>"},{"location":"api/resources/series/#pyorthanc.Series.description","title":"<code>description</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.image_orientation_patient","title":"<code>image_orientation_patient</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.images_in_acquisition","title":"<code>images_in_acquisition</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.instances","title":"<code>instances</code>  <code>property</code>","text":"<p>Get series instance</p>"},{"location":"api/resources/series/#pyorthanc.Series.is_stable","title":"<code>is_stable</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.labels","title":"<code>labels</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.last_update","title":"<code>last_update</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.legacy_viewer_url","title":"<code>legacy_viewer_url</code>  <code>property</code>","text":"<p>Get Series (legacy viewer) URL</p> <p>Returns:</p> Type Description <code>str</code> <p>URL of series (legacy viewer)</p>"},{"location":"api/resources/series/#pyorthanc.Series.manufacturer","title":"<code>manufacturer</code>  <code>property</code>","text":"<p>Get the manufacturer</p>"},{"location":"api/resources/series/#pyorthanc.Series.modality","title":"<code>modality</code>  <code>property</code>","text":"<p>Get series modality</p>"},{"location":"api/resources/series/#pyorthanc.Series.number_of_slices","title":"<code>number_of_slices</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.number_of_temporal_positions","title":"<code>number_of_temporal_positions</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.number_of_time_slices","title":"<code>number_of_time_slices</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.operators_name","title":"<code>operators_name</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.parent_patient","title":"<code>parent_patient</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.parent_study","title":"<code>parent_study</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.performed_procedure_step_description","title":"<code>performed_procedure_step_description</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.protocol_name","title":"<code>protocol_name</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.sequence_name","title":"<code>sequence_name</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.series_number","title":"<code>series_number</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.series_type","title":"<code>series_type</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.shared_tags","title":"<code>shared_tags</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.station_name","title":"<code>station_name</code>  <code>property</code>","text":""},{"location":"api/resources/series/#pyorthanc.Series.study_identifier","title":"<code>study_identifier</code>  <code>property</code>","text":"<p>Get the parent study identifier</p>"},{"location":"api/resources/series/#pyorthanc.Series.uid","title":"<code>uid</code>  <code>property</code>","text":"<p>Get SeriesInstanceUID</p>"},{"location":"api/resources/series/#pyorthanc.Series.add_label","title":"<code>add_label(label)</code>","text":"Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def add_label(self, label: str) -&gt; None:\n    self.client.put_series_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.anonymize","title":"<code>anonymize(remove=None, replace=None, keep=None, force=False, keep_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None, dicom_version=None)</code>","text":"<p>Anonymize series</p> <p>If no error has been raise, return an anonymous series. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method might be long to run, especially on large series or when multiple series are anonymized. In those cases, it is recommended to use the <code>.anonymize_as_job()</code></p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>List of tag to keep unchanged</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. SeriesID) for security reason</p> <code>False</code> <code>keep_private_tags</code> <code>bool</code> <p>If True, keep the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in replace.</p> <code>None</code> <code>dicom_version</code> <code>str</code> <p>Version of the DICOM standard to be used for anonymization. Check out configuration option DeidentifyLogsDicomVersion for possible values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>A New anonymous series.</p> <p>Examples:</p> <p>```python new_series = series.anonymize()</p> <p>new_series_with_specific_series_id = series.anonymize(     replace={'SeriesDescription': 'A description'} )</p> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n              force: bool = False, keep_private_tags: bool = False,\n              keep_source: bool = True, priority: int = 0, permissive: bool = False,\n              private_creator: str = None, dicom_version: str = None) -&gt; 'Series':\n    \"\"\"Anonymize series\n\n    If no error has been raise, return an anonymous series.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method might be long to run, especially on large series or when multiple\n    series are anonymized. In those cases, it is recommended to use the `.anonymize_as_job()`\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        List of tag to keep unchanged\n    force\n        Some tags can't be changed without forcing it (e.g. SeriesID) for security reason\n    keep_private_tags\n        If True, keep the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in replace.\n    dicom_version\n        Version of the DICOM standard to be used for anonymization.\n        Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n    Returns\n    -------\n    Series\n        A New anonymous series.\n\n    Examples\n    --------\n    ```python\n    new_series = series.anonymize()\n\n    new_series_with_specific_series_id = series.anonymize(\n        replace={'SeriesDescription': 'A description'}\n    )\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    data = {\n        'Asynchronous': False,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'KeepPrivateTags': keep_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n    if dicom_version is not None:\n        data['DicomVersion'] = dicom_version\n\n    try:\n        anonymous_series = self.client.post_series_id_anonymize(self.id_, data)\n    except ReadTimeout:\n        raise ReadTimeout(\n            'Series anonymization is too long to process. '\n            'Use `.anonymize_as_job` or increase client.timeout.'\n        )\n\n    return Series(anonymous_series['ID'], self.client)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.anonymize_as_job","title":"<code>anonymize_as_job(remove=None, replace=None, keep=None, force=False, keep_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None, dicom_version=None)</code>","text":"<p>Anonymize series and return a job</p> <p>Launch an anonymization job. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method is useful when anonymizing large series or launching many anonymization jobs. The jobs are sent to Orthanc and processed according to the priority.</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>List of tag to keep unchanged</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. SeriesInstanceUID) for security reason</p> <code>False</code> <code>keep_private_tags</code> <code>bool</code> <p>If True, keep the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in replace.</p> <code>None</code> <code>dicom_version</code> <code>str</code> <p>Version of the DICOM standard to be used for anonymization. Check out configuration option DeidentifyLogsDicomVersion for possible values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Job</code> <p>Return a Job object of the anonymization job.</p> <p>Examples:</p> <p>For large series (recommended)</p> <pre><code>job = series.anonymize_as_job()\njob.state  # You can follow the job state\n\njob.wait_until_completion() # Or just wait on its completion\nnew_series = Series(job.content['ID'], orthanc)\n</code></pre> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def anonymize_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                     force: bool = False, keep_private_tags: bool = False,\n                     keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                     private_creator: str = None, dicom_version: str = None) -&gt; Job:\n    \"\"\"Anonymize series and return a job\n\n    Launch an anonymization job.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method is useful when anonymizing large series or launching many\n    anonymization jobs. The jobs are sent to Orthanc and processed according\n    to the priority.\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        List of tag to keep unchanged\n    force\n        Some tags can't be changed without forcing it (e.g. SeriesInstanceUID) for security reason\n    keep_private_tags\n        If True, keep the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in replace.\n    dicom_version\n        Version of the DICOM standard to be used for anonymization.\n        Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n    Returns\n    -------\n    Job\n        Return a Job object of the anonymization job.\n\n    Examples\n    --------\n    For large series (recommended)\n    ```python\n    job = series.anonymize_as_job()\n    job.state  # You can follow the job state\n\n    job.wait_until_completion() # Or just wait on its completion\n    new_series = Series(job.content['ID'], orthanc)\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    data = {\n        'Asynchronous': True,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'KeepPrivateTags': keep_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n    if dicom_version is not None:\n        data['DicomVersion'] = dicom_version\n\n    job_info = self.client.post_series_id_anonymize(self.id_, data)\n\n    return Job(job_info['ID'], self.client)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.download","title":"<code>download(filepath, with_progres=False)</code>","text":"<p>Download the zip file to a target path or buffer</p> <p>This method is an alternative to the <code>.get_zip()</code> method for large files. The <code>.get_zip()</code> method will pull all the data in a single GET call, while <code>.download()</code> stream the data to a file or a buffer. Favor the <code>.download()</code> method to avoid timeout and memory issues.</p> <p>Examples:</p> <pre><code>from pyorthanc import Orthanc, Series\na_series = Series('SERIES_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n# Download a zip\na_series.download('series.zip')\n\n# Download a zip and show progress\na_series.download('series.zip', with_progres=True)\n\n# Or download in a buffer in memory\nbuffer = io.BytesIO()\na_series.download(buffer)\n# Now do whatever you want to do\nbuffer.seek(0)\nzip_bytes = buffer.read()\n</code></pre> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n    \"\"\"Download the zip file to a target path or buffer\n\n    This method is an alternative to the `.get_zip()` method for large files.\n    The `.get_zip()` method will pull all the data in a single GET call,\n    while `.download()` stream the data to a file or a buffer.\n    Favor the `.download()` method to avoid timeout and memory issues.\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Orthanc, Series\n    a_series = Series('SERIES_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n    # Download a zip\n    a_series.download('series.zip')\n\n    # Download a zip and show progress\n    a_series.download('series.zip', with_progres=True)\n\n    # Or download in a buffer in memory\n    buffer = io.BytesIO()\n    a_series.download(buffer)\n    # Now do whatever you want to do\n    buffer.seek(0)\n    zip_bytes = buffer.read()\n    ```\n    \"\"\"\n    self._download_file(f'{self.client.url}/series/{self.id_}/archive', filepath, with_progres)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.get_main_information","title":"<code>get_main_information()</code>","text":"<p>Get series main information</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary of series information</p> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def get_main_information(self) -&gt; Dict:\n    \"\"\"Get series main information\n\n    Returns\n    -------\n    Dict\n        Dictionary of series information\n    \"\"\"\n    return self.client.get_series_id(self.id_)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.get_shared_tags","title":"<code>get_shared_tags(simplify=False, short=False)</code>","text":"<p>Retrieve the shared tags of the series</p> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def get_shared_tags(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n    \"\"\"Retrieve the shared tags of the series\"\"\"\n    params = self._make_response_format_params(simplify, short)\n\n    return dict(self.client.get_series_id_shared_tags(\n        self.id_,\n        params=params\n    ))\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.get_zip","title":"<code>get_zip()</code>","text":"<p>Get the bytes of the zip file</p> <p>Get the .zip file.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes of Zip file of the series.</p> <p>Examples:</p> <pre><code>from pyorthanc import Orthanc, Series\na_series = Series('SERIES_IDENTIFIER', Orthanc('http://localhost:8042'))\n\nbytes_content = a_series.get_zip()\nwith open('series_zip_file_path.zip', 'wb') as file_handler:\n    file_handler.write(bytes_content)\n</code></pre> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def get_zip(self) -&gt; bytes:\n    \"\"\"Get the bytes of the zip file\n\n    Get the .zip file.\n\n    Returns\n    -------\n    bytes\n        Bytes of Zip file of the series.\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Orthanc, Series\n    a_series = Series('SERIES_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n    bytes_content = a_series.get_zip()\n    with open('series_zip_file_path.zip', 'wb') as file_handler:\n        file_handler.write(bytes_content)\n    ```\n\n    \"\"\"\n    return self.client.get_series_id_archive(self.id_)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.modify","title":"<code>modify(remove=None, replace=None, keep=None, force=False, remove_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None)</code>","text":"<p>Modify series</p> <p>If no error has been raise, then create a modified version of the series. If keep=['SeriesInstanceUID'] and force=True are use, then the series itself is changed. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method might be long to run, especially on large series or when multiple series are modified. In those cases, it is recommended to use the <code>.modify_as_job()</code></p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>Keep the original value of the specified tags, to be chosen among the SeriesInstanceUID, SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. SeriesInstanceUID) for security reason</p> <code>False</code> <code>remove_private_tags</code> <code>bool</code> <p>If True, remove the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>Returns a new modified series or returns itself if keep=['SeriesInstanceUID'] (in this case, the series itself is modified).</p> <p>Examples:</p> <pre><code># Create a modified series\nmodified_series = series.modify(replace={'SeriesInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'}, force=True)\nassert modified_series.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n\n# Modify itself\nseries.modify(replace={'ReferringPhysicianName': 'last^first'}, keep=['SeriesInstanceUID'], force=True)\nassert series.referring_physician_name == 'last^first'\n</code></pre> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n           force: bool = False, remove_private_tags: bool = False,\n           keep_source: bool = True, priority: int = 0, permissive: bool = False,\n           private_creator: str = None) -&gt; 'Series':\n    \"\"\"Modify series\n\n    If no error has been raise, then create a modified version of the series.\n    If keep=['SeriesInstanceUID'] and force=True are use, then the series itself is changed.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method might be long to run, especially on large series or when multiple\n    series are modified. In those cases, it is recommended to use the `.modify_as_job()`\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        Keep the original value of the specified tags, to be chosen among the SeriesInstanceUID,\n        SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n        as this breaks the DICOM model of the real world.\n    force\n        Some tags can't be changed without forcing it (e.g. SeriesInstanceUID) for security reason\n    remove_private_tags\n        If True, remove the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n\n    Returns\n    -------\n    Series\n        Returns a new modified series or returns itself if keep=['SeriesInstanceUID']\n        (in this case, the series itself is modified).\n\n    Examples\n    --------\n    ```python\n    # Create a modified series\n    modified_series = series.modify(replace={'SeriesInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'}, force=True)\n    assert modified_series.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n\n    # Modify itself\n    series.modify(replace={'ReferringPhysicianName': 'last^first'}, keep=['SeriesInstanceUID'], force=True)\n    assert series.referring_physician_name == 'last^first'\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    if 'SeriesInstanceUID' in replace and not force:\n        raise errors.ModificationError('If SeriesInstanceUID is replaced, `force` must be `True`')\n\n    data = {\n        'Asynchronous': False,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'RemovePrivateTags': remove_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n\n    try:\n        modified_series = self.client.post_series_id_modify(self.id_, data)\n    except ReadTimeout:\n        raise ReadTimeout(\n            'Series modification is too long to process. '\n            'Use `.modify_as_job` or increase client.timeout.'\n        )\n\n    # Reset cache since a main DICOM tag may have be changed\n    self._main_dicom_tags = None\n\n    # if 'SeriesInstanceUID' is not affected, the modified_series['ID'] is the same as self.id_\n    return Series(modified_series['ID'], self.client)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.modify_as_job","title":"<code>modify_as_job(remove=None, replace=None, keep=None, force=False, remove_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None)</code>","text":"<p>Modify series and return a job</p> <p>Launch a modification job. If keep=['SeriesInstanceUID'] (with <code>force=True</code>), then modified this series. If the SeriesInstanceUID is not keeped, this creates a new modified series. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method is useful when modifying large series or launching many modification jobs. The jobs are sent to Orthanc and processed according to the priority.</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>Keep the original value of the specified tags, to be chosen among the SeriesInstanceUID, SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world.</p> <code>False</code> <code>remove_private_tags</code> <code>bool</code> <p>If True, remove the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <p>Returns:</p> Type Description <code>Job</code> <p>Return a Job object of the modification job.</p> <p>Examples:</p> <p>For large series (recommended)</p> <pre><code>job = series.modify_as_job(replace={'SeriesDescription': 'a description'})\njob.state  # You can follow the job state\n\njob.wait_until_completion() # Or just wait on its completion\nmodified_series = Series(job.content['ID'], client)\nassert modified_series.description == 'a description'\n</code></pre> <p>Or modify the SeriesInstanceUID</p> <pre><code>job = series.modify_as_job(\n    replace={'SeriesInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'},\n    force=True\n)\njob.wait_until_completion() # Or just wait on its completion\n\nmodified_series = Series(job.content['ID'], client)\nmodified_series.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n</code></pre> <p>Or keep the SeriesInstanceUID</p> <pre><code>job = series.modify_as_job(\n    replace={'SeriesDescription': 'a description'},\n    keep=['SeriesInstanceUID'],\n    force=True\n)\njob.wait_until_completion()\n\nassert series.description == 'a description'\n</code></pre> Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def modify_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                  force: bool = False, remove_private_tags: bool = False,\n                  keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                  private_creator: str = None) -&gt; Job:\n    \"\"\"Modify series and return a job\n\n    Launch a modification job. If keep=['SeriesInstanceUID'] (with `force=True`),\n    then modified this series. If the SeriesInstanceUID is not keeped, this creates\n    a new modified series.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method is useful when modifying large series or launching many\n    modification jobs. The jobs are sent to Orthanc and processed according\n    to the priority.\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        Keep the original value of the specified tags, to be chosen among the SeriesInstanceUID,\n        SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n        as this breaks the DICOM model of the real world.\n    force\n        Allow the modification of tags related to DICOM identifiers, at the risk of breaking\n        the DICOM model of the real world.\n    remove_private_tags\n        If True, remove the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n\n    Returns\n    -------\n    Job\n        Return a Job object of the modification job.\n\n    Examples\n    --------\n    For large series (recommended)\n    ```python\n    job = series.modify_as_job(replace={'SeriesDescription': 'a description'})\n    job.state  # You can follow the job state\n\n    job.wait_until_completion() # Or just wait on its completion\n    modified_series = Series(job.content['ID'], client)\n    assert modified_series.description == 'a description'\n    ```\n    Or modify the SeriesInstanceUID\n    ```python\n    job = series.modify_as_job(\n        replace={'SeriesInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'},\n        force=True\n    )\n    job.wait_until_completion() # Or just wait on its completion\n\n    modified_series = Series(job.content['ID'], client)\n    modified_series.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n    ```\n    Or keep the SeriesInstanceUID\n    ```python\n    job = series.modify_as_job(\n        replace={'SeriesDescription': 'a description'},\n        keep=['SeriesInstanceUID'],\n        force=True\n    )\n    job.wait_until_completion()\n\n    assert series.description == 'a description'\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    if 'SeriesInstanceUID' in replace and not force:\n        raise errors.ModificationError('If SeriesInstanceUID is affected, `force` must be `True`')\n\n    data = {\n        'Asynchronous': True,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'RemovePrivateTags': remove_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n\n    job_info = self.client.post_series_id_modify(self.id_, data)\n\n    # Reset cache since a main DICOM tag may have be changed\n    self._main_dicom_tags = None\n\n    return Job(job_info['ID'], self.client)\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.remove_empty_instances","title":"<code>remove_empty_instances()</code>","text":"Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def remove_empty_instances(self) -&gt; None:\n    if self._child_resources is not None:\n        self._child_resources = [i for i in self._child_resources if i is not None]\n</code></pre>"},{"location":"api/resources/series/#pyorthanc.Series.remove_label","title":"<code>remove_label(label)</code>","text":"Source code in <code>pyorthanc/_resources/series.py</code> <pre><code>def remove_label(self, label):\n    self.client.delete_series_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"api/resources/study/","title":"Study","text":""},{"location":"api/resources/study/#pyorthanc.Study","title":"<code>pyorthanc.Study</code>","text":"<p>               Bases: <code>Resource</code></p> <p>Represent a study that is in an Orthanc server</p> <p>This object has many getters that allow the user to retrieve metadata or the entire DICOM file of the Series</p> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>class Study(Resource):\n    \"\"\"Represent a study that is in an Orthanc server\n\n    This object has many getters that allow the user to retrieve metadata\n    or the entire DICOM file of the Series\n    \"\"\"\n\n    def get_main_information(self) -&gt; Dict:\n        \"\"\"Get Study information\n\n        Returns\n        -------\n        Dict\n            Dictionary of study information\n        \"\"\"\n        return self.client.get_studies_id(self.id_)\n\n    @property\n    def legacy_viewer_url(self) -&gt; str:\n        \"\"\"Get Study (legacy viewer) URL\n\n        Returns\n        -------\n        str\n            URL of study (legacy viewer)\n        \"\"\"\n        return f'{self.client.url}/app/explorer.html#study?uuid={self.id_}'\n\n    @property\n    def referring_physician_name(self) -&gt; str:\n        \"\"\"Get referring physician name\"\"\"\n        return self._get_main_dicom_tag_value('ReferringPhysicianName')\n\n    @property\n    def requesting_physician(self) -&gt; str:\n        \"\"\"Get referring physician name\"\"\"\n        return self._get_main_dicom_tag_value('RequestingPhysician')\n\n    @property\n    def date(self) -&gt; datetime:\n        \"\"\"Get study date\n\n        The date have precision to the second (if available).\n\n        Returns\n        -------\n        datetime\n            Study date\n        \"\"\"\n        date_string = self._get_main_dicom_tag_value('StudyDate')\n        try:\n            time_string = self._get_main_dicom_tag_value('StudyTime')\n        except errors.TagDoesNotExistError:\n            time_string = None\n\n        return util.make_datetime_from_dicom_date(date_string, time_string)\n\n    @property\n    def study_id(self) -&gt; str:\n        \"\"\"Get Study ID\"\"\"\n        return self._get_main_dicom_tag_value('StudyID')\n\n    @property\n    def uid(self) -&gt; str:\n        \"\"\"Get StudyInstanceUID\"\"\"\n        return self._get_main_dicom_tag_value('StudyInstanceUID')\n\n    @property\n    def patient_identifier(self) -&gt; str:\n        \"\"\"Get the Orthanc identifier of the parent patient\"\"\"\n        return self.get_main_information()['ParentPatient']\n\n    @property\n    def parent_patient(self) -&gt; Patient:\n        from . import Patient\n        return Patient(self.patient_identifier, self.client)\n\n    @property\n    def patient_information(self) -&gt; Dict:\n        \"\"\"Get patient information\"\"\"\n        return self.get_main_information()['PatientMainDicomTags']\n\n    @property\n    def series(self) -&gt; List[Series]:\n        \"\"\"Get Study series\"\"\"\n        if self._lock_children:\n            if self._child_resources is None:\n                series_ids = self.get_main_information()['Series']\n                self._child_resources = [Series(i, self.client, self._lock_children) for i in series_ids]\n\n            return self._child_resources\n\n        series_ids = self.get_main_information()['Series']\n\n        return [Series(i, self.client) for i in series_ids]\n\n    @property\n    def accession_number(self) -&gt; str:\n        return self._get_main_dicom_tag_value('AccessionNumber')\n\n    @property\n    def description(self) -&gt; str:\n        return self._get_main_dicom_tag_value('StudyDescription')\n\n    @property\n    def institution_name(self) -&gt; str:\n        return self._get_main_dicom_tag_value('InstitutionName')\n\n    @property\n    def requested_procedure_description(self) -&gt; str:\n        return self._get_main_dicom_tag_value('RequestedProcedureDescription')\n\n    @property\n    def is_stable(self) -&gt; bool:\n        return self.get_main_information()['IsStable']\n\n    @property\n    def last_update(self) -&gt; datetime:\n        last_updated_date_and_time = self.get_main_information()['LastUpdate'].split('T')\n        date = last_updated_date_and_time[0]\n        time = last_updated_date_and_time[1]\n\n        return util.make_datetime_from_dicom_date(date, time)\n\n    @property\n    def labels(self) -&gt; List[str]:\n        return self.get_main_information()['Labels']\n\n    def add_label(self, label: str) -&gt; None:\n        self.client.put_studies_id_labels_label(self.id_, label)\n\n    def remove_label(self, label):\n        self.client.delete_studies_id_labels_label(self.id_, label)\n\n    def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n                  force: bool = False, keep_private_tags: bool = False,\n                  keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                  private_creator: str = None, dicom_version: str = None) -&gt; 'Study':\n        \"\"\"Anonymize study\n\n        If no error has been raise, return an anonymous study.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method might be long to run, especially on large study or when multiple\n        studies are anonymized. In those cases, it is recommended to use the `.anonymize_as_job()`\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            List of tag to keep unchanged\n        force\n            Some tags can't be changed without forcing it (e.g. StudyID) for security reason\n        keep_private_tags\n            If True, keep the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in replace.\n        dicom_version\n            Version of the DICOM standard to be used for anonymization.\n            Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n        Returns\n        -------\n        Study\n            A New anonymous study.\n\n        Examples\n        --------\n        ```python\n        new_study = study.anonymize()\n\n        new_study_with_specific_study_id = study.anonymize(\n            replace={'StudyDescription': 'A description'}\n        )\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        data = {\n            'Asynchronous': False,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'KeepPrivateTags': keep_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n        if dicom_version is not None:\n            data['DicomVersion'] = dicom_version\n\n        try:\n            anonymous_study = self.client.post_studies_id_anonymize(self.id_, data)\n        except ReadTimeout:\n            raise ReadTimeout(\n                'Study anonymization is too long to process. '\n                'Use `.anonymize_as_job` or increase client.timeout.'\n            )\n\n        return Study(anonymous_study['ID'], self.client)\n\n    def anonymize_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                         force: bool = False, keep_private_tags: bool = False,\n                         keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                         private_creator: str = None, dicom_version: str = None) -&gt; Job:\n        \"\"\"Anonymize study and return a job\n\n        Launch an anonymization job.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method is useful when anonymizing large study or launching many\n        anonymization jobs. The jobs are sent to Orthanc and processed according\n        to the priority.\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            List of tag to keep unchanged\n        force\n            Some tags can't be changed without forcing it (e.g. StudyInstanceUID) for security reason\n        keep_private_tags\n            If True, keep the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in replace.\n        dicom_version\n            Version of the DICOM standard to be used for anonymization.\n            Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n        Returns\n        -------\n        Job\n            Return a Job object of the anonymization job.\n\n        Examples\n        --------\n        For large study (recommended)\n        ```python\n        job = study.anonymize_as_job()\n        job.state  # You can follow the job state\n\n        job.wait_until_completion() # Or just wait on its completion\n        new_study = Study(job.content['ID'], orthanc)\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        data = {\n            'Asynchronous': True,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'KeepPrivateTags': keep_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n        if dicom_version is not None:\n            data['DicomVersion'] = dicom_version\n\n        job_info = self.client.post_studies_id_anonymize(self.id_, data)\n\n        return Job(job_info['ID'], self.client)\n\n    def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n               force: bool = False, remove_private_tags: bool = False,\n               keep_source: bool = True, priority: int = 0, permissive: bool = False,\n               private_creator: str = None) -&gt; 'Study':\n        \"\"\"Modify study\n\n        If no error has been raise, then create a modified version of the study.\n        If keep=['StudyInstanceUID'] and force=True are use, then the study itself is changed.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method might be long to run, especially on large study or when multiple\n        studies are modified. In those cases, it is recommended to use the `.modify_as_job()`\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n            SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n            as this breaks the DICOM model of the real world.\n        force\n            Some tags can't be changed without forcing it (e.g. StudyInstanceUID) for security reason\n        remove_private_tags\n            If True, remove the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n\n        Returns\n        -------\n        Study\n            Returns a new modified study or returns itself if keep=['StudyInstanceUID']\n            (in this case, the study itself is modified).\n\n        Examples\n        --------\n        ```python\n        # Create a modified study\n        modified_study = study.modify(replace={'StudyInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'}, force=True)\n        assert modified_study.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n\n        # Modify itself\n        study.modify(replace={'ReferringPhysicianName': 'last^first'}, keep=['StudyInstanceUID'], force=True)\n        assert study.referring_physician_name == 'last^first'\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        if 'StudyInstanceUID' in replace and not force:\n            raise errors.ModificationError('If StudyInstanceUID is replaced, `force` must be `True`')\n\n        data = {\n            'Asynchronous': False,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'RemovePrivateTags': remove_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n\n        try:\n            modified_study = self.client.post_studies_id_modify(self.id_, data)\n        except ReadTimeout:\n            raise ReadTimeout(\n                'Study modification is too long to process. '\n                'Use `.modify_as_job` or increase client.timeout.'\n            )\n\n        # Reset cache since a main DICOM tag may have be changed\n        self._main_dicom_tags = None\n\n        # if 'StudyInstanceUID' is not affected, the modified_study['ID'] is the same as self.id_\n        return Study(modified_study['ID'], self.client)\n\n    def modify_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                      force: bool = False, remove_private_tags: bool = False,\n                      keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                      private_creator: str = None) -&gt; Job:\n        \"\"\"Modify study and return a job\n\n        Launch a modification job. If keep=['StudyInstanceUID'] (with `force=True`),\n        then modified this study. If the StudyInstanceUID is not keeped, this creates\n        a new modified study.\n        Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n        Notes\n        -----\n        This method is useful when modifying large study or launching many\n        modification jobs. The jobs are sent to Orthanc and processed according\n        to the priority.\n\n        Parameters\n        ----------\n        remove\n            List of tag to remove\n        replace\n            Dictionary of {tag: new_content}\n        keep\n            Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n            SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n            as this breaks the DICOM model of the real world.\n        force\n            Allow the modification of tags related to DICOM identifiers, at the risk of breaking\n            the DICOM model of the real world.\n        remove_private_tags\n            If True, remove the private tags from the DICOM instances.\n        keep_source\n            If False, instructs Orthanc to the remove original resources.\n            By default, the original resources are kept in Orthanc.\n        priority\n            Priority of the job. The lower the value, the higher the priority.\n        permissive\n            If True, ignore errors during the individual steps of the job.\n        private_creator\n            The private creator to be used for private tags in Replace.\n\n        Returns\n        -------\n        Job\n            Return a Job object of the modification job.\n\n        Examples\n        --------\n        For large study (recommended)\n        ```python\n        job = study.modify_as_job(replace={'StudyDescription': 'a description'})\n        job.state  # You can follow the job state\n\n        job.wait_until_completion() # Or just wait on its completion\n        modified_study = Study(job.content['ID'], client)\n        assert modified_study.description == 'a description'\n        ```\n        Or modify the StudyInstanceUID\n        ```python\n        job = study.modify_as_job(\n            replace={'StudyInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'},\n            force=True\n        )\n        job.wait_until_completion() # Or just wait on its completion\n\n        modified_study = Study(job.content['ID'], client)\n        modified_study.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n        ```\n        Or keep the StudyInstanceUID\n        ```python\n        job = study.modify_as_job(\n            replace={'StudyDescription': 'a description'},\n            keep=['StudyInstanceUID'],\n            force=True\n        )\n        job.wait_until_completion()\n\n        assert study.description == 'a description'\n        ```\n        \"\"\"\n        remove = [] if remove is None else remove\n        replace = {} if replace is None else replace\n        keep = [] if keep is None else keep\n\n        if 'StudyInstanceUID' in replace and not force:\n            raise errors.ModificationError('If StudyInstanceUID is affected, `force` must be `True`')\n\n        data = {\n            'Asynchronous': True,\n            'Remove': remove,\n            'Replace': replace,\n            'Keep': keep,\n            'Force': force,\n            'RemovePrivateTags': remove_private_tags,\n            'KeepSource': keep_source,\n            'Priority': priority,\n            'Permissive': permissive,\n        }\n        if private_creator is not None:\n            data['PrivateCreator'] = private_creator\n\n        job_info = self.client.post_studies_id_modify(self.id_, data)\n\n        # Reset cache since a main DICOM tag may have be changed\n        self._main_dicom_tags = None\n\n        return Job(job_info['ID'], self.client)\n\n    def get_zip(self) -&gt; bytes:\n        \"\"\"Get the bytes of the zip file\n\n        Get the .zip file.\n\n        Returns\n        -------\n        bytes\n            Bytes of Zip file of the study.\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Orthanc, Study\n        a_study = Study('STUDY_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n        bytes_content = a_study.get_zip()\n        with open('study_zip_file_path.zip', 'wb') as file_handler:\n            file_handler.write(bytes_content)\n        ```\n        \"\"\"\n        return self.client.get_studies_id_archive(self.id_)\n\n    def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n        \"\"\"Download the zip file to a target path or buffer\n\n        This method is an alternative to the `.get_zip()` method for large files.\n        The `.get_zip()` method will pull all the data in a single GET call,\n        while `.download()` stream the data to a file or a buffer.\n        Favor the `.download()` method to avoid timeout and memory issues.\n\n        Examples\n        --------\n        ```python\n        from pyorthanc import Orthanc, Study\n        a_study = Study('STUDY_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n        # Download a zip\n        a_study.download('study.zip')\n\n        # Download a zip and show progress\n        a_study.download('study.zip', with_progres=True)\n\n        # Or download in a buffer in memory\n        buffer = io.BytesIO()\n        a_study.download(buffer)\n        # Now do whatever you want to do\n        buffer.seek(0)\n        zip_bytes = buffer.read()\n        ```\n        \"\"\"\n        self._download_file(f'{self.client.url}/studies/{self.id_}/archive', filepath, with_progres)\n\n    def get_shared_tags(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n        \"\"\"Retrieve the shared tags of the study\"\"\"\n        params = self._make_response_format_params(simplify, short)\n\n        return dict(self.client.get_studies_id_shared_tags(\n            self.id_,\n            params=params\n        ))\n\n    @property\n    def shared_tags(self) -&gt; Dict:\n        return self.get_shared_tags(simplify=True)\n\n    def remove_empty_series(self) -&gt; None:\n        \"\"\"Delete empty series.\"\"\"\n        if self._child_resources is None:\n            return\n\n        for series in self._child_resources:\n            series.remove_empty_instances()\n\n        self._child_resources = [series for series in self._child_resources if series._child_resources != []]\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.accession_number","title":"<code>accession_number</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.date","title":"<code>date</code>  <code>property</code>","text":"<p>Get study date</p> <p>The date have precision to the second (if available).</p> <p>Returns:</p> Type Description <code>datetime</code> <p>Study date</p>"},{"location":"api/resources/study/#pyorthanc.Study.description","title":"<code>description</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.institution_name","title":"<code>institution_name</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.is_stable","title":"<code>is_stable</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.labels","title":"<code>labels</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.last_update","title":"<code>last_update</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.legacy_viewer_url","title":"<code>legacy_viewer_url</code>  <code>property</code>","text":"<p>Get Study (legacy viewer) URL</p> <p>Returns:</p> Type Description <code>str</code> <p>URL of study (legacy viewer)</p>"},{"location":"api/resources/study/#pyorthanc.Study.parent_patient","title":"<code>parent_patient</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.patient_identifier","title":"<code>patient_identifier</code>  <code>property</code>","text":"<p>Get the Orthanc identifier of the parent patient</p>"},{"location":"api/resources/study/#pyorthanc.Study.patient_information","title":"<code>patient_information</code>  <code>property</code>","text":"<p>Get patient information</p>"},{"location":"api/resources/study/#pyorthanc.Study.referring_physician_name","title":"<code>referring_physician_name</code>  <code>property</code>","text":"<p>Get referring physician name</p>"},{"location":"api/resources/study/#pyorthanc.Study.requested_procedure_description","title":"<code>requested_procedure_description</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.requesting_physician","title":"<code>requesting_physician</code>  <code>property</code>","text":"<p>Get referring physician name</p>"},{"location":"api/resources/study/#pyorthanc.Study.series","title":"<code>series</code>  <code>property</code>","text":"<p>Get Study series</p>"},{"location":"api/resources/study/#pyorthanc.Study.shared_tags","title":"<code>shared_tags</code>  <code>property</code>","text":""},{"location":"api/resources/study/#pyorthanc.Study.study_id","title":"<code>study_id</code>  <code>property</code>","text":"<p>Get Study ID</p>"},{"location":"api/resources/study/#pyorthanc.Study.uid","title":"<code>uid</code>  <code>property</code>","text":"<p>Get StudyInstanceUID</p>"},{"location":"api/resources/study/#pyorthanc.Study.add_label","title":"<code>add_label(label)</code>","text":"Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def add_label(self, label: str) -&gt; None:\n    self.client.put_studies_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.anonymize","title":"<code>anonymize(remove=None, replace=None, keep=None, force=False, keep_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None, dicom_version=None)</code>","text":"<p>Anonymize study</p> <p>If no error has been raise, return an anonymous study. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method might be long to run, especially on large study or when multiple studies are anonymized. In those cases, it is recommended to use the <code>.anonymize_as_job()</code></p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>List of tag to keep unchanged</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. StudyID) for security reason</p> <code>False</code> <code>keep_private_tags</code> <code>bool</code> <p>If True, keep the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in replace.</p> <code>None</code> <code>dicom_version</code> <code>str</code> <p>Version of the DICOM standard to be used for anonymization. Check out configuration option DeidentifyLogsDicomVersion for possible values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Study</code> <p>A New anonymous study.</p> <p>Examples:</p> <p>```python new_study = study.anonymize()</p> <p>new_study_with_specific_study_id = study.anonymize(     replace={'StudyDescription': 'A description'} )</p> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def anonymize(self, remove: List = None, replace: Dict = None, keep: List = None,\n              force: bool = False, keep_private_tags: bool = False,\n              keep_source: bool = True, priority: int = 0, permissive: bool = False,\n              private_creator: str = None, dicom_version: str = None) -&gt; 'Study':\n    \"\"\"Anonymize study\n\n    If no error has been raise, return an anonymous study.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method might be long to run, especially on large study or when multiple\n    studies are anonymized. In those cases, it is recommended to use the `.anonymize_as_job()`\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        List of tag to keep unchanged\n    force\n        Some tags can't be changed without forcing it (e.g. StudyID) for security reason\n    keep_private_tags\n        If True, keep the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in replace.\n    dicom_version\n        Version of the DICOM standard to be used for anonymization.\n        Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n    Returns\n    -------\n    Study\n        A New anonymous study.\n\n    Examples\n    --------\n    ```python\n    new_study = study.anonymize()\n\n    new_study_with_specific_study_id = study.anonymize(\n        replace={'StudyDescription': 'A description'}\n    )\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    data = {\n        'Asynchronous': False,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'KeepPrivateTags': keep_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n    if dicom_version is not None:\n        data['DicomVersion'] = dicom_version\n\n    try:\n        anonymous_study = self.client.post_studies_id_anonymize(self.id_, data)\n    except ReadTimeout:\n        raise ReadTimeout(\n            'Study anonymization is too long to process. '\n            'Use `.anonymize_as_job` or increase client.timeout.'\n        )\n\n    return Study(anonymous_study['ID'], self.client)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.anonymize_as_job","title":"<code>anonymize_as_job(remove=None, replace=None, keep=None, force=False, keep_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None, dicom_version=None)</code>","text":"<p>Anonymize study and return a job</p> <p>Launch an anonymization job. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method is useful when anonymizing large study or launching many anonymization jobs. The jobs are sent to Orthanc and processed according to the priority.</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>List of tag to keep unchanged</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. StudyInstanceUID) for security reason</p> <code>False</code> <code>keep_private_tags</code> <code>bool</code> <p>If True, keep the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in replace.</p> <code>None</code> <code>dicom_version</code> <code>str</code> <p>Version of the DICOM standard to be used for anonymization. Check out configuration option DeidentifyLogsDicomVersion for possible values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Job</code> <p>Return a Job object of the anonymization job.</p> <p>Examples:</p> <p>For large study (recommended)</p> <pre><code>job = study.anonymize_as_job()\njob.state  # You can follow the job state\n\njob.wait_until_completion() # Or just wait on its completion\nnew_study = Study(job.content['ID'], orthanc)\n</code></pre> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def anonymize_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                     force: bool = False, keep_private_tags: bool = False,\n                     keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                     private_creator: str = None, dicom_version: str = None) -&gt; Job:\n    \"\"\"Anonymize study and return a job\n\n    Launch an anonymization job.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method is useful when anonymizing large study or launching many\n    anonymization jobs. The jobs are sent to Orthanc and processed according\n    to the priority.\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        List of tag to keep unchanged\n    force\n        Some tags can't be changed without forcing it (e.g. StudyInstanceUID) for security reason\n    keep_private_tags\n        If True, keep the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in replace.\n    dicom_version\n        Version of the DICOM standard to be used for anonymization.\n        Check out configuration option DeidentifyLogsDicomVersion for possible values.\n\n    Returns\n    -------\n    Job\n        Return a Job object of the anonymization job.\n\n    Examples\n    --------\n    For large study (recommended)\n    ```python\n    job = study.anonymize_as_job()\n    job.state  # You can follow the job state\n\n    job.wait_until_completion() # Or just wait on its completion\n    new_study = Study(job.content['ID'], orthanc)\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    data = {\n        'Asynchronous': True,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'KeepPrivateTags': keep_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n    if dicom_version is not None:\n        data['DicomVersion'] = dicom_version\n\n    job_info = self.client.post_studies_id_anonymize(self.id_, data)\n\n    return Job(job_info['ID'], self.client)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.download","title":"<code>download(filepath, with_progres=False)</code>","text":"<p>Download the zip file to a target path or buffer</p> <p>This method is an alternative to the <code>.get_zip()</code> method for large files. The <code>.get_zip()</code> method will pull all the data in a single GET call, while <code>.download()</code> stream the data to a file or a buffer. Favor the <code>.download()</code> method to avoid timeout and memory issues.</p> <p>Examples:</p> <pre><code>from pyorthanc import Orthanc, Study\na_study = Study('STUDY_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n# Download a zip\na_study.download('study.zip')\n\n# Download a zip and show progress\na_study.download('study.zip', with_progres=True)\n\n# Or download in a buffer in memory\nbuffer = io.BytesIO()\na_study.download(buffer)\n# Now do whatever you want to do\nbuffer.seek(0)\nzip_bytes = buffer.read()\n</code></pre> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def download(self, filepath: Union[str, BinaryIO], with_progres: bool = False) -&gt; None:\n    \"\"\"Download the zip file to a target path or buffer\n\n    This method is an alternative to the `.get_zip()` method for large files.\n    The `.get_zip()` method will pull all the data in a single GET call,\n    while `.download()` stream the data to a file or a buffer.\n    Favor the `.download()` method to avoid timeout and memory issues.\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Orthanc, Study\n    a_study = Study('STUDY_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n    # Download a zip\n    a_study.download('study.zip')\n\n    # Download a zip and show progress\n    a_study.download('study.zip', with_progres=True)\n\n    # Or download in a buffer in memory\n    buffer = io.BytesIO()\n    a_study.download(buffer)\n    # Now do whatever you want to do\n    buffer.seek(0)\n    zip_bytes = buffer.read()\n    ```\n    \"\"\"\n    self._download_file(f'{self.client.url}/studies/{self.id_}/archive', filepath, with_progres)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.get_main_information","title":"<code>get_main_information()</code>","text":"<p>Get Study information</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary of study information</p> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def get_main_information(self) -&gt; Dict:\n    \"\"\"Get Study information\n\n    Returns\n    -------\n    Dict\n        Dictionary of study information\n    \"\"\"\n    return self.client.get_studies_id(self.id_)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.get_shared_tags","title":"<code>get_shared_tags(simplify=False, short=False)</code>","text":"<p>Retrieve the shared tags of the study</p> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def get_shared_tags(self, simplify: bool = False, short: bool = False) -&gt; Dict:\n    \"\"\"Retrieve the shared tags of the study\"\"\"\n    params = self._make_response_format_params(simplify, short)\n\n    return dict(self.client.get_studies_id_shared_tags(\n        self.id_,\n        params=params\n    ))\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.get_zip","title":"<code>get_zip()</code>","text":"<p>Get the bytes of the zip file</p> <p>Get the .zip file.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes of Zip file of the study.</p> <p>Examples:</p> <pre><code>from pyorthanc import Orthanc, Study\na_study = Study('STUDY_IDENTIFIER', Orthanc('http://localhost:8042'))\n\nbytes_content = a_study.get_zip()\nwith open('study_zip_file_path.zip', 'wb') as file_handler:\n    file_handler.write(bytes_content)\n</code></pre> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def get_zip(self) -&gt; bytes:\n    \"\"\"Get the bytes of the zip file\n\n    Get the .zip file.\n\n    Returns\n    -------\n    bytes\n        Bytes of Zip file of the study.\n\n    Examples\n    --------\n    ```python\n    from pyorthanc import Orthanc, Study\n    a_study = Study('STUDY_IDENTIFIER', Orthanc('http://localhost:8042'))\n\n    bytes_content = a_study.get_zip()\n    with open('study_zip_file_path.zip', 'wb') as file_handler:\n        file_handler.write(bytes_content)\n    ```\n    \"\"\"\n    return self.client.get_studies_id_archive(self.id_)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.modify","title":"<code>modify(remove=None, replace=None, keep=None, force=False, remove_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None)</code>","text":"<p>Modify study</p> <p>If no error has been raise, then create a modified version of the study. If keep=['StudyInstanceUID'] and force=True are use, then the study itself is changed. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method might be long to run, especially on large study or when multiple studies are modified. In those cases, it is recommended to use the <code>.modify_as_job()</code></p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>Keep the original value of the specified tags, to be chosen among the StudyInstanceUID, SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Some tags can't be changed without forcing it (e.g. StudyInstanceUID) for security reason</p> <code>False</code> <code>remove_private_tags</code> <code>bool</code> <p>If True, remove the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <p>Returns:</p> Type Description <code>Study</code> <p>Returns a new modified study or returns itself if keep=['StudyInstanceUID'] (in this case, the study itself is modified).</p> <p>Examples:</p> <pre><code># Create a modified study\nmodified_study = study.modify(replace={'StudyInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'}, force=True)\nassert modified_study.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n\n# Modify itself\nstudy.modify(replace={'ReferringPhysicianName': 'last^first'}, keep=['StudyInstanceUID'], force=True)\nassert study.referring_physician_name == 'last^first'\n</code></pre> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def modify(self, remove: List = None, replace: Dict = None, keep: List = None,\n           force: bool = False, remove_private_tags: bool = False,\n           keep_source: bool = True, priority: int = 0, permissive: bool = False,\n           private_creator: str = None) -&gt; 'Study':\n    \"\"\"Modify study\n\n    If no error has been raise, then create a modified version of the study.\n    If keep=['StudyInstanceUID'] and force=True are use, then the study itself is changed.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method might be long to run, especially on large study or when multiple\n    studies are modified. In those cases, it is recommended to use the `.modify_as_job()`\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n        SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n        as this breaks the DICOM model of the real world.\n    force\n        Some tags can't be changed without forcing it (e.g. StudyInstanceUID) for security reason\n    remove_private_tags\n        If True, remove the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n\n    Returns\n    -------\n    Study\n        Returns a new modified study or returns itself if keep=['StudyInstanceUID']\n        (in this case, the study itself is modified).\n\n    Examples\n    --------\n    ```python\n    # Create a modified study\n    modified_study = study.modify(replace={'StudyInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'}, force=True)\n    assert modified_study.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n\n    # Modify itself\n    study.modify(replace={'ReferringPhysicianName': 'last^first'}, keep=['StudyInstanceUID'], force=True)\n    assert study.referring_physician_name == 'last^first'\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    if 'StudyInstanceUID' in replace and not force:\n        raise errors.ModificationError('If StudyInstanceUID is replaced, `force` must be `True`')\n\n    data = {\n        'Asynchronous': False,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'RemovePrivateTags': remove_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n\n    try:\n        modified_study = self.client.post_studies_id_modify(self.id_, data)\n    except ReadTimeout:\n        raise ReadTimeout(\n            'Study modification is too long to process. '\n            'Use `.modify_as_job` or increase client.timeout.'\n        )\n\n    # Reset cache since a main DICOM tag may have be changed\n    self._main_dicom_tags = None\n\n    # if 'StudyInstanceUID' is not affected, the modified_study['ID'] is the same as self.id_\n    return Study(modified_study['ID'], self.client)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.modify_as_job","title":"<code>modify_as_job(remove=None, replace=None, keep=None, force=False, remove_private_tags=False, keep_source=True, priority=0, permissive=False, private_creator=None)</code>","text":"<p>Modify study and return a job</p> <p>Launch a modification job. If keep=['StudyInstanceUID'] (with <code>force=True</code>), then modified this study. If the StudyInstanceUID is not keeped, this creates a new modified study. Documentation: https://book.orthanc-server.com/users/anonymization.html</p> Notes <p>This method is useful when modifying large study or launching many modification jobs. The jobs are sent to Orthanc and processed according to the priority.</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>List</code> <p>List of tag to remove</p> <code>None</code> <code>replace</code> <code>Dict</code> <p>Dictionary of {tag: new_content}</p> <code>None</code> <code>keep</code> <code>List</code> <p>Keep the original value of the specified tags, to be chosen among the StudyInstanceUID, SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible, as this breaks the DICOM model of the real world.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Allow the modification of tags related to DICOM identifiers, at the risk of breaking the DICOM model of the real world.</p> <code>False</code> <code>remove_private_tags</code> <code>bool</code> <p>If True, remove the private tags from the DICOM instances.</p> <code>False</code> <code>keep_source</code> <code>bool</code> <p>If False, instructs Orthanc to the remove original resources. By default, the original resources are kept in Orthanc.</p> <code>True</code> <code>priority</code> <code>int</code> <p>Priority of the job. The lower the value, the higher the priority.</p> <code>0</code> <code>permissive</code> <code>bool</code> <p>If True, ignore errors during the individual steps of the job.</p> <code>False</code> <code>private_creator</code> <code>str</code> <p>The private creator to be used for private tags in Replace.</p> <code>None</code> <p>Returns:</p> Type Description <code>Job</code> <p>Return a Job object of the modification job.</p> <p>Examples:</p> <p>For large study (recommended)</p> <pre><code>job = study.modify_as_job(replace={'StudyDescription': 'a description'})\njob.state  # You can follow the job state\n\njob.wait_until_completion() # Or just wait on its completion\nmodified_study = Study(job.content['ID'], client)\nassert modified_study.description == 'a description'\n</code></pre> <p>Or modify the StudyInstanceUID</p> <pre><code>job = study.modify_as_job(\n    replace={'StudyInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'},\n    force=True\n)\njob.wait_until_completion() # Or just wait on its completion\n\nmodified_study = Study(job.content['ID'], client)\nmodified_study.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n</code></pre> <p>Or keep the StudyInstanceUID</p> <pre><code>job = study.modify_as_job(\n    replace={'StudyDescription': 'a description'},\n    keep=['StudyInstanceUID'],\n    force=True\n)\njob.wait_until_completion()\n\nassert study.description == 'a description'\n</code></pre> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def modify_as_job(self, remove: List = None, replace: Dict = None, keep: List = None,\n                  force: bool = False, remove_private_tags: bool = False,\n                  keep_source: bool = True, priority: int = 0, permissive: bool = False,\n                  private_creator: str = None) -&gt; Job:\n    \"\"\"Modify study and return a job\n\n    Launch a modification job. If keep=['StudyInstanceUID'] (with `force=True`),\n    then modified this study. If the StudyInstanceUID is not keeped, this creates\n    a new modified study.\n    Documentation: https://book.orthanc-server.com/users/anonymization.html\n\n    Notes\n    -----\n    This method is useful when modifying large study or launching many\n    modification jobs. The jobs are sent to Orthanc and processed according\n    to the priority.\n\n    Parameters\n    ----------\n    remove\n        List of tag to remove\n    replace\n        Dictionary of {tag: new_content}\n    keep\n        Keep the original value of the specified tags, to be chosen among the StudyInstanceUID,\n        SeriesInstanceUID and SOPInstanceUID tags. Avoid this feature as much as possible,\n        as this breaks the DICOM model of the real world.\n    force\n        Allow the modification of tags related to DICOM identifiers, at the risk of breaking\n        the DICOM model of the real world.\n    remove_private_tags\n        If True, remove the private tags from the DICOM instances.\n    keep_source\n        If False, instructs Orthanc to the remove original resources.\n        By default, the original resources are kept in Orthanc.\n    priority\n        Priority of the job. The lower the value, the higher the priority.\n    permissive\n        If True, ignore errors during the individual steps of the job.\n    private_creator\n        The private creator to be used for private tags in Replace.\n\n    Returns\n    -------\n    Job\n        Return a Job object of the modification job.\n\n    Examples\n    --------\n    For large study (recommended)\n    ```python\n    job = study.modify_as_job(replace={'StudyDescription': 'a description'})\n    job.state  # You can follow the job state\n\n    job.wait_until_completion() # Or just wait on its completion\n    modified_study = Study(job.content['ID'], client)\n    assert modified_study.description == 'a description'\n    ```\n    Or modify the StudyInstanceUID\n    ```python\n    job = study.modify_as_job(\n        replace={'StudyInstanceUID': '1.2.840.113745.101000.1008000.38048.4626.5933732'},\n        force=True\n    )\n    job.wait_until_completion() # Or just wait on its completion\n\n    modified_study = Study(job.content['ID'], client)\n    modified_study.uid == '1.2.840.113745.101000.1008000.38048.4626.5933732'\n    ```\n    Or keep the StudyInstanceUID\n    ```python\n    job = study.modify_as_job(\n        replace={'StudyDescription': 'a description'},\n        keep=['StudyInstanceUID'],\n        force=True\n    )\n    job.wait_until_completion()\n\n    assert study.description == 'a description'\n    ```\n    \"\"\"\n    remove = [] if remove is None else remove\n    replace = {} if replace is None else replace\n    keep = [] if keep is None else keep\n\n    if 'StudyInstanceUID' in replace and not force:\n        raise errors.ModificationError('If StudyInstanceUID is affected, `force` must be `True`')\n\n    data = {\n        'Asynchronous': True,\n        'Remove': remove,\n        'Replace': replace,\n        'Keep': keep,\n        'Force': force,\n        'RemovePrivateTags': remove_private_tags,\n        'KeepSource': keep_source,\n        'Priority': priority,\n        'Permissive': permissive,\n    }\n    if private_creator is not None:\n        data['PrivateCreator'] = private_creator\n\n    job_info = self.client.post_studies_id_modify(self.id_, data)\n\n    # Reset cache since a main DICOM tag may have be changed\n    self._main_dicom_tags = None\n\n    return Job(job_info['ID'], self.client)\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.remove_empty_series","title":"<code>remove_empty_series()</code>","text":"<p>Delete empty series.</p> Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def remove_empty_series(self) -&gt; None:\n    \"\"\"Delete empty series.\"\"\"\n    if self._child_resources is None:\n        return\n\n    for series in self._child_resources:\n        series.remove_empty_instances()\n\n    self._child_resources = [series for series in self._child_resources if series._child_resources != []]\n</code></pre>"},{"location":"api/resources/study/#pyorthanc.Study.remove_label","title":"<code>remove_label(label)</code>","text":"Source code in <code>pyorthanc/_resources/study.py</code> <pre><code>def remove_label(self, label):\n    self.client.delete_studies_id_labels_label(self.id_, label)\n</code></pre>"},{"location":"paper/paper/","title":"Summary","text":"<p>PyOrthanc is an open-source Python library that provides a comprehensive interface for interacting with Orthanc [@jodogne2018orthanc], a lightweight, versatile, open-source DICOM server for medical imaging in healthcare and  research environments.</p>","tags":["Python","Orthanc","Medical physics"]},{"location":"paper/paper/#statement-of-need","title":"Statement of need","text":"<p>Digital Imaging and Communications in Medicine (DICOM) [@dicom2020] is the standard for managing and transmitting  medical images. Orthanc has gained popularity for its lightweight nature and versatility. However, programmatically  interacting with Orthanc servers from its REST API can be complex, especially for those unfamiliar with RESTful APIs.  PyOrthanc addresses this challenge by providing a client-side, Pythonic interface to Orthanc servers, abstracting away  the complexities of HTTP requests and DICOM data handling. This is in contrast to the Orthanc Python plugin, which  offers a powerful means to extend Orthanc's functionality directly within the server environment.</p>","tags":["Python","Orthanc","Medical physics"]},{"location":"paper/paper/#features-and-functionalities","title":"Features and Functionalities","text":"<p>PyOrthanc offers a wide range of features that facilitate data manipulation with Orthanc servers:</p> <ol> <li> <p>Orthanc\u2019s REST API: PyOrthanc implements Python bindings for all Orthanc REST API routes. All the functionalities exposed in Orthanc are therefore easily accessible from a Pythonic interface.</p> </li> <li> <p>Patient, Study, Series, and Instance: The library provides Python classes that ease data management by following DICOM-level concepts.</p> </li> <li> <p>Querying: PyOrthanc provides utility functions to perform complex queries. </p> </li> <li> <p>Anonymization: PyOrthanc exposes Orthanc\u2019s anonymization functionalities, which are useful for research and data sharing. </p> </li> <li> <p>Modalities: Users can easily command Orthanc servers to invoke DICOM Message Service Element (DIMSE) services     with other connected modalities, such as Computerized Tomography (CT) scan and hospital Picture Archiving and Communication Systems (PACS),     which allows querying, storing, and retrieving DICOM data. </p> </li> <li> <p>Jobs: PyOrthanc allows to monitoring of long-running tasks on the Orthanc server. </p> </li> <li> <p>Orthanc SDK: PyOrthanc provides a mock of the Orthanc SDK, which brings type hints and autocomplete (intelliSense) when working with the Python Plugin.</p> </li> </ol>","tags":["Python","Orthanc","Medical physics"]},{"location":"paper/paper/#architecture-and-design","title":"Architecture and Design","text":"<p>The core of PyOrthanc is the Orthanc class, which handles the connection to the Orthanc server and serves as the entry  point for all operations. This class manages authentication, request formatting, and response parsing, presenting a  clean API to the user. It uses Python's httpx [@coles2024httpx] library for HTTP communications. The Orthanc class is  used by all the utility functions and classes in PyOrthanc. Note that the class is programmatically generated with  simple-openapi-client [@couture2024simple] for each new version of the Orthanc REST API.</p> <p>The library is structured around key DICOM concepts, with main classes representing DICOM-level entities such as  patients, studies, series, and instances. These classes provide intuitive methods for common operations, such as  querying level-specific information, launching anonymization jobs, and downloading data. PyOrthanc also provides  utility classes and functions, useful to monitor long-running tasks within Orthanc or perform complex queries.</p>","tags":["Python","Orthanc","Medical physics"]},{"location":"paper/paper/#use-cases-and-applications","title":"Use Cases and Applications","text":"<p>PyOrthanc finds applications in various medical imaging scenarios:</p> <ol> <li> <p>Research Data Management: Researchers can use PyOrthanc to automate the process of collecting, anonymizing, and organizing DICOM data.</p> </li> <li> <p>Quality Assurance: The library can be used to develop scripts for checking DICOM data and metadata consistency across large datasets.</p> </li> <li> <p>Clinical Workflow Integration: PyOrthanc can be integrated into clinical workflows, automating tasks such as routing studies to appropriate specialists or triggering analysis pipelines.</p> </li> </ol>","tags":["Python","Orthanc","Medical physics"]},{"location":"paper/paper/#performance-and-scalability","title":"Performance and Scalability","text":"<p>PyOrthanc is designed to handle large-scale DICOM operations efficiently. The library implements connection pooling  and supports asynchronous operations for improved performance when dealing with multiple concurrent requests.</p>","tags":["Python","Orthanc","Medical physics"]},{"location":"paper/paper/#conclusion","title":"Conclusion","text":"<p>PyOrthanc provides a powerful and user-friendly interface to Orthanc DICOM servers, enabling Python developers to easily  integrate DICOM functionality into their applications. By abstracting the complexities of the Orthanc REST API,  PyOrthanc accelerates the development of medical imaging applications and workflows. As the field of medical imaging  informatics continues to evolve, tools like PyOrthanc play an important role in advancing research and improving  clinical practice by making the complex task of data management easier.</p>","tags":["Python","Orthanc","Medical physics"]},{"location":"paper/paper/#references","title":"References","text":"","tags":["Python","Orthanc","Medical physics"]},{"location":"tutorial/examples/","title":"Examples","text":"<p>Here is a list of examples with pyorthanc</p>"},{"location":"tutorial/examples/#find-data-on-your-orthanc-server","title":"Find data on your Orthanc server","text":"<p>This notebook is a walkthrough  on how a user can query and pull data from it's Orthanc server.</p>"},{"location":"tutorial/examples/#orthanc-as-a-tool-to-query-and-retrieve-data-from-the-hospital-pacs","title":"Orthanc as a tool to query and retrieve data from the hospital PACS","text":"<p>This notebook is a walkthrough  on how a user can query and pull data from other modality connected to an Orthanc Server. A modality can be for example a hospital Picture Archiving and Communication Systems (PACS) or a Computerized Tomography (CT) scan.</p>"},{"location":"tutorial/examples/#transfer-data-from-a-pacs-to-an-orthanc-server","title":"Transfer data from a PACS to an Orthanc server","text":"<p>Transfer data from a PACS to a Orthanc server </p>"},{"location":"tutorial/quickstart/","title":"First steps","text":""},{"location":"tutorial/quickstart/#orthanc-installation","title":"Orthanc installation","text":"<p>For testing purposes, you can use one of this solution to install Orthanc</p> <ul> <li>Orthanc's demo server (https://orthanc.uclouvain.be/demo)</li> <li>Deploy it locally with docker using <code>docker run -p 8042:8042 -p 4242:4242 orthancteam/orthanc</code></li> <li>Using the docker-compose from the pyorthanc repo<ul> <li>For this, clone the repo (<code>git clone https://github.com/gacou54/pyorthanc</code>)</li> <li>Got in the repo (<code>cd pyorthanc</code>)</li> <li>Start orthanc (<code>docker compose up orthanc1</code>)</li> </ul> </li> <li>Other method to install Orthanc are available here</li> </ul>"},{"location":"tutorial/quickstart/#pyorthanc-installation","title":"PyOrthanc installation","text":"<pre><code>pip install pyorthanc\npip install pyorthanc[all]  # (Optional) For progress bar when downloading DICOM data\n</code></pre>"},{"location":"tutorial/quickstart/#getting-started","title":"Getting started","text":""},{"location":"tutorial/quickstart/#connect-to-orthanc","title":"Connect to Orthanc","text":"<p>Here are some quick how to examples to use pyorthanc</p> <pre><code>from pyorthanc import Orthanc\n\northanc = Orthanc(url='http://localhost:8042/', username='orthanc', password='orthanc')\n</code></pre>"},{"location":"tutorial/quickstart/#upload-dicom-files-to-orthanc","title":"Upload DICOM files to Orthanc:","text":"<pre><code>import pyorthanc\n\npyorthanc.upload(orthanc, 'A_DICOM_INSTANCE_PATH.dcm')\n</code></pre>"},{"location":"tutorial/quickstart/#getting-list-of-connected-remote-modalities","title":"Getting list of connected remote modalities:","text":"<pre><code>modalities = orthanc.get_modalities()\n</code></pre>"},{"location":"tutorial/quickstart/#query-c-find-and-retrieve-c-move-from-remote-modality","title":"Query (C-Find) and Retrieve (C-Move) from remote modality:","text":"<pre><code>from pyorthanc import Modality\n\nmodality = Modality(orthanc, 'modality')\n\n# C-Echo\nassert modality.echo()  # Test the connection\n\n# Query (C-Find) on modality\ndata = {'Level': 'Study', 'Query': {'PatientID': '*'}}\nquery_response = modality.query(data=data)\n\n# Inspect the answer\nanswer = modality.get_query_answers()[query_response['ID']]\nprint(answer)\n\n# Retrieve (C-Move) results of query on a Orthanc itself, or to a target modality (AET)\nmodality.move(query_response['ID'])\n# or\nmodality.move(query_response['ID'], {'TargetAet': 'OTHER_AET'})\n</code></pre>"},{"location":"tutorial/quickstart/#find-and-download-patients-according-to-criteria","title":"Find and download patients according to criteria:","text":"<pre><code>from pyorthanc import find_patients\n\npatients = find_patients(\n    client=orthanc,\n    query={'PatientName': '*Gabriel'},  # Filter on PatientName\n    labels=['a-label']  # Filter on patients with the 'a-label'\n)\n</code></pre> <p>Download the patients data</p> <pre><code>import os\nfrom pyorthanc import retrieve_and_write_patients\n\nos.makedirs('./data')  # Ensure that the target directory exists\n\nfor patient in patients:\n    patient.download(f'./data/patient-{patient.patient_id}.zip', with_progres=False)\n\n# As a directory tree DICOM files (patients -&gt; studies -&gt; series -&gt; instances)\nretrieve_and_write_patients(patients, './data/')\n</code></pre> <p>Or manipulates the Patient object</p> <pre><code>patient = patients[0]\n\npatient.name\npatient.is_stable\npatient.last_update\n\npatient.labels\npatient.remove_label('a-label')\npatient.add_label('a-new-label')\n...\n</code></pre> <p>It is also possible to query the other resource levels</p> <pre><code>from pyorthanc import find_studies, find_series, find_instances\n\nstudies = find_studies(client=orthanc, query={...}, labels=[...])\nseries = find_series(client=orthanc, query={...}, labels=[...])\ninstances = find_instances(client=orthanc, query={...}, labels=[...])\n</code></pre> <p>If you have the Patient ID, StudyInstanceUID, the SeriesInstanceUID and/or the SOPInstanceUID, you can generate the Orthanc IDs:</p> <pre><code>from pyorthanc import util, Patient\n\nutil.to_orthanc_patient_id('patient_id')  # '8dfa510b-b29ad31a-b2139fbf-b9929710-2edfa5c2'\nutil.to_orthanc_study_id('patient_id', 'study_uid')  # 'f9c33ef9-0bcdc38b-c216e9e8-8dbd62c1-28e4815c'\nutil.to_orthanc_series_id('patient_id', 'study_uid', 'series_uid')  # 'beceea8b-5424ff8c-3c76fe2e-edfed858-819fe6e1'\nutil.to_orthanc_instance_id('patient_id', 'study_uid', 'series_uid', 'instance_uid')  # '0e7848a0-4337f771-bda13733-150f651b-dfddd545'\n\npatient = Patient('8dfa510b-b29ad31a-b2139fbf-b9929710-2edfa5c2', client)\n</code></pre>"},{"location":"tutorial/quickstart/#anonymize-patient","title":"Anonymize patient","text":"<p>Resources (<code>Patient</code>, <code>Study</code>, <code>Series</code>, <code>Instance</code>) can be easily anonymized.</p> <pre><code>import pyorthanc\n\northanc_patient_id = client.get_patients()[0]\npatient = pyorthanc.Patient(orthanc_patient_id, client)\n</code></pre> <p>Waiting for the anonymization process (this may raise a TimeOutError)</p> <pre><code>new_patient = patient.anonymize()\nnew_patient_with_given_patient_id = patient.anonymize(\n   keep=['PatientName'],\n   replace={'PatientID': 'TheNewPatientID'},\n   force=True  # Needed when changing PatientID/StudyInstanceUID/SeriesInstanceUID/SOPInstanceUID\n)\n</code></pre> <p>For long-running job (i.e. large patient) or to submit many anonymization jobs at the same time, use</p> <pre><code>job = patient.anonymize_as_job()\njob.state  # You can follow the job state\n\njob.wait_until_completion() # Or just wait on its completion\nnew_patient = pyorthanc.Patient(job.content['ID'], client)\n</code></pre>"},{"location":"tutorial/quickstart/#find-resources-with-complex-filters-or-filter-on-many-resource-levels","title":"Find resources with complex filters or filter on many resource levels","text":"<p>The <code>pyorthanc.find()</code> function allow to find resources with filters on many levels, or with complex filter. Each filter function takes an object that correspond to the resource level and should return a boolean value.</p> <p>Note that when using the <code>find()</code> function, the children of the resources <code>Patient/Study/Series/Instance</code> are only query once and then filtered accordingly to the provided filters.</p> <pre><code>from datetime import datetime\nfrom pyorthanc import find\n\npatients = find(\n    orthanc,\n    patient_filter=lambda patient: patient.last_update &gt; datetime(year=2023, month=10, day=1),\n    study_filter=lambda study: 'thorax' in study.description.lower(),\n    series_filter=lambda series: series.modality == 'CT'\n)\n</code></pre> <p>Note that this function may take a while to run since each resource level is filtered.  Using <code>find()</code> on large Orthanc server is not recommended.</p>"},{"location":"tutorial/quickstart/#develop-with-the-orthancs-python-plugin","title":"Develop with the Orthanc's Python Plugin","text":"<p>The <code>orthanc_sdk</code> is useful when developing with the Orthanc's Python Plugin, it exposes <code>orthanc</code> module when available (i.e. used as an Orthanc script), or expose the functions/classes signatures when not for linting and autocomplete.</p> <p>Use it the same way you would use the Python Plugin:</p> <pre><code># Has the same signature as `import orthanc`\nfrom pyorthanc import orthanc_sdk \n\ndef on_get(output: orthanc_sdk.RestOutput, *_, **__):\n    output.AnswerBuffer('ok', 'text/plain')\n\northanc_sdk.RegisterRestCallback('/test', on_get)\n</code></pre>"},{"location":"tutorial/quickstart/#for-examples-of-usage-see-this","title":"For examples of usage, see this","text":""}]}